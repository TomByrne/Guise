<haxe>
	<class path="Array" params="T" file="C:\Motion-Twin\haxe\std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="C:\Motion-Twin\haxe\std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Date" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/Date.hx">
		<now public="1" set="method" line="55" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="59" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="65" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method" line="53">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method" line="51">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the week day of the date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method" line="49">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the day of the date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method" line="47">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the month of the date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method" line="45">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the full year of the date.</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method" line="43">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the seconds of the date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method" line="41">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the minutes value of the date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method" line="39">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the hours value of the date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method" line="35">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.</haxe_doc>
		</getTime>
		<mSeconds><c path="Float"/></mSeconds>
		<new public="1" set="method" line="31">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new date object.</haxe_doc>
		</new>
		<haxe_doc>The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Enum" params="T" file="C:\Motion-Twin\haxe\std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="C:\Motion-Twin\haxe\std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="GraphicsComparisonTest" params="" file="../testSrc/GraphicsComparisonTest.hx">
		<main public="1" set="method" line="38" static="1"><f a=""><e path="Void"/></f></main>
		<addTextInput set="method" line="89"><f a="parent:prompt:x:y:w:h">
	<c path="composure.core.ComposeGroup"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addTextInput>
		<addLabel set="method" line="84"><f a="parent:text:x:y:w:h">
	<c path="composure.core.ComposeGroup"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addLabel>
		<addButton set="method" line="78"><f a="parent:text:x:y:w:h:selectable">
	<c path="composure.core.ComposeGroup"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addButton>
		<addControls public="1" set="method" line="71"><f a="x:parent">
	<c path="Float"/>
	<c path="composure.core.ComposeGroup"/>
	<e path="Void"/>
</f></addControls>
		<window><c path="guise.core.GuiseItem"/></window>
		<root><c path="composure.core.ComposeRoot"/></root>
		<new public="1" set="method" line="45"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="Hash" params="T" file="C:\Motion-Twin\haxe\std/cpp/_std/Hash.hx">
		<toString public="1" set="method" line="76">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="61">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="45">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="41">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="37">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="33">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<__Internal><d/></__Internal>
		<new public="1" set="method" line="29">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntHash" params="T" file="C:\Motion-Twin\haxe\std/cpp/_std/IntHash.hx">
		<toString public="1" set="method" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="55">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><d/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="C:\Motion-Twin\haxe\std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="C:\Motion-Twin\haxe\std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an [Array] from an [Iterable]</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a [List] from an [Iterable]</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to [map], but also pass an index for each item iterated.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if at least one element of the iterable is found by using the specific function.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if all elements of the iterable have the specified property defined by [f].</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>Call the function 'f' on all elements of the [Iterable] 'it'.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Return the list of elements matching the function 'f'</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional 'fold' using an [Iterable]</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>Count the number of elements in an [Iterable] having [pred] returning true.</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an iterable does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a list containing all items of 'a' followed by all items of 'b'</haxe_doc>
		</concat>
		<haxe_doc>The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.</haxe_doc>
	</class>
	<class path="LazyInst" params="" file="../../Composure/src/LazyInst.hx">
		<_metaName line="16" static="1"><c path="String"/></_metaName>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="List" params="T" file="C:\Motion-Twin\haxe\std/List.hx">
		<map public="1" params="X" set="method" line="246">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted
		by the function [f].</haxe_doc>
		</map>
		<filter public="1" set="method" line="230">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].</haxe_doc>
		</filter>
		<join public="1" set="method" line="211">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Join the element of the list by using the separator [sep].</haxe_doc>
		</join>
		<toString public="1" set="method" line="191">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Makes the list empty.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="98">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<last public="1" set="method" line="88">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of the list, or null
		if the list is empty.</haxe_doc>
		</last>
		<first public="1" set="method" line="80">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Push an element at the beginning of the list.</haxe_doc>
		</push>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the end of the list.</haxe_doc>
		</add>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
	</class>
	<class path="Math" params="" file="C:\Motion-Twin\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/Reflect.hx">
		<hasField public="1" set="method" line="29" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="33" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="42" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="46" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" line="51" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="58" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="65" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="69" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="73" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="81" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="88" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="93" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="104" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/Std.hx">
		<is public="1" set="method" line="27" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="31" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" set="method" line="35" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="39" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="47" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="Null" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="C:\Motion-Twin\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="47">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addChar public="1" get="inline" set="null" line="43">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<addSub public="1" get="inline" set="null" line="39">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<add public="1" get="inline" set="null" line="35">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="Array"><d/></c></b>
		<new public="1" set="method" line="31">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="StringTools" params="" file="C:\Motion-Twin\haxe\std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<class path="cpp.Lib" params="" file="C:\Motion-Twin\haxe\std/cpp/Lib.hx">
		<load public="1" set="method" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Cpp primitive from a DLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="44" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>Tries to load, and always returns a valid function, but the function may throw
		if called.</haxe_doc>
		</loadLazy>
		<rethrow public="1" set="method" line="60" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></rethrow>
		<stringReference public="1" set="method" line="62" static="1"><f a="inExp">
	<d/>
	<e path="Void"/>
</f></stringReference>
		<print public="1" set="method" line="67" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output.</haxe_doc>
		</print>
		<haxeToNeko public="1" set="method" line="75" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</haxeToNeko>
		<nekoToHaxe public="1" set="method" line="83" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>This function is used to make porting from neko to cpp easy.
		It does not need to do anything because the c-code can work with any Dynamic</haxe_doc>
		</nekoToHaxe>
		<println public="1" set="method" line="89" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output followed by a newline character.</haxe_doc>
		</println>
	</class>
	<class path="Sys" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/Sys.hx">
		<print public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="32" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<stdin public="1" set="method" line="37" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="41" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="45" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<getChar public="1" set="method" line="49" static="1">
			<f a="echo">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<args public="1" set="method" line="53" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="57" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="64" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<sleep public="1" set="method" line="68" static="1">
			<f a="seconds">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="72" static="1">
			<f a="loc">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="76" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="84" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<escapeArgument set="method" line="88" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="102" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="111" static="1">
			<f a="code">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="115" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="119" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="123" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<environment public="1" set="method" line="127" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<get_env line="138" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></get_env>
		<put_env line="139" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></put_env>
		<_sleep line="140" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="141" static="1"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="142" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="143" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></set_cwd>
		<sys_string line="144" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="145" static="1"><f a="">
	<c path="String"/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="146" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="147" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="148" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="149" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="150" static="1"><f a=""><c path="Array"><c path="String"/></c></f></sys_env>
		<file_stdin line="152" static="1"><f a=""><unknown/></f></file_stdin>
		<file_stdout line="153" static="1"><f a=""><unknown/></f></file_stdout>
		<file_stderr line="154" static="1"><f a=""><unknown/></f></file_stderr>
		<getch line="156" static="1"><f a="">
	<e path="Bool"/>
	<c path="Int"/>
</f></getch>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="39" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="50" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="56" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="60" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="66" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="70" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="77" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="84" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="90" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="94" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="100" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="106" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="110" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="114" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="118" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="134" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="138" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="142" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="147" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="151" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="cmtc.ds.hash.ObjectHash" params="Key:Val" file="../../Composure/src/cmtc/ds/hash/ObjectHash.hx">
		<SAFE_NUM get="inline" set="null" line="15" static="1"><c path="Int"/></SAFE_NUM>
		<clsId line="16" static="1"><c path="Int"/></clsId>
		<hxUnserialize public="1" set="method" line="307"><f a="s">
	<c path="haxe.Unserializer"/>
	<e path="Void"/>
</f></hxUnserialize>
		<hxSerialize public="1" set="method" line="281"><f a="s">
	<c path="haxe.Serializer"/>
	<e path="Void"/>
</f></hxSerialize>
		<toString public="1" set="method" line="255"><f a=""><c path="String"/></f></toString>
		<iterator public="1" get="inline" set="null" line="229"><f a=""><t path="Iterator"><c path="cmtc.ds.hash.ObjectHash.Val"/></t></f></iterator>
		<keys public="1" set="method" line="203"><f a=""><t path="Iterator"><c path="cmtc.ds.hash.ObjectHash.Key"/></t></f></keys>
		<delete public="1" set="method" line="171"><f a="k">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<e path="Bool"/>
</f></delete>
		<exists public="1" set="method" line="145"><f a="k">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<e path="Bool"/>
</f></exists>
		<get public="1" set="method" line="118"><f a="k">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<t path="Null"><c path="cmtc.ds.hash.ObjectHash.Val"/></t>
</f></get>
		<getObjectId get="inline" set="null" line="67"><f a="obj">
	<d/>
	<c path="Int"/>
</f></getObjectId>
		<set public="1" set="method" line="37"><f a="k:v">
	<c path="cmtc.ds.hash.ObjectHash.Key"/>
	<c path="cmtc.ds.hash.ObjectHash.Val"/>
	<e path="Void"/>
</f></set>
		<length public="1" set="null"><c path="Int"/></length>
		<ival><c path="IntHash"><c path="Array"><d/></c></c></ival>
		<new public="1" set="method" line="26"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author waneck</haxe_doc>
	</class>
	<class path="composure.core.ComposeItem" params="" file="../../Composure/src/composure/core/ComposeItem.hx">
		<getRealTrait public="1" set="method" line="21" static="1"><f a="trait">
	<d/>
	<c path="composure.traits.ITrait"/>
</f></getRealTrait>
		<removeParentInjector set="method" line="301"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<addParentInjector set="method" line="297"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<onRootRemove set="method" line="288"><f a=""><e path="Void"/></f></onRootRemove>
		<onRootAdd set="method" line="281"><f a=""><e path="Void"/></f></onRootAdd>
		<onParentRemove set="method" line="271"><f a=""><e path="Void"/></f></onParentRemove>
		<onParentAdd set="method" line="261"><f a=""><e path="Void"/></f></onParentAdd>
		<removeTraitInjector set="method" line="246"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<addTraitInjector set="method" line="231"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<_removeTrait set="method" line="202"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_removeTrait>
		<removeAllTraits public="1" set="method" line="197">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all traits from this item.</haxe_doc>
		</removeAllTraits>
		<removeTraits public="1" set="method" line="189">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a list of traits from this item.
	 * @see					addTrait
	 * @param	trait		The list of traits to remove from this item.</haxe_doc>
		</removeTraits>
		<removeTrait public="1" set="method" line="181">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a trait from this item.
	 * @see					addTrait
	 * @param	trait		The trait to remove from this item.</haxe_doc>
		</removeTrait>
		<_addTrait set="method" line="148"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_addTrait>
		<addTraits public="1" set="method" line="143">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds multiple traits to this item.
	 * @see					addTrait
	 * @param	traits		The traits to add to this item.</haxe_doc>
		</addTraits>
		<addTrait public="1" set="method" line="135">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a trait to this item. Any type of object can be added, but if it implements ITrait
	 * it will have access to more information about the item and it's other traits. If, for structural reasons,
	 * it is inconvenient to implement ITrait, the object can expose a method called 'getProxiedTrait()' which should
	 * return an ITrait object to operate as it's proxy regarding other traits etc.
	 * @param	trait		The trait to add to this item.</haxe_doc>
		</addTrait>
		<callForTraits public="1" params="TraitType" set="method" line="125">
			<f a="func:?TraitType">
				<f a=":">
					<c path="composure.core.ComposeItem"/>
					<c path="callForTraits.TraitType"/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="callForTraits.TraitType"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Calls a function once for each trait that matches a certain type. The ComposeItem and
	 * trait are passed through as arguments. A function should have a signature like:<br/>
	 * <code>
	 * function myTraitFunction(item:ComposeItem, trait:ITrait):Void;
	 * </code>
	 * @param	func		The function to call.
	 * @param	TraitType	The type which the returned traits must implement.
	 * 						If no type is passed in, the function is called for all traits.]]></haxe_doc>
		</callForTraits>
		<getTraits public="1" params="TraitType" set="method" line="109">
			<f a="?TraitType">
				<c path="Class"><c path="getTraits.TraitType"/></c>
				<t path="Iterable"><c path="getTraits.TraitType"/></t>
			</f>
			<haxe_doc>* Gets a list of traits of a certain type.
	 * @param	TraitType		The type which the returned traits must implement.
	 * 							If no type is passed in, all traits are returned.
	 * @return		An array of traits, returns null if no matching traits are found.
	 * 				CAUTION: Do not modify the returned Array, for performance reasons,
	 * 				it is passed out by reference and reused internally.</haxe_doc>
		</getTraits>
		<getTrait public="1" params="TraitType" set="method" line="98">
			<f a="TraitType">
				<c path="Class"><c path="getTrait.TraitType"/></c>
				<c path="getTrait.TraitType"/>
			</f>
			<haxe_doc>* Gets the first trait of a certain type.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getTrait>
		<setRoot set="method" line="84"><f a="root">
	<c path="composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<_traitToPair><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<t path="composure.traits.TraitPair"><d/></t>
</c></_traitToPair>
		<_traitToCast><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.traits.ITrait"/>
</c></_traitToCast>
		<_uniInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_uniInjectors>
		<_ascInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ascInjectors>
		<_parentMarrier><c path="composure.injectors.InjectorMarrier"/></_parentMarrier>
		<_siblingMarrier><c path="composure.injectors.InjectorMarrier"/></_siblingMarrier>
		<_traitCollection><c path="composure.traits.TraitCollection"/></_traitCollection>
		<_root><c path="composure.core.ComposeRoot"/></_root>
		<_parentItem><c path="composure.core.ComposeGroup"/></_parentItem>
		<getRoot set="method" line="59"><f a=""><c path="composure.core.ComposeRoot"/></f></getRoot>
		<root public="1" get="getRoot" set="null">
			<c path="composure.core.ComposeRoot"/>
			<haxe_doc>* The ComposeRoot which is the top-level parent, if this is the root 'root' will be a self-reference.
	 * This value is set automatically and shouldn't be manually changed.</haxe_doc>
		</root>
		<setParentItem set="method" line="42"><f a="value">
	<c path="composure.core.ComposeGroup"/>
	<c path="composure.core.ComposeGroup"/>
</f></setParentItem>
		<getParentItem set="method" line="39"><f a=""><c path="composure.core.ComposeGroup"/></f></getParentItem>
		<parentItem public="1" get="getParentItem" set="setParentItem">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The ComposeGroup to which this item is added, if this is the root 'parentItem' will be a self-reference.
	 * This value is set automatically and shouldn't be manually changed.</haxe_doc>
		</parentItem>
		<new public="1" set="method" line="76">
			<f a="?initTraits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	initTraits		A list of traits to add to this ComposeItem initially.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* ComposeItem forms is the base class of all conceptual items in Composure.
 * It allows traits to be added and removed.<br/>
 * ComposeItem should only be used for performance critical items, it is recommended
 * that most items be represented by the subclass ComposeGroup, which adds the ability
 * to add/remove child items.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.core.ComposeGroup" params="" file="../../Composure/src/composure/core/ComposeGroup.hx">
		<extends path="composure.core.ComposeItem"/>
		<removeDescParentInjector set="method" line="344"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeDescParentInjector>
		<addDescParentInjector set="method" line="337"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addDescParentInjector>
		<checkForNewlyUnignoredInjectors set="method" line="319"><f a=""><e path="Void"/></f></checkForNewlyUnignoredInjectors>
		<checkForNewlyIgnoredInjectors set="method" line="300"><f a=""><e path="Void"/></f></checkForNewlyIgnoredInjectors>
		<removeParentInjector set="method" line="290" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<addParentInjector set="method" line="280" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<_removeAscendingInjector set="method" line="275"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_removeAscendingInjector>
		<removeAscendingInjector public="1" set="method" line="267">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</removeAscendingInjector>
		<_addAscendingInjector set="method" line="258"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_addAscendingInjector>
		<addAscendingInjector public="1" set="method" line="249">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</addAscendingInjector>
		<onParentRemove set="method" line="234" override="1"><f a=""><e path="Void"/></f></onParentRemove>
		<onParentAdd set="method" line="223" override="1"><f a=""><e path="Void"/></f></onParentAdd>
		<callForDescTraits public="1" params="TraitType" set="method" line="220">
			<f a="func:?TraitType">
				<f a=":">
					<c path="composure.core.ComposeItem"/>
					<d/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="callForDescTraits.TraitType"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Calls a function once for each descendant trait that matches a certain type. This ComposeGroup and
	 * the matched trait are passed through as arguments. A function should have a signature like:<br/>
	 * <code>
	 * function myTraitFunction(item:ComposeItem, trait:ITrait):Void;
	 * </code>
	 * @see					callForTraits
	 * @param	func		The function to call.
	 * @param	TraitType	The type which the returned traits must implement.
	 * 						If no type is passed in, the function is called for all traits.]]></haxe_doc>
		</callForDescTraits>
		<getDescTraits public="1" params="TraitType" set="method" line="206">
			<f a="?TraitType">
				<c path="Class"><c path="getDescTraits.TraitType"/></c>
				<t path="Iterable"><c path="getDescTraits.TraitType"/></t>
			</f>
			<haxe_doc>* Gets a list of traits of a certain type from any of this groups descendant items.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getDescTraits>
		<getDescTrait public="1" params="TraitType" set="method" line="198">
			<f a="TraitType">
				<c path="Class"><c path="getDescTrait.TraitType"/></c>
				<c path="getDescTrait.TraitType"/>
			</f>
			<haxe_doc>* Gets the first trait of a certain type from any of this groups descendant items.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getDescTrait>
		<removeTraitInjector set="method" line="184" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<addTraitInjector set="method" line="175" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<removeAllTraits public="1" set="method" line="171" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeAllTraits>
		<removeTraits public="1" set="method" line="164" override="1">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeTraits>
		<removeTrait public="1" set="method" line="157" override="1">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeTrait>
		<addTraits public="1" set="method" line="150" override="1">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</addTraits>
		<addTrait public="1" set="method" line="143" override="1">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</addTrait>
		<removeChildTrait public="1" set="method" line="136">
			<f a="traitPair">
				<t path="composure.traits.TraitPair"><d/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</removeChildTrait>
		<addChildTrait public="1" set="method" line="128">
			<f a="traitPair">
				<t path="composure.traits.TraitPair"><d/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</addChildTrait>
		<removeAllItem public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all children from this ComposeGroup.</haxe_doc>
		</removeAllItem>
		<removeChild public="1" set="method" line="90">
			<f a="item">
				<c path="composure.core.ComposeItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a child ComposeItem from this ComposeGroup.
	 * @param	item		A ComposeItem object to remove as a child from this group.</haxe_doc>
		</removeChild>
		<addChild public="1" set="method" line="60">
			<f a="item">
				<c path="composure.core.ComposeItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a child ComposeItem to this ComposeGroup.
	 * @param	item		A ComposeItem object to add as a child to this group.</haxe_doc>
		</addChild>
		<setRoot set="method" line="50" override="1"><f a="game">
	<c path="composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<_ignoredParentDescInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ignoredParentDescInjectors>
		<_parentDescInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_parentDescInjectors>
		<_descInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_descInjectors>
		<_childAscendingMarrier><c path="composure.injectors.InjectorMarrier"/></_childAscendingMarrier>
		<_ignoredChildAscInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ignoredChildAscInjectors>
		<_childAscInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_childAscInjectors>
		<_children><c path="org.tbyrne.collections.UniqueList"><c path="composure.core.ComposeItem"/></c></_children>
		<_descendantTraits><c path="composure.traits.TraitCollection"/></_descendantTraits>
		<get_children set="method" line="24"><f a=""><t path="Iterable"><c path="composure.core.ComposeItem"/></t></f></get_children>
		<children public="1" get="get_children" set="null"><t path="Iterable"><c path="composure.core.ComposeItem"/></t></children>
		<new public="1" set="method" line="42">
			<f a="?initTraits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	initTraits		A list of traits to add to this ComposeItem initially.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* ComposeGroup is the core item used in Composure. It represents one conceptual object.
 * It shouldn't be directly overriden, instead it should be instantiated and then
 * populated with traits, each adding one atomic piece of behaviour.<br/>
 * ComposeGroup adds to the functionality of ComposeItem by allowing child items. For
 * performance critical items that will never need to house children, ComposeItem can
 * be used instead.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.core.ComposeRoot" params="" file="../../Composure/src/composure/core/ComposeRoot.hx">
		<extends path="composure.core.ComposeGroup"/>
		<removeUniversalInjector public="1" set="method" line="42">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</removeUniversalInjector>
		<addUniversalInjector public="1" set="method" line="35">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</addUniversalInjector>
		<getAllTraits public="1" set="method" line="28"><f a=""><c path="composure.traits.TraitCollection"/></f></getAllTraits>
		<_universalMarrier><c path="composure.injectors.InjectorMarrier"/></_universalMarrier>
		<new public="1" set="method" line="23"><f a="?initTraits">
	<c path="Array"><c path="composure.traits.ITrait"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* ComposeRoot is the root item for the Composure library.
 * When using Composure, one top-level ComposeRoot object should be
 * created. All other objects should then be added to this object or one
 * of it's descendants.<br/>
 * It is recommended that you do not add traits directly to the root object.
 * Adding them to some 'stage' or 'controller' item instead will allow your app
 * to coexist and interrelate with other Composure apps in future.<br/>
 * The only functional change ComposeRoot adds to ComposeGroup is that it's
 * 'root' property is a reference to itself.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.injectors.IInjector" params="" file="../../Composure/src/composure/injectors/IInjector.hx" interface="1">
		<isInterestedIn public="1" set="method"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<injectorRemoved public="1" set="method"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorRemoved>
		<injectorAdded public="1" set="method"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorAdded>
		<ownerTrait public="1"><d/></ownerTrait>
		<acceptOwnerTrait public="1" set="null"><e path="Bool"/></acceptOwnerTrait>
		<universal public="1" set="null"><e path="Bool"/></universal>
		<descendants public="1" set="null"><e path="Bool"/></descendants>
		<ascendants public="1" set="null"><e path="Bool"/></ascendants>
		<siblings public="1" set="null"><e path="Bool"/></siblings>
	</class>
	<class path="composure.injectors.AbstractInjector" params="" file="../../Composure/src/composure/injectors/AbstractInjector.hx">
		<implements path="composure.injectors.IInjector"/>
		<isInterestedIn public="1" set="method" line="123"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method" line="119"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method" line="115"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<itemMatchesAny set="method" line="107"><f a="item:traitTypes">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAny>
		<itemMatchesAll set="method" line="99"><f a="item:traitTypes">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAll>
		<injectorRemoved public="1" set="method" line="79"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorRemoved>
		<injectorAdded public="1" set="method" line="59"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorAdded>
		<_addedTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_addedTraits>
		<passThroughItem public="1"><e path="Bool"/></passThroughItem>
		<passThroughInjector public="1"><e path="Bool"/></passThroughInjector>
		<ownerTrait public="1"><d/></ownerTrait>
		<_enumValMode><e path="Bool"/></_enumValMode>
		<set_interestedTraitType set="method" line="22"><f a="value">
	<d/>
	<d/>
</f></set_interestedTraitType>
		<interestedTraitType public="1" set="set_interestedTraitType"><d/></interestedTraitType>
		<acceptOwnerTrait public="1"><e path="Bool"/></acceptOwnerTrait>
		<universal public="1"><e path="Bool"/></universal>
		<ascendants public="1"><e path="Bool"/></ascendants>
		<descendants public="1"><e path="Bool"/></descendants>
		<siblings public="1"><e path="Bool"/></siblings>
		<removeHandler public="1"><d/></removeHandler>
		<addHandler public="1"><d/></addHandler>
		<new public="1" set="method" line="43"><f a="interestedTraitType:addHandler:removeHandler:?siblings:?descendants:?ascendants:?universal">
	<d/>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.Injector" params="" file="../../Composure/src/composure/injectors/Injector.hx">
		<extends path="composure.injectors.AbstractInjector"/>
		<isInterestedIn public="1" set="method" line="35" override="1"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method" line="28" override="1"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method" line="21" override="1"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<maxMatches public="1"><c path="Int"/></maxMatches>
		<stopAscendingAt public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.Injector"/>
	<e path="Bool"/>
</f></stopAscendingAt>
		<stopDescendingAt public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.Injector"/>
	<e path="Bool"/>
</f></stopDescendingAt>
		<matchTrait public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.Injector"/>
	<e path="Bool"/>
</f></matchTrait>
		<new public="1" set="method" line="14"><f a="traitType:addHandler:removeHandler:?siblings:?descendants:?ascendants:?universal">
	<d/>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.InjectorMarrier" params="" file="../../Composure/src/composure/injectors/InjectorMarrier.hx">
		<compareTrait set="method" line="122"><f a="traitPair:traitInjector">
	<t path="composure.traits.TraitPair"><d/></t>
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></compareTrait>
		<onTraitRemoved set="method" line="107"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></onTraitRemoved>
		<onTraitAdded set="method" line="101"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></onTraitAdded>
		<removeInjector public="1" set="method" line="73"><f a="traitInjector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeInjector>
		<addInjector public="1" set="method" line="55"><f a="traitInjector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addInjector>
		<_traitLookup><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c>
</c></_traitLookup>
		<_injectorLookup><c path="cmtc.ds.hash.ObjectHash">
	<c path="composure.injectors.IInjector"/>
	<c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><d/></t></c>
</c></_injectorLookup>
		<_traitInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_traitInjectors>
		<_traits><c path="composure.traits.TraitCollection"/></_traits>
		<getTraitInjectors set="method" line="34"><f a=""><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></f></getTraitInjectors>
		<traitInjectors public="1" get="getTraitInjectors" set="null"><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></traitInjectors>
		<set_traits set="method" line="19"><f a="value">
	<c path="composure.traits.TraitCollection"/>
	<c path="composure.traits.TraitCollection"/>
</f></set_traits>
		<get_traits set="method" line="16"><f a=""><c path="composure.traits.TraitCollection"/></f></get_traits>
		<traits public="1" get="get_traits" set="set_traits"><c path="composure.traits.TraitCollection"/></traits>
		<new public="1" set="method" line="47"><f a="traits">
	<c path="composure.traits.TraitCollection"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.PropInjector" params="" file="../../Composure/src/composure/injectors/PropInjector.hx">
		<extends path="composure.injectors.Injector"/>
		<removeProp set="method" line="38"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeProp>
		<addProp set="method" line="24"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addProp>
		<setTrait><d/></setTrait>
		<isSet><e path="Bool"/></isSet>
		<writeOnly><e path="Bool"/></writeOnly>
		<prop><c path="String"/></prop>
		<subject><d/></subject>
		<new public="1" set="method" line="16"><f a="interestedTraitType:subject:prop:?siblings:?descendants:?ascendants:?universal:?writeOnly">
	<d/>
	<d/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="composure.traitCheckers.TraitTypeChecker" params="" file="../../Composure/src/composure/traitCheckers/TraitTypeChecker.hx">
		<createMulti public="1" set="method" line="14" static="1"><f a="types:?useOrCheck:?invertResponse:?unlessIsTraits:?dontMatchFrom">
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
	<f a="::">
		<c path="composure.core.ComposeItem"/>
		<d/>
		<c path="composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></createMulti>
		<create public="1" set="method" line="37" static="1"><f a="type:?invertResponse:?unlessIsTrait:?dontMatchFrom">
	<c path="Class"><d/></c>
	<e path="Bool"/>
	<d/>
	<e path="Bool"/>
	<f a="::">
		<c path="composure.core.ComposeItem"/>
		<d/>
		<c path="composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></create>
		<contains set="method" line="46" static="1"><f a="traits:trait">
	<c path="Array"><d/></c>
	<d/>
	<e path="Bool"/>
</f></contains>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="composure.traits.ITrait" params="" file="../../Composure/src/composure/traits/ITrait.hx" interface="1">
		<getInjectors public="1" set="method">
			<f a=""><t path="Iterable"><c path="composure.injectors.IInjector"/></t></f>
			<haxe_doc>* This provides a way for this trait to gain access to other traits in the
	 * application.
	 * @return A list of IInjectors, each one describing which traits it is concerned with.</haxe_doc>
		</getInjectors>
		<group public="1" set="null">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The group to which this item is added. This is a method of convenience,
	 * and should return the 'item' property cast as a ComposeGroup.</haxe_doc>
		</group>
		<item public="1" set="set_item">
			<c path="composure.core.ComposeItem"/>
			<haxe_doc>* The item which this trait is added to. Do not set this manually,
	 * the ComposeItem class sets this property automatically when the 
	 * trait is added to it.</haxe_doc>
		</item>
		<haxe_doc>* ITrait can be implemented by traits to give them access to the item
 * to which they are added. It also allows traits to return a list of 
 * injectors, which describe other traits (sibling, ascendant or descendant)
 * which this trait should gain access to.
 * 
 * @author		Tom Byrne</haxe_doc>
	</class>
	<class path="composure.traits.AbstractTrait" params="" file="../../Composure/src/composure/traits/AbstractTrait.hx">
		<implements path="composure.traits.ITrait"/>
		<removeInjector public="1" set="method" line="195">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes an injector from this trait.
	 * @see addInjector
	 * @param injector The injector to remove from this trait.</haxe_doc>
		</removeInjector>
		<addInjector public="1" set="method" line="181">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds an injector to this trait, each injector is a description of a certain other trait
	 * that this trait would like access to.
	 * @param injector The injector to add to this trait.</haxe_doc>
		</addInjector>
		<removeChildItems set="method" line="170"><f a="children">
	<c path="Array"><c path="composure.core.ComposeItem"/></c>
	<e path="Void"/>
</f></removeChildItems>
		<removeChildItem set="method" line="160"><f a="child">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></removeChildItem>
		<addChildItem set="method" line="149"><f a="child">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></addChildItem>
		<removeSiblingTraits set="method" line="143"><f a="traits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></removeSiblingTraits>
		<removeSiblingTrait set="method" line="133"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeSiblingTrait>
		<addSiblingTrait set="method" line="122"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addSiblingTrait>
		<getInjectors public="1" set="method" line="117">
			<f a=""><t path="Iterable"><c path="composure.injectors.IInjector"/></t></f>
			<haxe_doc>* This provides a way for this trait to gain access to other traits in the
	 * application.
	 * @return A list of IInjectors, each one describing which traits it is concerned with.</haxe_doc>
		</getInjectors>
		<onItemAdd set="method" line="108"><f a=""><e path="Void"/></f></onItemAdd>
		<onItemRemove set="method" line="105"><f a=""><e path="Void"/></f></onItemRemove>
		<_ownerTrait><d/></_ownerTrait>
		<_groupOnly>
			<e path="Bool"/>
			<haxe_doc>* Set to true to force Trait to only be added for groups.</haxe_doc>
		</_groupOnly>
		<_childItems><c path="org.tbyrne.collections.UniqueList"><c path="composure.core.ComposeItem"/></c></_childItems>
		<_siblingTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_siblingTraits>
		<_injectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_injectors>
		<set_item set="method" line="40"><f a="value">
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></set_item>
		<item public="1" set="set_item">
			<c path="composure.core.ComposeItem"/>
			<haxe_doc>* The item which this trait is added to. Do not set this manually,
	 * the ComposeItem class sets this property automatically when the 
	 * trait is added to it.</haxe_doc>
		</item>
		<group public="1" set="null">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The group to which this item is added. This is a method of convenience,
	 * and returns the 'item' property cast as a ComposeGroup.</haxe_doc>
		</group>
		<new public="1" set="method" line="97">
			<f a="?ownerTrait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param ownerTrait When using this Class as a Proxied Trait, pass through the actual trait
	 * object as the first parameter.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The AbstractTrait class can be extended by any trait to gain access
 * to the trait to which it is added. It also allows traits to access
 * other traits in the application either via the injection metadata
 * or via manually adding injectors via the addInjector method.<br/>
 * <br/>
 * If, for whatever reason, it is not possible or convenient to extend 
 * AbstractTrait, it is also possible to instantiate it within your trait
 * (passing <code>this</code> in as the constructor argument) and returning this
 * instance via a <code>getProxiedTrait</code> method. To use injection metadata in
 * this situation you must also add the <code>@build(composure.macro.InjectorMacro.inject())</code>
 * metadata to your class.
 * 
 * @author		Tom Byrne]]></haxe_doc>
		<meta>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<typedef path="composure.traits.TraitPair" params="TraitType" file="../../Composure/src/composure/traits/ITrait.hx" module="composure.traits.ITrait"><a>
	<trait><c path="composure.traits.TraitPair.TraitType"/></trait>
	<item><c path="composure.core.ComposeItem"/></item>
</a></typedef>
	<class path="composure.traits.TraitCollection" params="" file="../../Composure/src/composure/traits/TraitCollection.hx">
		<get_traitRemoved set="method" line="28"><f a=""><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></f></get_traitRemoved>
		<_traitRemoved><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></_traitRemoved>
		<get_traitAdded set="method" line="25"><f a=""><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></f></get_traitAdded>
		<_traitAdded><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></_traitAdded>
		<removeTrait public="1" set="method" line="173"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></removeTrait>
		<addTrait public="1" set="method" line="165"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></addTrait>
		<callForTraits public="1" params="TraitType" set="method" line="103"><f a="func:matchType:thisObj:?params:?collectReturns">
	<d/>
	<c path="Class"><c path="callForTraits.TraitType"/></c>
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></callForTraits>
		<validateCache public="1" params="TraitType" set="method" line="70"><f a="matchType">
	<c path="Class"><c path="validateCache.TraitType"/></c>
	<c path="composure.traits._TraitCollection.TraitTypeCache"><c path="validateCache.TraitType"/></c>
</f></validateCache>
		<getTraits public="1" params="TraitType" set="method" line="61"><f a="?TraitType">
	<c path="Class"><c path="getTraits.TraitType"/></c>
	<t path="Iterable"><c path="getTraits.TraitType"/></t>
</f></getTraits>
		<getTrait public="1" params="TraitType" set="method" line="47"><f a="TraitType">
	<c path="Class"><c path="getTrait.TraitType"/></c>
	<c path="getTrait.TraitType"/>
</f></getTrait>
		<traitPairs public="1" set="null"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><d/></t></c></traitPairs>
		<_traitTypeCache><c path="Hash"><c path="composure.traits._TraitCollection.TraitTypeCache"><d/></c></c></_traitTypeCache>
		<_testSignal><c path="msignal.Signal1"><d/></c></_testSignal>
		<get_testSignal set="method" line="31"><f a=""><c path="msignal.Signal1"><d/></c></f></get_testSignal>
		<testSignal public="1" get="get_testSignal" set="null"><c path="msignal.Signal1"><d/></c></testSignal>
		<traitRemoved public="1" get="get_traitRemoved" set="null">
			<c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c>
			<meta><m n="lazyInst"/></meta>
		</traitRemoved>
		<traitAdded public="1" get="get_traitAdded" set="null">
			<c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c>
			<meta><m n="lazyInst"/></meta>
		</traitAdded>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* The TraitCollection holds a collection of traits and has the
 * ability to compare them to a collection of injectors. This is 
 * used internally in Composure.
 * 
 * @author Tom Byrne</haxe_doc>
		<meta><m n=":build"><e>'???'</e></m></meta>
	</class>
	<class path="composure.traits._TraitCollection.TraitTypeCache" params="TraitType" file="../../Composure/src/composure/traits/TraitCollection.hx" private="1" module="composure.traits.TraitCollection">
		<invalid public="1"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></c></invalid>
		<matched public="1"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></c></matched>
		<getTraitsList public="1"><c path="org.tbyrne.collections.UniqueList"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></c></getTraitsList>
		<getTraits public="1"><t path="Iterable"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></getTraits>
		<getTrait public="1"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></getTrait>
		<methodCachesSafe public="1"><e path="Bool"/></methodCachesSafe>
		<new public="1" set="method" line="195"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="composure.utilTraits.Furnisher" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<unregisterItem set="method" line="309"><f a="trait:currItem:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></unregisterItem>
		<registerItem set="method" line="242"><f a="trait:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></registerItem>
		<getItem set="method" line="239"><f a="trait">
	<d/>
	<c path="composure.core.ComposeItem"/>
</f></getItem>
		<testRules set="method" line="223"><f a="foundTrait:item:rules">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
	<e path="Bool"/>
</f></testRules>
		<getTrait set="method" line="206"><f a="foundTrait:item:addTrait">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="composure.utilTraits.AddTrait"/>
	<d/>
</f></getTrait>
		<addTrait public="1" set="method" line="190"><f a="addTrait">
	<e path="composure.utilTraits.AddTrait"/>
	<e path="Void"/>
</f></addTrait>
		<onConcernedTraitRemoved set="method" line="169"><f a="trait:currItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onConcernedTraitRemoved>
		<onConcernedTraitAdded set="method" line="144"><f a="trait:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onConcernedTraitAdded>
		<_ignoreTraitChanges><e path="Bool"/></_ignoreTraitChanges>
		<_originalParents><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeGroup"/>
</c></_originalParents>
		<_originalItems><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeItem"/>
</c></_originalItems>
		<_traitToItems><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeItem"/>
</c></_traitToItems>
		<_addedTraits><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="Array"><d/></c>
</c></_addedTraits>
		<_foundTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_foundTraits>
		<_addTraits><c path="org.tbyrne.collections.UniqueList"><e path="composure.utilTraits.AddTrait"/></c></_addTraits>
		<_injector><c path="composure.injectors.Injector"/></_injector>
		<_addType><e path="composure.utilTraits.AddType"/></_addType>
		<set_searchAscendants set="method" line="105"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchAscendants>
		<searchAscendants public="1" set="set_searchAscendants"><e path="Bool"/></searchAscendants>
		<set_searchDescendants set="method" line="95"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchDescendants>
		<searchDescendants public="1" set="set_searchDescendants"><e path="Bool"/></searchDescendants>
		<set_searchSiblings set="method" line="85"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchSiblings>
		<searchSiblings public="1" set="set_searchSiblings"><e path="Bool"/></searchSiblings>
		<set_concernedTraitType set="method" line="70"><f a="value">
	<d/>
	<d/>
</f></set_concernedTraitType>
		<concernedTraitType public="1" set="set_concernedTraitType"><d/></concernedTraitType>
		<new public="1" set="method" line="126"><f a="?concernedTraitType:?addTraits:?addType:?searchSiblings:?searchDescendants:?searchAscendants">
	<d/>
	<c path="Array"><e path="composure.utilTraits.AddTrait"/></c>
	<e path="composure.utilTraits.AddType"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Furnisher class is used to add traits to an item in response
 * to a certain type of trait being added to the item.<br/>
 * <br/>
 * This is very useful when creating interchangable libraries. For example,
 * when wanting to add a platform specific display trait to a items in the
 * presence of another trait:
 * <pre><code>
 * var furnisher:Furnisher = new Furnisher(RectangleInfo, [TType(HtmlRectangleDisplay)]);
 * stage.addTrait(furnisher);
 * </code></pre>
 * In this example, any item which has a RectangleInfo trait added to it (representing
 * a rectangle's position and size) will also get a HtmlRectangleDisplay trait added to
 * it. The HtmlRectangleDisplay object can then access the RectangleInfo's size and 
 * position properties using injection metadata. In this way, the display method for
 * all rectangles could be quickly and easily be swapped out for another display trait.
 * 
 * @author Tom Byrne]]></haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="composure.utilTraits.AddTrait" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<TType a="t:?rules">
			<c path="Class"><d/></c>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TType>
		<TInst a="t:?rules">
			<d/>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TInst>
		<TFact a="f:?rules">
			<f a="">
				<d/>
				<d/>
			</f>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TFact>
	</enum>
	<enum path="composure.utilTraits.AddRule" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<UnlessHas a="t"><c path="Class"><d/></c></UnlessHas>
		<IfHas a="t"><c path="Class"><d/></c></IfHas>
	</enum>
	<enum path="composure.utilTraits.AddType" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<traitSibling a="?adoptMatchedTrait"><e path="Bool"/></traitSibling>
		<traitItem/>
		<traitChild a="?adoptMatchedTrait"><e path="Bool"/></traitChild>
		<selfSibling a="?adoptMatchedTrait"><e path="Bool"/></selfSibling>
		<selfItem a="?adoptMatchedTrait"><e path="Bool"/></selfItem>
		<selfChild a="?adoptMatchedTrait"><e path="Bool"/></selfChild>
		<itemSibling a="item:?adoptMatchedTrait">
			<c path="composure.core.ComposeItem"/>
			<e path="Bool"/>
		</itemSibling>
		<itemChild a="group:?adoptMatchedTrait">
			<c path="composure.core.ComposeGroup"/>
			<e path="Bool"/>
		</itemChild>
		<item a="item:?adoptMatchedTrait">
			<c path="composure.core.ComposeItem"/>
			<e path="Bool"/>
		</item>
		<adoptItem a="newParent:?adoptMatchedTrait">
			<c path="composure.core.ComposeGroup"/>
			<e path="Bool"/>
		</adoptItem>
	</enum>
	<class path="cpp.FastIterator" params="T" file="C:\Motion-Twin\haxe\std/cpp/FastIterator.hx" extern="1">
		<next public="1" set="method"><f a=""><c path="cpp.FastIterator.T"/></f></next>
		<hasNext public="1" set="method"><f a=""><e path="Bool"/></f></hasNext>
	</class>
	<class path="cpp.FastIterator_feffects_Tween" params="" file="C:\Motion-Twin\haxe\std/cpp/FastIterator.hx">
		<next public="1" set="method"><f a=""><c path="feffects.Tween"/></f></next>
		<hasNext public="1" set="method"><f a=""><e path="Bool"/></f></hasNext>
	</class>
	<class path="cpp.FastIterator_guise_traits_core_IActive" params="" file="C:\Motion-Twin\haxe\std/cpp/FastIterator.hx">
		<next public="1" set="method"><f a=""><c path="guise.traits.core.IActive"/></f></next>
		<hasNext public="1" set="method"><f a=""><e path="Bool"/></f></hasNext>
	</class>
	<typedef path="cpp.FileSystem" params="" file="C:\Motion-Twin\haxe\std/cpp/FileSystem.hx"><c path="sys.FileSystem"/></typedef>
	<typedef path="cpp.Sys" params="" file="C:\Motion-Twin\haxe\std/cpp/Sys.hx"><c path="Sys"/></typedef>
	<typedef path="cpp.io.File" params="" file="C:\Motion-Twin\haxe\std/cpp/io/File.hx"><c path="sys.io.File"/></typedef>
	<class path="cpp.rtti.FieldNumericIntegerLookup" params="" file="C:\Motion-Twin\haxe\std/cpp/rtti/FieldNumericIntegerLookup.hx" interface="1"><haxe_doc>If you implement this interface, then the backend will generate code that
	allows fast numeric access to fields by integer id.  This should speed up the CFFI.</haxe_doc></class>
	<class path="cpp.zip.Compress" params="" file="C:\Motion-Twin\haxe\std/cpp/zip/Compress.hx">
		<run public="1" set="method" line="47" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_deflate_init line="58" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></_deflate_init>
		<_deflate_bound line="59" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
</f></_deflate_bound>
		<_deflate_buffer line="60" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></_deflate_buffer>
		<_deflate_end line="61" static="1"><f a="">
	<d/>
	<unknown/>
</f></_deflate_end>
		<_set_flush_mode line="62" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></_set_flush_mode>
		<close public="1" set="method" line="43"><f a=""><e path="Void"/></f></close>
		<setFlushMode public="1" set="method" line="39"><f a="f">
	<e path="cpp.zip.Flush"/>
	<e path="Void"/>
</f></setFlushMode>
		<execute public="1" set="method" line="35"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></execute>
		<s><d/></s>
		<new public="1" set="method" line="31"><f a="level">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="cpp.zip.Flush" params="" file="C:\Motion-Twin\haxe\std/cpp/zip/Flush.hx">
		<SYNC/>
		<NO/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
	</enum>
	<class path="cpp.zip.Uncompress" params="" file="C:\Motion-Twin\haxe\std/cpp/zip/Uncompress.hx">
		<run public="1" set="method" line="46" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<_inflate_init line="64" static="1"><f a="">
	<t path="Null"><c path="Int"/></t>
	<unknown/>
</f></_inflate_init>
		<_inflate_buffer line="65" static="1"><f a="::::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></_inflate_buffer>
		<_inflate_end line="66" static="1"><f a="">
	<d/>
	<unknown/>
</f></_inflate_end>
		<_set_flush_mode line="67" static="1"><f a=":">
	<d/>
	<unknown/>
	<unknown/>
</f></_set_flush_mode>
		<close public="1" set="method" line="42"><f a=""><e path="Void"/></f></close>
		<setFlushMode public="1" set="method" line="38"><f a="f">
	<e path="cpp.zip.Flush"/>
	<e path="Void"/>
</f></setFlushMode>
		<this_run public="1" set="method" line="34"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<a>
		<write><c path="Int"/></write>
		<read><c path="Int"/></read>
		<done><e path="Bool"/></done>
	</a>
</f></this_run>
		<s><d/></s>
		<new public="1" set="method" line="30"><f a="windowBits">
	<t path="Null"><c path="Int"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="feffects.Easing" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx" module="feffects.Tween"><f a=":::">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></typedef>
	<class path="feffects.TweenObject" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx" module="feffects.Tween">
		<tween public="1" set="method" line="65" static="1"><f a="target:properties:duration:?easing:?autoStart:?onFinish:?onFinishParams">
	<d/>
	<d/>
	<c path="Int"/>
	<t path="feffects.Easing"/>
	<e path="Bool"/>
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.TweenObject"/>
</f></tween>
		<_onFinish set="method" line="130"><f a="tp">
	<c path="feffects.TweenProperty"/>
	<e path="Void"/>
</f></_onFinish>
		<onFinish public="1" set="method" line="124"><f a="f:?params">
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.TweenObject"/>
</f></onFinish>
		<stop public="1" set="method" line="119"><f a="?finish">
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<reverse public="1" set="method" line="114"><f a=""><e path="Void"/></f></reverse>
		<seek public="1" set="method" line="108"><f a="n">
	<c path="Int"/>
	<c path="feffects.TweenObject"/>
</f></seek>
		<resume public="1" set="method" line="103"><f a=""><e path="Void"/></f></resume>
		<pause public="1" set="method" line="98"><f a=""><e path="Void"/></f></pause>
		<start public="1" set="method" line="87"><f a=""><c path="List"><c path="feffects.TweenProperty"/></c></f></start>
		<setEasing public="1" set="method" line="81"><f a="easing">
	<t path="feffects.Easing"/>
	<c path="feffects.TweenObject"/>
</f></setEasing>
		<__onFinishParams><c path="Array"><d/></c></__onFinishParams>
		<__onFinish><d/></__onFinish>
		<get_isPlaying set="method" line="55"><f a=""><e path="Bool"/></f></get_isPlaying>
		<isPlaing public="1" get="get_isPlaying" set="null"><e path="Bool"/></isPlaing>
		<easing public="1" set="null"><t path="feffects.Easing"/></easing>
		<duration public="1" set="null"><c path="Int"/></duration>
		<properties public="1" set="null"><d/></properties>
		<target public="1" set="null"><d/></target>
		<tweens public="1" set="null"><c path="List"><c path="feffects.TweenProperty"/></c></tweens>
		<new public="1" set="method" line="69"><f a="target:properties:duration:?easing:?autoStart:?onFinish:?onFinishParams">
	<d/>
	<d/>
	<c path="Int"/>
	<t path="feffects.Easing"/>
	<e path="Bool"/>
	<d/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Class that allows tweening properties of an object.<br/>
* Version 1.3.3
* Compatible haxe 2.11 - flash/js/NME
* Usage :<br/>
* import feffects.easing.Elastic;<br/>
* 
* using feffects.Tween.TweenObject;
* ...<br/>
* var mySprite = new Sprite();
* mySprite.graphics.beginFill( 0 );
* mySprite.graphics.drawCircle( 0, 0, 20 );
* mySprite.graphics.endFill();
* 
* Lib.current.addChild( mySprite );
* 
* function foo() {
* 	trace( "end" );
* }
* 
* mySprite.tween( { x : 100, y : 200 }, 1000 ).onFinish( foo ).start();
* 
* OR
* 
* mySprite.tween( {x : 100, y : 200 }, 1000, foo, true );
* 
* @author : M.Romecki
*]]></haxe_doc>
	</class>
	<class path="haxe.FastList_feffects_Tween" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="129">
			<f a=""><t path="Iterator"><c path="feffects.Tween"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="feffects.Tween"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="feffects.Tween"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="feffects.Tween"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="feffects.Tween"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell_feffects_Tween"/></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
	</class>
	<class path="feffects.Tween" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx">
		<_aTweens line="203" static="1"><c path="haxe.FastList_feffects_Tween"/></_aTweens>
		<_aPaused line="204" static="1"><c path="haxe.FastList_feffects_Tween"/></_aPaused>
		<DEFAULT_EASING public="1" line="211" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></DEFAULT_EASING>
		<_isTweening static="1"><e path="Bool"/></_isTweening>
		<AddTween set="method" line="234" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></AddTween>
		<RemoveActiveTween set="method" line="250" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></RemoveActiveTween>
		<RemovePausedTween set="method" line="255" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></RemovePausedTween>
		<checkActiveTweens set="method" line="260" static="1"><f a=""><e path="Void"/></f></checkActiveTweens>
		<getActiveTweens public="1" set="method" line="276" static="1"><f a=""><c path="haxe.FastList_feffects_Tween"/></f></getActiveTweens>
		<getPausedTweens public="1" set="method" line="280" static="1"><f a=""><c path="haxe.FastList_feffects_Tween"/></f></getPausedTweens>
		<setTweenPaused set="method" line="284" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></setTweenPaused>
		<setTweenActive set="method" line="294" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></setTweenActive>
		<cb_tick set="method" line="314" static="1"><f a="?_">
	<unknown/>
	<e path="Void"/>
</f></cb_tick>
		<easingEquation get="inline" set="null" line="499" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easingEquation>
		<getStamp get="inline" set="null" line="487"><f a=""><c path="Float"/></f></getStamp>
		<getCurVal get="inline" set="null" line="483"><f a="curTime">
	<c path="Int"/>
	<c path="Float"/>
</f></getCurVal>
		<doInterval set="method" line="459"><f a=""><e path="Void"/></f></doInterval>
		<setEasing public="1" set="method" line="454">
			<f a="f">
				<t path="feffects.Easing"/>
				<c path="feffects.Tween"/>
			</f>
			<haxe_doc>* Set the [easingFunc] equation to use for tweening</haxe_doc>
		</setEasing>
		<onFinish public="1" set="method" line="445"><f a="f:?params">
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.Tween"/>
</f></onFinish>
		<onUpdate public="1" set="method" line="436"><f a="f:?params">
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.Tween"/>
</f></onUpdate>
		<finish set="method" line="424"><f a=""><e path="Void"/></f></finish>
		<stop public="1" set="method" line="410"><f a="?doFinish">
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<reverse public="1" set="method" line="399">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Reverse the tweeen from the current position</haxe_doc>
		</reverse>
		<seek public="1" set="method" line="391">
			<f a="ms">
				<c path="Int"/>
				<c path="feffects.Tween"/>
			</f>
			<haxe_doc>* Go to the specified position [ms] (in ms)</haxe_doc>
		</seek>
		<resume public="1" set="method" line="376"><f a=""><e path="Void"/></f></resume>
		<pause public="1" set="method" line="365"><f a=""><e path="Void"/></f></pause>
		<start public="1" set="method" line="348"><f a="?position">
	<c path="Int"/>
	<e path="Void"/>
</f></start>
		<_onFinishParams><c path="Array"><d/></c></_onFinishParams>
		<_onUpdateParams><c path="Array"><d/></c></_onUpdateParams>
		<_onFinish><d/></_onFinish>
		<_onUpdate><d/></_onUpdate>
		<_easingF><t path="feffects.Easing"/></_easingF>
		<_reverseTime><c path="Float"/></_reverseTime>
		<_offsetTime><c path="Float"/></_offsetTime>
		<_pauseTime><c path="Float"/></_pauseTime>
		<_startTime><c path="Float"/></_startTime>
		<_endVal><c path="Float"/></_endVal>
		<_initVal><c path="Float"/></_initVal>
		<isPaused public="1" set="null"><e path="Bool"/></isPaused>
		<isPlaying public="1" set="null"><e path="Bool"/></isPlaying>
		<isReversed public="1" set="null"><e path="Bool"/></isReversed>
		<position public="1" set="null"><c path="Int"/></position>
		<duration public="1" set="null"><c path="Int"/></duration>
		<new public="1" set="method" line="324">
			<f a="init:end:dur:?easing:?autoStart:?onUpdate:?onUpdateParams:?onFinish:?onFinishParams">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<t path="feffects.Easing"/>
				<e path="Bool"/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a tween from the [init] value, to the [end] value, while [dur] (in ms)<br />
	* There is a default easing equation.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Class that allows tweening numerical values of an object.<br/>
* Version 1.3.3
* Compatible haxe 2.11 - flash/js/NME
* Usage :<br/>
* import feffects.Tween;<br/>
* import feffects.easing.Elastic;<br/>
* ...<br/>
* function foo ( n : Float ){
* 	mySprite.x = n;
* }
* var t = new Tween( 0, 100, 2000 );						// create a new tween<br/>
* t.onUpdate( foo );
* t.start();												// start the tween<br/>
* 
* You can add :
* * 
* t.setEasing( Elastic.easeIn );							// set the easing function used to compute values<br/>
* t.seek( 1000 );											// go to the specified position (in ms)</br>
* t.pause();<br/>
* t.resume();<br/>
* t.reverse();												// reverse the tween from the current position</br>
* t.stop();
* 
* OR combinated sythax :
* 
* new Tween( 0, 100, 2000 ).setEasing( Elastic.easeIn ).seek( 1000 ).onUpdate( foo ).onFinish( foo2 ).start();
* 
* OR fastest one : 
*
* new Tween( 0, 100, 2000, Elastic.easeIn, foo, foo2, true ).seek( 1000 );
* 
* @author : M.Romecki
*]]></haxe_doc>
	</class>
	<class path="feffects.TweenProperty" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx" module="feffects.Tween">
		<extends path="feffects.Tween"/>
		<__onUpdate set="method" line="156"><f a="n">
	<c path="Float"/>
	<e path="Void"/>
</f></__onUpdate>
		<___onUpdateParams><c path="Array"><d/></c></___onUpdateParams>
		<___onUpdate><d/></___onUpdate>
		<property public="1" set="null"><c path="String"/></property>
		<target public="1" set="null"><d/></target>
		<new public="1" set="method" line="146"><f a="target:prop:value:duration:?easing:?autostart:?onUpdate:?onUpdateParams:?onFinish:?onFinishParams">
	<d/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Int"/>
	<t path="feffects.Easing"/>
	<e path="Bool"/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Public" params="" file="C:\Motion-Twin\haxe\std/haxe/Public.hx" interface="1"><haxe_doc>When implementing this interface, all default fields access for the class and
	subclasses becomes [public] instead of [private].</haxe_doc></class>
	<class path="feffects.easing.Quad" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/easing/Quad.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" get="inline" set="null" line="4" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" get="inline" set="null" line="8" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" get="inline" set="null" line="12" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="guise.Guise" params="" file="../src/guise/Guise.hx">
		<_parent><c path="composure.core.ComposeGroup"/></_parent>
		<stage public="1" set="null"><c path="guise.core.GuiseItem"/></stage>
		<window public="1" set="null"><c path="guise.core.GuiseItem"/></window>
		<get_root public="1" set="method" line="15"><f a=""><c path="composure.core.ComposeRoot"/></f></get_root>
		<root public="1" get="get_root" set="null"><c path="composure.core.ComposeRoot"/></root>
		<new public="1" set="method" line="24"><f a="?parent">
	<c path="composure.core.ComposeGroup"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.ControlLayers" params="" file="../src/guise/controls/ControlLayers.hx">
		<BACKING public="1" line="9" static="1"><c path="String"/></BACKING>
		<LABEL_TEXT public="1" line="11" static="1"><c path="String"/></LABEL_TEXT>
		<INPUT_TEXT public="1" line="13" static="1"><c path="String"/></INPUT_TEXT>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.ControlLogic" params="" file="../src/guise/controls/ControlLogic.hx">
		<install public="1" set="method" line="20" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.IClick" params="" file="../src/guise/controls/data/IClick.hx" interface="1">
		<clicked public="1" get="get_clicked" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c></clicked>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.IInputPrompt" params="" file="../src/guise/controls/data/IInputPrompt.hx" interface="1">
		<setPrompt public="1" set="method"><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></setPrompt>
		<prompt public="1" set="null"><c path="String"/></prompt>
		<promptChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.IInputPrompt"/></c></promptChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.InputPrompt" params="" file="../src/guise/controls/data/IInputPrompt.hx" module="guise.controls.data.IInputPrompt">
		<implements path="guise.controls.data.IInputPrompt"/>
		<setPrompt public="1" set="method" line="32"><f a="prompt">
	<c path="String"/>
	<e path="Void"/>
</f></setPrompt>
		<prompt public="1" set="null"><c path="String"/></prompt>
		<promptChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.IInputPrompt"/></c></promptChanged>
		<new public="1" set="method" line="26"><f a="?prompt">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.data.ISelected" params="" file="../src/guise/controls/data/ISelected.hx" interface="1">
		<set public="1" set="method"><f a="selected">
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<selected public="1" set="null"><e path="Bool"/></selected>
		<selectedChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ISelected"/></c></selectedChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.Selected" params="" file="../src/guise/controls/data/ISelected.hx" module="guise.controls.data.ISelected">
		<implements path="guise.controls.data.ISelected"/>
		<set public="1" set="method" line="32"><f a="selected">
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<selected public="1" set="null"><e path="Bool"/></selected>
		<selectedChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ISelected"/></c></selectedChanged>
		<new public="1" set="method" line="26"><f a="?selected">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.data.ITextLabel" params="" file="../src/guise/controls/data/ITextLabel.hx" interface="1">
		<set public="1" set="method"><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<text public="1" set="null"><c path="String"/></text>
		<textChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ITextLabel"/></c></textChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.TextLabel" params="" file="../src/guise/controls/data/ITextLabel.hx" module="guise.controls.data.ITextLabel">
		<implements path="guise.controls.data.ITextLabel"/>
		<set public="1" set="method" line="32"><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<text public="1" set="null"><c path="String"/></text>
		<textChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ITextLabel"/></c></textChanged>
		<new public="1" set="method" line="26"><f a="?text">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.logic.input.ButtonClickTrait" params="" file="../src/guise/controls/logic/input/ButtonClickTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<implements path="guise.controls.data.IClick"/>
		<get_clicked set="method" line="24"><f a=""><c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c></f></get_clicked>
		<_clicked><c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c></_clicked>
		<dispatchBundle set="method" line="105"><f a="bundle">
	<c path="guise.controls.logic.input.ClickTypeBundle"/>
	<e path="Void"/>
</f></dispatchBundle>
		<onDoubleClicked set="method" line="89"><f a="info">
	<c path="guise.platform.types.ClickInfo"/>
	<e path="Void"/>
</f></onDoubleClicked>
		<onClicked set="method" line="70"><f a="info">
	<c path="guise.platform.types.ClickInfo"/>
	<e path="Void"/>
</f></onClicked>
		<findBundle set="method" line="61"><f a="clickType">
	<e path="guise.controls.logic.input.ClickType"/>
	<c path="guise.controls.logic.input.ClickTypeBundle"/>
</f></findBundle>
		<unbindFromClick public="1" set="method" line="55"><f a="handler:clickType">
	<f a="">
		<c path="guise.controls.logic.input.ButtonClickTrait"/>
		<e path="Void"/>
	</f>
	<e path="guise.controls.logic.input.ClickType"/>
	<e path="Void"/>
</f></unbindFromClick>
		<bindToClick public="1" set="method" line="47"><f a="handler:clickType">
	<f a="">
		<c path="guise.controls.logic.input.ButtonClickTrait"/>
		<e path="Void"/>
	</f>
	<e path="guise.controls.logic.input.ClickType"/>
	<e path="Void"/>
</f></bindToClick>
		<onMouseClickRemove set="method" line="41"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickRemove>
		<onMouseClickAdd set="method" line="36"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickAdd>
		<clickTypeBundles><c path="Array"><c path="guise.controls.logic.input.ClickTypeBundle"/></c></clickTypeBundles>
		<_mouseClickable><c path="guise.platform.types.IMouseClickable"/></_mouseClickable>
		<clicked public="1" get="get_clicked" set="null">
			<c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c>
			<meta><m n="lazyInst"/></meta>
		</clicked>
		<set_active public="1" set="method" line="18"><f a="value">
	<c path="guise.traits.core.IActive"/>
	<c path="guise.traits.core.IActive"/>
</f></set_active>
		<active public="1" set="set_active">
			<c path="guise.traits.core.IActive"/>
			<meta><m n="inject"/></meta>
		</active>
		<new public="1" set="method" line="30"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guise.controls.logic.input.ClickType" params="" file="../src/guise/controls/logic/input/ButtonClickTrait.hx" module="guise.controls.logic.input.ButtonClickTrait">
		<RightClick/>
		<LeftClick/>
		<DoubleLeftClick/>
		<Advanced a="left:double:alt:ctrl:shift">
			<e path="Bool"/>
			<e path="Bool"/>
			<t path="Null"><e path="Bool"/></t>
			<t path="Null"><e path="Bool"/></t>
			<t path="Null"><e path="Bool"/></t>
		</Advanced>
	</enum>
	<class path="guise.controls.logic.input.ClickTypeBundle" params="" file="../src/guise/controls/logic/input/ButtonClickTrait.hx" module="guise.controls.logic.input.ButtonClickTrait">
		<signaler public="1"><c path="msignal.Signal1"><c path="guise.controls.logic.input.ButtonClickTrait"/></c></signaler>
		<clickType public="1"><e path="guise.controls.logic.input.ClickType"/></clickType>
		<new public="1" set="method" line="119"><f a="owner:clickType">
	<c path="guise.controls.logic.input.ButtonClickTrait"/>
	<e path="guise.controls.logic.input.ClickType"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.logic.input.ClickToggleSelect" params="" file="../src/guise/controls/logic/input/ClickToggleSelect.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onClicked set="method" line="34"><f a="info">
	<c path="guise.platform.types.ClickInfo"/>
	<e path="Void"/>
</f></onClicked>
		<onMouseClickRemove set="method" line="29"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickRemove>
		<onMouseClickAdd set="method" line="25"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickAdd>
		<_mouseClickable><c path="guise.platform.types.IMouseClickable"/></_mouseClickable>
		<selected public="1">
			<c path="guise.controls.data.ISelected"/>
			<meta><m n="inject"/></meta>
		</selected>
		<new public="1" set="method" line="20"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.input.MouseOverTrait" params="" file="../src/guise/controls/logic/input/MouseOverTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<assessMouseOver set="method" line="64"><f a=""><e path="Void"/></f></assessMouseOver>
		<onRolledOut set="method" line="59"><f a="?info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOut>
		<onRolledOver set="method" line="55"><f a="?info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOver>
		<onMouseIntRemove set="method" line="49"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntRemove>
		<onMouseIntAdd set="method" line="43"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntAdd>
		<_mouseInteractions><c path="guise.platform.types.IMouseInteractions"/></_mouseInteractions>
		<_mouseOver><e path="Bool"/></_mouseOver>
		<get_mouseOverChanged set="method" line="26"><f a=""><c path="msignal.Signal1"><c path="guise.controls.logic.input.MouseOverTrait"/></c></f></get_mouseOverChanged>
		<mouseOverChanged public="1" get="get_mouseOverChanged" set="null"><c path="msignal.Signal1"><c path="guise.controls.logic.input.MouseOverTrait"/></c></mouseOverChanged>
		<_mouseOverChanged><c path="msignal.Signal1"><c path="guise.controls.logic.input.MouseOverTrait"/></c></_mouseOverChanged>
		<mouseOver public="1" set="null"><e path="Bool"/></mouseOver>
		<set_active public="1" set="method" line="18"><f a="value">
	<c path="guise.traits.core.IActive"/>
	<c path="guise.traits.core.IActive"/>
</f></set_active>
		<active public="1" set="set_active">
			<c path="guise.traits.core.IActive"/>
			<meta><m n="inject"/></meta>
		</active>
		<new public="1" set="method" line="37"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.input.TextInputPrompt" params="" file="../src/guise/controls/logic/input/TextInputPrompt.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onFocusedChanged set="method" line="88"><f a="from">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusedChanged>
		<onPromptChanged set="method" line="82"><f a="from">
	<c path="guise.controls.data.IInputPrompt"/>
	<e path="Void"/>
</f></onPromptChanged>
		<onTextChanged set="method" line="73"><f a="from">
	<c path="guise.platform.types.ITextInputAccess"/>
	<e path="Void"/>
</f></onTextChanged>
		<onFocusRemove set="method" line="69"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusRemove>
		<onFocusAdd set="method" line="64"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusAdd>
		<onInputRemove set="method" line="60"><f a="access">
	<c path="guise.platform.types.ITextInputAccess"/>
	<e path="Void"/>
</f></onInputRemove>
		<onInputAdd set="method" line="54"><f a="access">
	<c path="guise.platform.types.ITextInputAccess"/>
	<e path="Void"/>
</f></onInputAdd>
		<_focused><e path="Bool"/></_focused>
		<_ignoreChanges><e path="Bool"/></_ignoreChanges>
		<_showingPrompt><e path="Bool"/></_showingPrompt>
		<_focus><c path="guise.platform.IFocusableAccess"/></_focus>
		<_input><c path="guise.platform.types.ITextInputAccess"/></_input>
		<set_inputPrompt set="method" line="29"><f a="inputPrompt">
	<c path="guise.controls.data.IInputPrompt"/>
	<c path="guise.controls.data.IInputPrompt"/>
</f></set_inputPrompt>
		<inputPrompt public="1" set="set_inputPrompt">
			<c path="guise.controls.data.IInputPrompt"/>
			<meta><m n="inject"/></meta>
		</inputPrompt>
		<set_textLabel set="method" line="19"><f a="value">
	<c path="guise.controls.data.ITextLabel"/>
	<c path="guise.controls.data.ITextLabel"/>
</f></set_textLabel>
		<textLabel public="1" set="set_textLabel">
			<c path="guise.controls.data.ITextLabel"/>
			<meta><m n="inject"/></meta>
		</textLabel>
		<new public="1" set="method" line="47"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.states.ButtonStateMapper" params="" file="../src/guise/controls/logic/states/ButtonStateMapper.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onRolledOut set="method" line="63"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOut>
		<onRolledOver set="method" line="59"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOver>
		<onReleased set="method" line="55"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onReleased>
		<onPressed set="method" line="51"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onPressed>
		<onMouseIntRemove set="method" line="42"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntRemove>
		<onMouseIntAdd set="method" line="35"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntAdd>
		<_mouseInteractions><c path="guise.platform.types.IMouseInteractions"/></_mouseInteractions>
		<overState><c path="guise.traits.states.State"><e path="guise.traits.states.ButtonOverState"/></c></overState>
		<downState><c path="guise.traits.states.State"><e path="guise.traits.states.ButtonDownState"/></c></downState>
		<new public="1" set="method" line="21"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.states.FocusStateMapper" params="" file="../src/guise/controls/logic/states/FocusStateMapper.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onFocusedChanged set="method" line="39"><f a="from">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusedChanged>
		<onFocusRemove set="method" line="35"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusRemove>
		<onFocusAdd set="method" line="30"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusAdd>
		<_focusable><c path="guise.platform.IFocusableAccess"/></_focusable>
		<focusedState><c path="guise.traits.states.State"><e path="guise.traits.states.FocusState"/></c></focusedState>
		<new public="1" set="method" line="20"><f a="layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.states.SelectableStateMapper" params="" file="../src/guise/controls/logic/states/SelectableStateMapper.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onSelectedChanged set="method" line="47"><f a="from">
	<c path="guise.controls.data.ISelected"/>
	<e path="Void"/>
</f></onSelectedChanged>
		<selectedState><c path="guise.traits.states.State"><e path="guise.traits.states.SelectedState"/></c></selectedState>
		<selectableState><c path="guise.traits.states.State"><e path="guise.traits.states.SelectableState"/></c></selectableState>
		<set_selected set="method" line="16"><f a="value">
	<c path="guise.controls.data.ISelected"/>
	<c path="guise.controls.data.ISelected"/>
</f></set_selected>
		<selected public="1" set="set_selected">
			<c path="guise.controls.data.ISelected"/>
			<meta><m n="inject"/></meta>
		</selected>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.AbsPosAwareTrait" params="" file="../src/guise/core/AbsPosAwareTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<posChanged set="method" line="51"><f a=""><e path="Void"/></f></posChanged>
		<onPosChanged set="method" line="48"><f a="position">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></onPosChanged>
		<assessPosition set="method" line="29"><f a=""><e path="Void"/></f></assessPosition>
		<set_posInjected set="method" line="24"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<c path="guise.traits.core.IPosition"/>
</f></set_posInjected>
		<posInjected public="1" set="set_posInjected">
			<c path="guise.traits.core.IPosition"/>
			<meta><m n="inject"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</posInjected>
		<set_posExplicit set="method" line="14"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<c path="guise.traits.core.IPosition"/>
</f></set_posExplicit>
		<posExplicit public="1" set="set_posExplicit"><c path="guise.traits.core.IPosition"/></posExplicit>
		<position public="1" set="null"><c path="guise.traits.core.IPosition"/></position>
		<new public="1" set="method" line="43"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.AbsPosSizeAwareTrait" params="" file="../src/guise/core/AbsPosSizeAwareTrait.hx">
		<extends path="guise.core.AbsPosAwareTrait"/>
		<sizeChangedInvalid set="method" line="46"><f a=""><e path="Void"/></f></sizeChangedInvalid>
		<sizeChangedValid set="method" line="43"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></sizeChangedValid>
		<sizeChanged set="method" line="33"><f a=""><e path="Void"/></f></sizeChanged>
		<_sizeAware><c path="guise.core.AbsSizeAwareTrait"/></_sizeAware>
		<set_sizeExplicit set="method" line="21"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<c path="guise.traits.core.ISize"/>
</f></set_sizeExplicit>
		<get_sizeExplicit set="method" line="18"><f a=""><c path="guise.traits.core.ISize"/></f></get_sizeExplicit>
		<sizeExplicit public="1" get="get_sizeExplicit" set="set_sizeExplicit"><c path="guise.traits.core.ISize"/></sizeExplicit>
		<get_size set="method" line="13"><f a=""><c path="guise.traits.core.ISize"/></f></get_size>
		<size public="1" get="get_size" set="null"><c path="guise.traits.core.ISize"/></size>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.AbsSizeAwareTrait" params="" file="../src/guise/core/AbsSizeAwareTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<sizeChangedInvalid set="dynamic" line="68"><f a=""><e path="Void"/></f></sizeChangedInvalid>
		<sizeChangedValid set="dynamic" line="65"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></sizeChangedValid>
		<sizeChanged set="dynamic" line="55"><f a=""><e path="Void"/></f></sizeChanged>
		<onSizeChanged set="method" line="51"><f a="size">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></onSizeChanged>
		<assessSize set="method" line="29"><f a=""><e path="Void"/></f></assessSize>
		<set_sizeInjected set="method" line="24"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<c path="guise.traits.core.ISize"/>
</f></set_sizeInjected>
		<sizeInjected public="1" set="set_sizeInjected">
			<c path="guise.traits.core.ISize"/>
			<meta><m n="inject"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</sizeInjected>
		<set_sizeExplicit set="method" line="14"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<c path="guise.traits.core.ISize"/>
</f></set_sizeExplicit>
		<sizeExplicit public="1" set="set_sizeExplicit"><c path="guise.traits.core.ISize"/></sizeExplicit>
		<size public="1" set="null"><c path="guise.traits.core.ISize"/></size>
		<new public="1" set="method" line="43"><f a="?sizeChanged:?sizeChangedValid:?sizeChangedInvalid">
	<f a=""><e path="Void"/></f>
	<f a=":">
		<c path="Float"/>
		<c path="Float"/>
		<e path="Void"/>
	</f>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.GuiseItem" params="" file="../src/guise/core/GuiseItem.hx">
		<extends path="composure.core.ComposeGroup"/>
		<createActive set="method" line="41"><f a=""><e path="Void"/></f></createActive>
		<createSize set="method" line="37"><f a="?w:?h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createSize>
		<createPosition set="method" line="33"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createPosition>
		<active public="1" set="null"><c path="guise.traits.core.IActive"/></active>
		<size public="1" set="null"><c path="guise.traits.core.ISize"/></size>
		<position public="1" set="null"><c path="guise.traits.core.IPosition"/></position>
		<new public="1" set="method" line="26"><f a="?x:?y:?w:?h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* This class provides a simple setup for many of the UI elements.
 * I should be considered a default setup, but never the superclass of all UI elements.
 * Alternative configurations can and will exist which replace or reconfigure these core traits.
 * 
 * 
 * @author Tom Byrne</haxe_doc>
	</class>
	<typedef path="guise.geom.Matrix" params="" file="../src/guise/geom/Matrix.hx"><t path="nme.geom.Matrix"/></typedef>
	<class path="guise.layer.LayerOrderer" params="" file="../src/guise/layer/LayerOrderer.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<checkDepths set="method" line="53"><f a=""><e path="Void"/></f></checkDepths>
		<onLayeringRemove public="1" set="method" line="48"><f a="access">
	<c path="guise.platform.types.ILayerOrderAccess"/>
	<e path="Void"/>
</f></onLayeringRemove>
		<onLayeringChanged set="method" line="45"><f a="from">
	<c path="guise.platform.types.ILayerOrderAccess"/>
	<e path="Void"/>
</f></onLayeringChanged>
		<onLayeringAdd public="1" set="method" line="38"><f a="access">
	<c path="guise.platform.types.ILayerOrderAccess"/>
	<e path="Void"/>
</f></onLayeringAdd>
		<_layerOrderAccess><c path="guise.platform.types.ILayerOrderAccess"/></_layerOrderAccess>
		<set_sorting set="method" line="19"><f a="value">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></set_sorting>
		<sorting public="1" set="set_sorting"><c path="Array"><c path="String"/></c></sorting>
		<new public="1" set="method" line="29"><f a="?sorting:?childMode">
	<c path="Array"><c path="String"/></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.layout.AbstractLayout" params="InfoType" file="../src/guise/layout/AbstractLayout.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<getPositionables set="method" line="46"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<t path="Iterable"><c path="guise.layout.IPositionable"/></t>
</f></getPositionables>
		<getItem set="method" line="43"><f a="trait">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
</f></getItem>
		<layoutChild set="method" line="40"><f a="trait">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<e path="Void"/>
</f></layoutChild>
		<removeLayoutChild public="1" set="method" line="35"><f a="trait:item">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></removeLayoutChild>
		<addLayoutChild public="1" set="method" line="30"><f a="trait:item">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></addLayoutChild>
		<_childToItem><c path="cmtc.ds.hash.ObjectHash">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
</c></_childToItem>
		<_children><c path="Array"><c path="guise.layout.AbstractLayout.InfoType"/></c></_children>
		<new set="method" line="18"><f a="t">
	<c path="Class"><c path="guise.layout.AbstractLayout.InfoType"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.layout.LayoutInfo" params="InfoType" file="../src/guise/layout/AbstractLayout.hx" module="guise.layout.AbstractLayout">
		<get_layoutInfoChanged set="method" line="55"><f a=""><c path="msignal.Signal1"><c path="guise.layout.LayoutInfo.InfoType"/></c></f></get_layoutInfoChanged>
		<_layoutInfoChanged><c path="msignal.Signal1"><c path="guise.layout.LayoutInfo.InfoType"/></c></_layoutInfoChanged>
		<layoutChanged set="method" line="57"><f a=""><e path="Void"/></f></layoutChanged>
		<layoutInfoChanged public="1" get="get_layoutInfoChanged" set="null">
			<c path="msignal.Signal1"><c path="guise.layout.LayoutInfo.InfoType"/></c>
			<meta><m n="lazyInst"/></meta>
		</layoutInfoChanged>
		<meta><m n=":build"><e>'???'</e></m></meta>
	</class>
	<class path="guise.layout.IPositionable" params="" file="../src/guise/layout/IPositionable.hx" interface="1">
		<setPosition public="1" set="method"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.layout.Position" params="" file="../src/guise/layout/Position.hx">
		<extends path="guise.layout.LayoutInfo"><c path="guise.layout.Position"/></extends>
		<setSize public="1" set="method" line="38"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setPosition public="1" set="method" line="33"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<set public="1" set="method" line="26"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<h public="1"><c path="Float"/></h>
		<w public="1"><c path="Float"/></w>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<new public="1" set="method" line="18"><f a="?x:?y:?w:?h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.layout.PositionManager" params="" file="../src/guise/layout/PositionManager.hx">
		<extends path="guise.layout.AbstractLayout"><c path="guise.layout.Position"/></extends>
		<layoutChild set="method" line="16" override="1"><f a="trait">
	<c path="guise.layout.Position"/>
	<e path="Void"/>
</f></layoutChild>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.IPlatformAccess" params="" file="../src/guise/platform/IPlatformAccess.hx" interface="1">
		<returnAccess public="1" set="method"><f a="access">
	<c path="guise.platform.IAccessType"/>
	<e path="Void"/>
</f></returnAccess>
		<requestAccess public="1" params="AccessType" set="method"><f a="context:accessType:?layerName">
	<c path="composure.core.ComposeItem"/>
	<c path="Class"><c path="requestAccess.AccessType"/></c>
	<c path="String"/>
	<c path="requestAccess.AccessType"/>
</f></requestAccess>
		<accessTypeSupported public="1" set="method"><f a="layerAccess:accessType">
	<e path="Bool"/>
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<e path="Bool"/>
</f></accessTypeSupported>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.AbsPlatformAccess" params="ContInfoType:LayerInfoType" file="../src/guise/platform/AbsPlatformAccess.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<implements path="guise.platform.IPlatformAccess"/>
		<assessBundle set="method" line="136"><f a="bundle:context">
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</c>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></assessBundle>
		<returnAccess public="1" set="method" line="105"><f a="access">
	<c path="guise.platform.IAccessType"/>
	<e path="Void"/>
</f></returnAccess>
		<getContBundle set="method" line="93"><f a="context">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</c>
</f></getContBundle>
		<requestAccess public="1" params="AccessType" set="method" line="74"><f a="context:accessType:?layerName">
	<c path="composure.core.ComposeItem"/>
	<c path="Class"><c path="requestAccess.AccessType"/></c>
	<c path="String"/>
	<c path="requestAccess.AccessType"/>
</f></requestAccess>
		<accessTypeSupported public="1" set="method" line="70"><f a="layerAccess:accessType">
	<e path="Bool"/>
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<e path="Bool"/>
</f></accessTypeSupported>
		<registerLayerAccess params="AccessClass" set="method" line="64"><f a="klass:types:createHandler:destroyHandler">
	<c path="Class"><c path="registerLayerAccess.AccessClass"/></c>
	<c path="Array"><c path="Class"><c path="guise.platform.IAccessType"/></c></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="registerLayerAccess.AccessClass"/>
	</f>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="registerLayerAccess.AccessClass"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></registerLayerAccess>
		<registerAccess params="AccessClass" set="method" line="58"><f a="klass:types:createHandler:destroyHandler">
	<c path="Class"><c path="registerAccess.AccessClass"/></c>
	<c path="Array"><c path="Class"><c path="guise.platform.IAccessType"/></c></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="registerAccess.AccessClass"/>
	</f>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="registerAccess.AccessClass"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></registerAccess>
		<addContainerFurnisher params="TagType" set="method" line="54"><f a="tagType:onCreate:?onDestroy">
	<d/>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="addContainerFurnisher.TagType"/>
		<c path="Array"><d/></c>
	</f>
	<f a="::">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="addContainerFurnisher.TagType"/>
		<c path="Array"><d/></c>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></addContainerFurnisher>
		<_typeToDestroyLayer><c path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</c></_typeToDestroyLayer>
		<_typeToCreateLayer><c path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</c></_typeToCreateLayer>
		<_typeToDestroy><c path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</c></_typeToDestroy>
		<_typeToCreate><c path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</c></_typeToCreate>
		<_destroyLayerInfo><f a="">
	<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	<e path="Void"/>
</f></_destroyLayerInfo>
		<_createLayerInfo><f a=":">
	<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
	<c path="String"/>
	<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
</f></_createLayerInfo>
		<_destroyContInfo><f a="">
	<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
	<e path="Void"/>
</f></_destroyContInfo>
		<_createContInfo><f a="">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
</f></_createContInfo>
		<_accessToDetails><c path="cmtc.ds.hash.ObjectHash">
	<c path="guise.platform.IAccessType"/>
	<t path="guise.platform.RequestDetails"/>
</c></_accessToDetails>
		<_contextToBundle><c path="cmtc.ds.hash.ObjectHash">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</c>
</c></_contextToBundle>
		<new public="1" set="method" line="33"><f a="createContInfo:destroyContInfo:createLayerInfo:destroyLayerInfo">
	<f a="">
		<c path="composure.core.ComposeItem"/>
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
	</f>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<e path="Void"/>
	</f>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="String"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</f>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<typedef path="guise.platform.RequestDetails" params="" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess"><a>
	<layerName><c path="String"/></layerName>
	<context><c path="composure.core.ComposeItem"/></context>
</a></typedef>
	<class path="guise.platform.AbsBundle" params="InfoType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<isEmpty public="1" set="method" line="286"><f a=""><e path="Bool"/></f></isEmpty>
		<returnAccess public="1" params="AccessType" set="method" line="274"><f a="access">
	<c path="returnAccess.AccessType"/>
	<e path="Void"/>
</f></returnAccess>
		<requestAccess public="1" params="AccessType" set="method" line="258"><f a="accessType">
	<c path="Class"><c path="requestAccess.AccessType"/></c>
	<c path="requestAccess.AccessType"/>
</f></requestAccess>
		<getAccess public="1" params="AccessType" set="method" line="254"><f a="accessType">
	<c path="Class"><c path="getAccess.AccessType"/></c>
	<c path="getAccess.AccessType"/>
</f></getAccess>
		<_info><c path="guise.platform.AbsBundle.InfoType"/></_info>
		<accessToDestroy public="1"><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a=":">
		<c path="guise.platform.AbsBundle.InfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</c></accessToDestroy>
		<accessToCreate public="1"><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a="">
		<c path="guise.platform.AbsBundle.InfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</c></accessToCreate>
		<_accessToType><c path="cmtc.ds.hash.ObjectHash">
	<c path="guise.platform.IAccessType"/>
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
</c></_accessToType>
		<_createToAccess><c path="cmtc.ds.hash.ObjectHash">
	<f a="">
		<c path="guise.platform.AbsBundle.InfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
	<c path="guise.platform.IAccessType"/>
</c></_createToAccess>
		<_accessToCount><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="Int"/>
</c></_accessToCount>
		<_totalCount><c path="Int"/></_totalCount>
		<new public="1" set="method" line="247"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="guise.platform.ContBundle" params="ContInfoType:LayerInfoType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<extends path="guise.platform.AbsBundle"><c path="guise.platform.ContBundle.ContInfoType"/></extends>
		<cleanup public="1" set="method" line="210"><f a=""><e path="Void"/></f></cleanup>
		<isEmpty public="1" set="method" line="207" override="1"><f a=""><e path="Bool"/></f></isEmpty>
		<returnLayerAccess public="1" params="AccessType" set="method" line="195"><f a="layerName:access">
	<c path="String"/>
	<c path="returnLayerAccess.AccessType"/>
	<e path="Void"/>
</f></returnLayerAccess>
		<requestLayerAccess public="1" params="AccessType" set="method" line="184"><f a="layerName:accessType">
	<c path="String"/>
	<c path="Class"><c path="requestLayerAccess.AccessType"/></c>
	<c path="requestLayerAccess.AccessType"/>
</f></requestLayerAccess>
		<removeDependency public="1" set="method" line="180"><f a=""><e path="Void"/></f></removeDependency>
		<addDependency public="1" set="method" line="177"><f a=""><e path="Void"/></f></addDependency>
		<accessToDestroyLayer public="1"><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a=":">
		<c path="guise.platform.ContBundle.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</c></accessToDestroyLayer>
		<accessToCreateLayer public="1"><c path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a="">
		<c path="guise.platform.ContBundle.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</c></accessToCreateLayer>
		<_dependencyCount><c path="Int"/></_dependencyCount>
		<_layerCount><c path="Int"/></_layerCount>
		<_destroyLayerInfo><f a="">
	<c path="guise.platform.ContBundle.LayerInfoType"/>
	<e path="Void"/>
</f></_destroyLayerInfo>
		<_createLayerInfo><f a=":">
	<c path="guise.platform.ContBundle.ContInfoType"/>
	<c path="String"/>
	<c path="guise.platform.ContBundle.LayerInfoType"/>
</f></_createLayerInfo>
		<layers><c path="Hash"><c path="guise.platform.LayerBundle">
	<c path="guise.platform.ContBundle.ContInfoType"/>
	<c path="guise.platform.ContBundle.LayerInfoType"/>
</c></c></layers>
		<contInfo public="1" set="null"><c path="guise.platform.ContBundle.ContInfoType"/></contInfo>
		<new public="1" set="method" line="165"><f a="contInfo:createLayerInfo:destroyLayerInfo">
	<c path="guise.platform.ContBundle.ContInfoType"/>
	<f a=":">
		<c path="guise.platform.ContBundle.ContInfoType"/>
		<c path="String"/>
		<c path="guise.platform.ContBundle.LayerInfoType"/>
	</f>
	<f a="">
		<c path="guise.platform.ContBundle.LayerInfoType"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.LayerBundle" params="ContInfoType:LayerInfoType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<extends path="guise.platform.AbsBundle"><c path="guise.platform.LayerBundle.LayerInfoType"/></extends>
		<cleanup public="1" set="method" line="229"><f a=""><e path="Void"/></f></cleanup>
		<name public="1"><c path="String"/></name>
		<layerInfo public="1" set="null"><c path="guise.platform.LayerBundle.LayerInfoType"/></layerInfo>
		<new public="1" set="method" line="222"><f a="layerInfo">
	<c path="guise.platform.LayerBundle.LayerInfoType"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.FurnisherBundle" params="ContInfoType:LayerInfoType:TagType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<onRemove set="method" line="328"><f a="tag:context">
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onRemove>
		<onAdd set="method" line="319"><f a="tag:context">
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onAdd>
		<_tagToTraits><c path="cmtc.ds.hash.ObjectHash">
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
</c></_tagToTraits>
		<_assessBundle><f a=":">
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.FurnisherBundle.ContInfoType"/>
		<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
	</c>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></_assessBundle>
		<_getContBundle><f a="">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.FurnisherBundle.ContInfoType"/>
		<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
	</c>
</f></_getContBundle>
		<_onDestroy><t path="Null"><f a="::">
	<c path="guise.platform.FurnisherBundle.ContInfoType"/>
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></t></_onDestroy>
		<_onCreate><f a=":">
	<c path="guise.platform.FurnisherBundle.ContInfoType"/>
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
</f></_onCreate>
		<_tagType><d/></_tagType>
		<_injector><c path="composure.injectors.Injector"/></_injector>
		<getInjector public="1" set="method" line="295"><f a=""><c path="composure.injectors.Injector"/></f></getInjector>
		<new public="1" set="method" line="307"><f a="tagType:onCreate:onDestroy:getContBundle:assessBundle">
	<d/>
	<f a=":">
		<c path="guise.platform.FurnisherBundle.ContInfoType"/>
		<c path="guise.platform.FurnisherBundle.TagType"/>
		<c path="Array"><d/></c>
	</f>
	<t path="Null"><f a="::">
	<c path="guise.platform.FurnisherBundle.ContInfoType"/>
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></t>
	<f a="">
		<c path="composure.core.ComposeItem"/>
		<c path="guise.platform.ContBundle">
			<c path="guise.platform.FurnisherBundle.ContInfoType"/>
			<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
		</c>
	</f>
	<f a=":">
		<c path="guise.platform.ContBundle">
			<c path="guise.platform.FurnisherBundle.ContInfoType"/>
			<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
		</c>
		<c path="composure.core.ComposeItem"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.IAccessType" params="" file="../src/guise/platform/IPlatformAccess.hx" module="guise.platform.IPlatformAccess" interface="1"/>
	<class path="guise.platform.IFocusableAccess" params="" file="../src/guise/platform/IPlatformAccess.hx" module="guise.platform.IPlatformAccess" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<focusedChanged public="1" get="get_focusedChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.IFocusableAccess"/></c></focusedChanged>
		<focused public="1" set="null"><e path="Bool"/></focused>
	</class>
	<class path="guise.platform.PlatformAccessor" params="AccessType" file="../src/guise/platform/PlatformAccessor.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onAccessRemove set="dynamic" line="92"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onAccessRemove>
		<onAccessAdd set="dynamic" line="89"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onAccessAdd>
		<returnAccess set="method" line="81"><f a=""><e path="Void"/></f></returnAccess>
		<requestAccess set="method" line="73"><f a=""><e path="Void"/></f></requestAccess>
		<onInjectRemove set="method" line="67"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onInjectRemove>
		<onInjectAdd set="method" line="61"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onInjectAdd>
		<onItemRemove set="method" line="55" override="1"><f a=""><e path="Void"/></f></onItemRemove>
		<onItemAdd set="method" line="49" override="1"><f a=""><e path="Void"/></f></onItemAdd>
		<_accessType><c path="Class"><c path="guise.platform.PlatformAccessor.AccessType"/></c></_accessType>
		<_injected><c path="guise.platform.PlatformAccessor.AccessType"/></_injected>
		<_access><c path="guise.platform.PlatformAccessor.AccessType"/></_access>
		<_accessTaken><e path="Bool"/></_accessTaken>
		<set_layerName set="method" line="24"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_layerName>
		<layerName public="1" set="set_layerName"><c path="String"/></layerName>
		<set_platformAccess set="method" line="16"><f a="value">
	<c path="guise.platform.IPlatformAccess"/>
	<c path="guise.platform.IPlatformAccess"/>
</f></set_platformAccess>
		<platformAccess public="1" set="set_platformAccess">
			<c path="guise.platform.IPlatformAccess"/>
			<meta><m n="inject"><e>{asc:true}</e></m></meta>
		</platformAccess>
		<new public="1" set="method" line="36"><f a="accessType:?layerName:?onAccessAdd:?onAccessRemove:?inject">
	<c path="Class"><c path="guise.platform.PlatformAccessor.AccessType"/></c>
	<c path="String"/>
	<f a="">
		<c path="guise.platform.PlatformAccessor.AccessType"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="guise.platform.PlatformAccessor.AccessType"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.types.IFrameTicker" params="" file="../src/guise/platform/types/CoreAccessTypes.hx" module="guise.platform.types.CoreAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setIntendedFPS public="1" set="method"><f a="fps">
	<c path="Int"/>
	<e path="Void"/>
</f></setIntendedFPS>
		<actualFPS public="1" set="null"><c path="Float"/></actualFPS>
		<frameTick public="1" set="null"><c path="msignal.Signal0"/></frameTick>
	</class>
	<class path="guise.platform.cross.core.FrameTicker" params="" file="../src/guise/platform/cross/core/FrameTicker.hx">
		<implements path="guise.platform.types.IFrameTicker"/>
		<tick public="1" set="method" line="35"><f a=""><e path="Void"/></f></tick>
		<setIntendedFPS public="1" set="method" line="26"><f a="fps">
	<c path="Int"/>
	<e path="Void"/>
</f></setIntendedFPS>
		<_frames><c path="Array"><c path="Float"/></c></_frames>
		<_timer><c path="haxe.Timer"/></_timer>
		<actualFPS public="1" set="null"><c path="Float"/></actualFPS>
		<frameTick public="1" set="null"><c path="msignal.Signal0"/></frameTick>
		<new public="1" set="method" line="18"><f a="?intendedFPS">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.native.NativePlatformAccess" params="" file="../src/guise/platform/native/NativePlatformAccess.hx">
		<install public="1" set="method" line="14" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.nme.NmePlatformAccess" params="" file="../src/guise/platform/nme/NmePlatformAccess.hx">
		<extends path="guise.platform.AbsPlatformAccess">
			<c path="guise.platform.nme.ContInfo"/>
			<c path="guise.platform.nme.LayerInfo"/>
		</extends>
		<install public="1" set="method" line="40" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<_frameTicker static="1"><c path="guise.platform.nme.core.FrameTicker"/></_frameTicker>
		<_keyboardAccess static="1"><c path="guise.platform.nme.input.KeyboardAccess"/></_keyboardAccess>
		<returnMouseClickLayerAccess set="method" line="178"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
	<e path="Void"/>
</f></returnMouseClickLayerAccess>
		<getMouseClickLayerAccess set="method" line="174"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
</f></getMouseClickLayerAccess>
		<returnMouseClickAccess set="method" line="171"><f a="layer:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
	<e path="Void"/>
</f></returnMouseClickAccess>
		<getMouseClickAccess set="method" line="168"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
</f></getMouseClickAccess>
		<returnMouseIntLayerAccess set="method" line="165"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
	<e path="Void"/>
</f></returnMouseIntLayerAccess>
		<getMouseIntLayerAccess set="method" line="161"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
</f></getMouseIntLayerAccess>
		<returnMouseIntAccess set="method" line="158"><f a="layer:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
	<e path="Void"/>
</f></returnMouseIntAccess>
		<getMouseIntAccess set="method" line="155"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
</f></getMouseIntAccess>
		<returnGraphicsAccess set="method" line="152"><f a="cont:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.GraphicsAccess"/>
	<e path="Void"/>
</f></returnGraphicsAccess>
		<getGraphicsAccess set="method" line="146"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.GraphicsAccess"/>
</f></getGraphicsAccess>
		<returnFilterableAccess set="method" line="142"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.FilterableAccess"/>
	<e path="Void"/>
</f></returnFilterableAccess>
		<getFilterableAccess set="method" line="137"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.FilterableAccess"/>
</f></getFilterableAccess>
		<returnSizableAccess set="method" line="133"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.SizableDisplayAccess"/>
	<e path="Void"/>
</f></returnSizableAccess>
		<getSizableAccess set="method" line="126"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.SizableDisplayAccess"/>
</f></getSizableAccess>
		<returnFocusableAccess set="method" line="123"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.FocusableAccess"/>
	<e path="Void"/>
</f></returnFocusableAccess>
		<getFocusableAccess set="method" line="119"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.FocusableAccess"/>
</f></getFocusableAccess>
		<returnTextAccess set="method" line="113"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.TextAccess"/>
	<e path="Void"/>
</f></returnTextAccess>
		<getTextAccess set="method" line="109"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.TextAccess"/>
</f></getTextAccess>
		<returnLayeringAccess set="method" line="106"><f a="cont:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.display.LayerOrderAccess"/>
	<e path="Void"/>
</f></returnLayeringAccess>
		<getLayeringAccess set="method" line="103"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.display.LayerOrderAccess"/>
</f></getLayeringAccess>
		<returnKeyLayerAccess set="method" line="99"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
	<e path="Void"/>
</f></returnKeyLayerAccess>
		<getKeyLayerAccess set="method" line="95"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
</f></getKeyLayerAccess>
		<returnKeyAccess set="method" line="92"><f a="layer:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
	<e path="Void"/>
</f></returnKeyAccess>
		<getKeyAccess set="method" line="87"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
</f></getKeyAccess>
		<returnFrameTicker set="method" line="85"><f a="info:access">
	<d/>
	<c path="guise.platform.nme.core.FrameTicker"/>
	<e path="Void"/>
</f></returnFrameTicker>
		<getFrameTicker set="method" line="81"><f a="info">
	<d/>
	<c path="guise.platform.nme.core.FrameTicker"/>
</f></getFrameTicker>
		<set_stageTrait set="method" line="75"><f a="value">
	<c path="guise.platform.nme.display.StageTrait"/>
	<c path="guise.platform.nme.display.StageTrait"/>
</f></set_stageTrait>
		<stageTrait public="1" set="set_stageTrait">
			<c path="guise.platform.nme.display.StageTrait"/>
			<meta><m n="inject"><e>{asc:true}</e></m></meta>
		</stageTrait>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.nme.ContInfo" params="" file="../src/guise/platform/nme/NmePlatformAccess.hx" module="guise.platform.nme.NmePlatformAccess">
		<create public="1" set="method" line="184" static="1"><f a="context">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.nme.ContInfo"/>
</f></create>
		<destroy public="1" set="method" line="187" static="1"><f a="contInfo">
	<c path="guise.platform.nme.ContInfo"/>
	<e path="Void"/>
</f></destroy>
		<_contSkin><c path="guise.platform.nme.display.ContainerSkin"/></_contSkin>
		<set_context set="method" line="195"><f a="value">
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></set_context>
		<context public="1" set="set_context"><c path="composure.core.ComposeItem"/></context>
		<container public="1" set="null"><t path="nme.display.Sprite"/></container>
		<new public="1" set="method" line="204"><f a="context">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.nme.LayerInfo" params="" file="../src/guise/platform/nme/NmePlatformAccess.hx" module="guise.platform.nme.NmePlatformAccess">
		<create public="1" set="method" line="215" static="1"><f a="contInfo:layerName">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="String"/>
	<c path="guise.platform.nme.LayerInfo"/>
</f></create>
		<destroy public="1" set="method" line="218" static="1"><f a="layerInfo">
	<c path="guise.platform.nme.LayerInfo"/>
	<e path="Void"/>
</f></destroy>
		<assessDisplayObject public="1" set="method" line="271"><f a=""><e path="Void"/></f></assessDisplayObject>
		<createContainer public="1" set="method" line="263"><f a=""><e path="Void"/></f></createContainer>
		<createTextField public="1" set="method" line="252"><f a=""><e path="Void"/></f></createTextField>
		<filterable public="1"><c path="guise.platform.nme.display.FilterableAccess"/></filterable>
		<sizable public="1"><c path="guise.platform.nme.display.SizableDisplayAccess"/></sizable>
		<layerName public="1"><c path="String"/></layerName>
		<container public="1"><t path="nme.display.Sprite"/></container>
		<textField public="1"><t path="nme.text.TextField"/></textField>
		<displayObject public="1"><t path="nme.display.DisplayObject"/></displayObject>
		<set_contInfo set="method" line="225"><f a="value">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.ContInfo"/>
</f></set_contInfo>
		<contInfo public="1" set="set_contInfo"><c path="guise.platform.nme.ContInfo"/></contInfo>
		<new public="1" set="method" line="245"><f a="contInfo:layerName">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.nme.core.FrameTicker" params="" file="../src/guise/platform/nme/core/FrameTicker.hx">
		<extends path="guise.platform.cross.core.FrameTicker"/>
		<onEnterFrame public="1" set="method" line="25"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onEnterFrame>
		<setIntendedFPS public="1" set="method" line="21" override="1"><f a="fps">
	<c path="Int"/>
	<e path="Void"/>
</f></setIntendedFPS>
		<new public="1" set="method" line="15"><f a="?intendedFPS">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.nme.display.DisplaySkin" params="" file="../src/guise/platform/nme/display/DisplaySkin.hx">
		<extends path="guise.core.AbsPosAwareTrait"/>
		<implements path="guise.layout.IPositionable"/>
		<setPosition public="1" set="method" line="78"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<posChanged set="method" line="72" override="1"><f a=""><e path="Void"/></f></posChanged>
		<setDisplayObject set="method" line="58"><f a="value">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></setDisplayObject>
		<assumeDisplayObject set="method" line="54"><f a=""><e path="Void"/></f></assumeDisplayObject>
		<onParentRemoved set="method" line="46"><f a="parent">
	<c path="guise.platform.nme.display.ContainerSkin"/>
	<e path="Void"/>
</f></onParentRemoved>
		<onParentAdded set="method" line="38"><f a="parent">
	<c path="guise.platform.nme.display.ContainerSkin"/>
	<e path="Void"/>
</f></onParentAdded>
		<_parent><c path="guise.platform.nme.display.ContainerSkin"/></_parent>
		<displayObject public="1" set="null"><t path="nme.display.DisplayObject"/></displayObject>
		<new public="1" set="method" line="23"><f a="?displayObject">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.nme.display.ContainerSkin" params="" file="../src/guise/platform/nme/display/ContainerSkin.hx">
		<extends path="guise.platform.nme.display.DisplaySkin"/>
		<setContainer set="method" line="25"><f a="container">
	<t path="nme.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></setContainer>
		<assumeDisplayObject set="method" line="22" override="1"><f a=""><e path="Void"/></f></assumeDisplayObject>
		<sprite public="1" set="null"><t path="nme.display.Sprite"/></sprite>
		<container public="1" set="null"><t path="nme.display.DisplayObjectContainer"/></container>
		<new public="1" set="method" line="18"><f a="?container">
	<t path="nme.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.types.IFilterableAccess" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setFilters public="1" set="method"><f a="?filters">
	<c path="Array"><e path="guise.platform.types.FilterType"/></c>
	<e path="Void"/>
</f></setFilters>
	</class>
	<class path="guise.platform.nme.display.FilterableAccess" params="" file="../src/guise/platform/nme/display/FilterableAccess.hx">
		<implements path="guise.platform.types.IFilterableAccess"/>
		<transAngle get="inline" set="null" line="59"><f a="rads:inner">
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></transAngle>
		<setFilters public="1" set="method" line="35"><f a="?filters">
	<c path="Array"><e path="guise.platform.types.FilterType"/></c>
	<e path="Void"/>
</f></setFilters>
		<_lastFilters><c path="Array"><t path="nme.filters.BitmapFilter"/></c></_lastFilters>
		<set_displayObject set="method" line="17"><f a="value">
	<t path="nme.display.DisplayObject"/>
	<t path="nme.display.DisplayObject"/>
</f></set_displayObject>
		<displayObject public="1" set="set_displayObject"><t path="nme.display.DisplayObject"/></displayObject>
		<new public="1" set="method" line="31"><f a="?displayObject">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IGraphics" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<moveTo public="1" set="method"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?pixelHinting:?caps:?joints">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="guise.platform.types.CapsStyle"/>
	<e path="guise.platform.types.JointStyle"/>
	<e path="Void"/>
</f></lineStyle>
		<beginStroke public="1" set="method"><f a="?color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginStroke>
		<beginGradientStroke public="1" set="method"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientStroke>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawRoundRect public="1" set="method"><f a="x:y:w:h:r">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawEllipse public="1" set="method"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<curveTo public="1" set="method"><f a="inCX:inCY:inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginGradientFill public="1" set="method"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
	</class>
	<class path="guise.platform.types.IBitmapGraphics" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes" interface="1">
		<implements path="guise.platform.types.IGraphics"/>
		<beginBitmapStroke public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapStroke>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
	</class>
	<class path="guise.platform.nme.display.GraphicsAccess" params="" file="../src/guise/platform/nme/display/GraphicsAccess.hx">
		<implements path="guise.platform.types.IBitmapGraphics"/>
		<sortGradPoints set="method" line="233"><f a="gp1:gp2">
	<a>
		<fract><c path="Float"/></fract>
		<c><c path="Int"/></c>
		<a><c path="Float"/></a>
	</a>
	<a>
		<fract><c path="Float"/></fract>
		<c><c path="Int"/></c>
		<a><c path="Float"/></a>
	</a>
	<c path="Int"/>
</f></sortGradPoints>
		<moveTo public="1" set="method" line="228"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method" line="222"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method" line="198"><f a="?thickness:?pixelHinting:?caps:?joints">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="guise.platform.types.CapsStyle"/>
	<e path="guise.platform.types.JointStyle"/>
	<e path="Void"/>
</f></lineStyle>
		<beginStroke public="1" set="method" line="191"><f a="?color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginStroke>
		<_miterLimit><c path="Float"/></_miterLimit>
		<_joints><t path="nme.display.JointStyle"/></_joints>
		<_caps><t path="nme.display.CapsStyle"/></_caps>
		<_pixelHinting><e path="Bool"/></_pixelHinting>
		<_thickness><c path="Float"/></_thickness>
		<_alpha><c path="Float"/></_alpha>
		<_color><c path="Int"/></_color>
		<beginGradientStroke public="1" set="method" line="131"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientStroke>
		<beginBitmapStroke public="1" set="method" line="123"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapStroke>
		<endFill public="1" set="method" line="118"><f a=""><e path="Void"/></f></endFill>
		<drawRoundRect public="1" set="method" line="113"><f a="x:y:w:h:r">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method" line="107"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawEllipse public="1" set="method" line="101"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<curveTo public="1" set="method" line="95"><f a="inCX:inCY:inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<clear public="1" set="method" line="89"><f a=""><e path="Void"/></f></clear>
		<beginGradientFill public="1" set="method" line="37"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginBitmapFill public="1" set="method" line="33"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method" line="28"><f a="color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<graphics public="1"><t path="nme.display.Graphics"/></graphics>
		<new public="1" set="method" line="22"><f a="?graphics">
	<t path="nme.display.Graphics"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.ILayerOrderAccess" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<swapDepths public="1" set="method"><f a="layer1:layer2">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></swapDepths>
		<layers public="1" set="null"><c path="Array"><c path="String"/></c></layers>
		<layeringChanged public="1" get="get_layeringChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ILayerOrderAccess"/></c></layeringChanged>
	</class>
	<class path="guise.platform.nme.display.LayerOrderAccess" params="" file="../src/guise/platform/nme/display/LayerOrderAccess.hx">
		<implements path="guise.platform.types.ILayerOrderAccess"/>
		<checkLayers set="method" line="47"><f a=""><e path="Void"/></f></checkLayers>
		<swapDepths public="1" set="method" line="43"><f a="layer1:layer2">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></swapDepths>
		<layers public="1" set="null"><c path="Array"><c path="String"/></c></layers>
		<onChildAdded set="method" line="35"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onChildAdded>
		<setcontainer set="method" line="20"><f a="value">
	<t path="nme.display.DisplayObjectContainer"/>
	<t path="nme.display.DisplayObjectContainer"/>
</f></setcontainer>
		<container public="1" set="setcontainer"><t path="nme.display.DisplayObjectContainer"/></container>
		<get_layeringChanged set="method" line="14"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ILayerOrderAccess"/></c></f></get_layeringChanged>
		<layeringChanged public="1" get="get_layeringChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ILayerOrderAccess"/></c></layeringChanged>
		<new public="1" set="method" line="32"><f a="container">
	<t path="nme.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.ISizableDisplayAccess" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setSize public="1" set="method"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></setSize>
		<setPos public="1" set="method"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></setPos>
		<getMeasHeight public="1" set="method"><f a=""><c path="Float"/></f></getMeasHeight>
		<getMeasWidth public="1" set="method"><f a=""><c path="Float"/></f></getMeasWidth>
		<measChanged public="1" get="get_measChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ISizableDisplayAccess"/></c></measChanged>
	</class>
	<class path="guise.platform.nme.display.SizableDisplayAccess" params="" file="../src/guise/platform/nme/display/SizableDisplayAccess.hx">
		<implements path="guise.platform.types.ISizableDisplayAccess"/>
		<TEXT_FIELD_GUTTER line="16" static="1"><c path="Float"/></TEXT_FIELD_GUTTER>
		<validateMeas set="method" line="136"><f a=""><e path="Void"/></f></validateMeas>
		<invalidateMeas set="method" line="131"><f a=""><e path="Void"/></f></invalidateMeas>
		<sizeDisplay set="method" line="127"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></sizeDisplay>
		<sizeTextField set="method" line="123"><f a="textField">
	<t path="nme.text.TextField"/>
	<e path="Void"/>
</f></sizeTextField>
		<onSizeChanged set="method" line="115"><f a="from">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></onSizeChanged>
		<setSize public="1" set="method" line="105"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></setSize>
		<positionDisplay set="method" line="99"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></positionDisplay>
		<positionTextField set="method" line="95"><f a="textField">
	<t path="nme.text.TextField"/>
	<e path="Void"/>
</f></positionTextField>
		<onPosChanged set="method" line="87"><f a="from">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></onPosChanged>
		<setPos public="1" set="method" line="77"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></setPos>
		<getMeasHeight public="1" set="method" line="72"><f a=""><c path="Float"/></f></getMeasHeight>
		<getMeasWidth public="1" set="method" line="68"><f a=""><c path="Float"/></f></getMeasWidth>
		<onTextChanged set="method" line="64"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onTextChanged>
		<removeDisplay public="1" set="method" line="54"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></removeDisplay>
		<addDisplay public="1" set="method" line="39"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></addDisplay>
		<_measInvalid><e path="Bool"/></_measInvalid>
		<_measHeight><c path="Float"/></_measHeight>
		<_measWidth><c path="Float"/></_measWidth>
		<_textFields><c path="Array"><t path="nme.text.TextField"/></c></_textFields>
		<_displays><c path="Array"><t path="nme.display.DisplayObject"/></c></_displays>
		<_size><c path="guise.traits.core.ISize"/></_size>
		<_position><c path="guise.traits.core.IPosition"/></_position>
		<get_measChanged set="method" line="19"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ISizableDisplayAccess"/></c></f></get_measChanged>
		<measChanged public="1" get="get_measChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ISizableDisplayAccess"/></c></measChanged>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.nme.display.StageTrait" params="" file="../src/guise/platform/nme/display/StageTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<_stage><t path="nme.display.Stage"/></_stage>
		<get_stage set="method" line="20"><f a=""><t path="nme.display.Stage"/></f></get_stage>
		<stage public="1" get="get_stage" set="null"><t path="nme.display.Stage"/></stage>
		<new public="1" set="method" line="26"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.nme.input.FocusableAccess" params="" file="../src/guise/platform/nme/input/FocusableAccess.hx">
		<implements path="guise.platform.IFocusableAccess"/>
		<get_focusedChanged set="method" line="44"><f a=""><c path="msignal.Signal1"><c path="guise.platform.IFocusableAccess"/></c></f></get_focusedChanged>
		<focusedChanged public="1" get="get_focusedChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.IFocusableAccess"/></c></focusedChanged>
		<focused public="1" set="null"><e path="Bool"/></focused>
		<onFocusOut set="method" line="36"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusOut>
		<onFocusIn set="method" line="32"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusIn>
		<set_interactiveObject set="method" line="15"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="28"><f a="?interactiveObject">
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IKeyboardAccess" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<isDown public="1" set="method"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<e path="Bool"/>
</f></isDown>
		<keyUp public="1" set="method"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyUp>
		<keyDown public="1" set="method"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyDown>
	</class>
	<class path="guise.platform.nme.input.KeyboardAccess" params="" file="../src/guise/platform/nme/input/KeyboardAccess.hx">
		<implements path="guise.platform.types.IKeyboardAccess"/>
		<getModStr set="method" line="126"><f a="mods">
	<c path="Array"><e path="guise.platform.types.ModKeys"/></c>
	<c path="String"/>
</f></getModStr>
		<getKey set="method" line="118"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="String"/>
</f></getKey>
		<isDown public="1" set="method" line="109"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<e path="Bool"/>
</f></isDown>
		<getSignal public="1" set="method" line="98"><f a="keyInfo:from">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></getSignal>
		<keyDown public="1" set="method" line="95"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyDown>
		<keyUp public="1" set="method" line="92"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyUp>
		<dispatchFrom public="1" set="method" line="85"><f a="key:signals">
	<c path="String"/>
	<c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c>
	<e path="Void"/>
</f></dispatchFrom>
		<dispatchSignals set="method" line="55"><f a="keyCode:charCode:ctrl:alt:shift:signals:isDown">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></dispatchSignals>
		<onKeyDown set="method" line="50"><f a="e">
	<t path="nme.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<onKeyUp set="method" line="46"><f a="e">
	<t path="nme.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyUp>
		<_isDown><c path="Hash"><e path="Bool"/></c></_isDown>
		<_keyInfos><c path="Hash"><e path="guise.platform.types.KeyInfo"/></c></_keyInfos>
		<_downSignals><c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c></_downSignals>
		<_upSignals><c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c></_upSignals>
		<set_interactiveObject set="method" line="15"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="35"><f a="?interactiveObject">
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IMouseClickable" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<doubleClicked public="1" get="get_doubleClicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></doubleClicked>
		<clicked public="1" get="get_clicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></clicked>
	</class>
	<class path="guise.platform.nme.input.MouseClickable" params="" file="../src/guise/platform/nme/input/MouseClickable.hx">
		<implements path="guise.platform.types.IMouseClickable"/>
		<get_doubleClicked set="method" line="72"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></f></get_doubleClicked>
		<doubleClicked public="1" get="get_doubleClicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></doubleClicked>
		<_doubleClicked><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></_doubleClicked>
		<get_clicked set="method" line="62"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></f></get_clicked>
		<clicked public="1" get="get_clicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></clicked>
		<_clicked><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></_clicked>
		<onDoubleClicked set="method" line="53"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onDoubleClicked>
		<onClicked set="method" line="47"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClicked>
		<setClickInfo set="method" line="37"><f a="left:altHeld:ctrlHeld:shiftHeld">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setClickInfo>
		<clickInfo><c path="guise.platform.types.ClickInfo"/></clickInfo>
		<set_interactiveObject set="method" line="17"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="32"><f a="?interactiveObject">
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IMouseInteractions" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<moved public="1" get="get_moved" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></moved>
		<rolledOut public="1" get="get_rolledOut" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOut>
		<rolledOver public="1" get="get_rolledOver" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOver>
		<released public="1" get="get_released" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></released>
		<pressed public="1" get="get_pressed" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></pressed>
	</class>
	<class path="guise.platform.nme.input.MouseInteractions" params="" file="../src/guise/platform/nme/input/MouseInteractions.hx">
		<implements path="guise.platform.types.IMouseInteractions"/>
		<get_moved set="method" line="142"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_moved>
		<moved public="1" get="get_moved" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></moved>
		<_moved><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_moved>
		<get_rolledOut set="method" line="132"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_rolledOut>
		<rolledOut public="1" get="get_rolledOut" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOut>
		<_rolledOut><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_rolledOut>
		<get_rolledOver set="method" line="119"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_rolledOver>
		<rolledOver public="1" get="get_rolledOver" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOver>
		<_rolledOver><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_rolledOver>
		<get_released set="method" line="109"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_released>
		<released public="1" get="get_released" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></released>
		<_released><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_released>
		<get_pressed set="method" line="99"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_pressed>
		<pressed public="1" get="get_pressed" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></pressed>
		<_pressed><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_pressed>
		<setMouseInfo set="method" line="84"><f a=""><e path="Void"/></f></setMouseInfo>
		<onMoved set="method" line="78"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onMoved>
		<onRolledOut set="method" line="71"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onRolledOut>
		<onRolledOver set="method" line="64"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onRolledOver>
		<onReleased set="method" line="57"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onReleased>
		<onPressed set="method" line="48"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onPressed>
		<_isOver><e path="Bool"/></_isOver>
		<mouseInfo><c path="guise.platform.types.MouseInfo"/></mouseInfo>
		<coordinateSpace public="1"><t path="nme.display.InteractiveObject"/></coordinateSpace>
		<set_interactiveObject set="method" line="17"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="42"><f a="?interactiveObject:?coordinateSpace">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.ITextOutputAccess" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setText public="1" set="method"><f a="run:isHtml">
	<c path="guise.platform.types.TextRun"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setText>
		<setAntiAliasing public="1" set="method"><f a="type">
	<e path="guise.platform.types.AntiAliasType"/>
	<e path="Void"/>
</f></setAntiAliasing>
		<selectable public="1" set="set_selectable"><e path="Bool"/></selectable>
		<getTextHeight public="1" set="method"><f a=""><c path="Float"/></f></getTextHeight>
		<getTextWidth public="1" set="method"><f a=""><c path="Float"/></f></getTextWidth>
	</class>
	<class path="guise.platform.types.ITextInputAccess" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<inputEnabled public="1" set="set_inputEnabled"><e path="Bool"/></inputEnabled>
		<textChanged public="1" get="get_textChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></textChanged>
		<getText public="1" set="method"><f a=""><c path="String"/></f></getText>
	</class>
	<class path="guise.platform.nme.input.TextAccess" params="" file="../src/guise/platform/nme/input/TextAccess.hx">
		<implements path="guise.platform.types.ITextOutputAccess"/>
		<implements path="guise.platform.types.ITextInputAccess"/>
		<wrapInAlign set="method" line="190"><f a="align:text">
	<e path="guise.platform.types.Align"/>
	<c path="String"/>
	<c path="String"/>
</f></wrapInAlign>
		<wrapInFormat set="method" line="157"><f a="style:inner">
	<e path="guise.platform.types.TextStyle"/>
	<c path="String"/>
	<c path="String"/>
</f></wrapInFormat>
		<createHtml set="method" line="143"><f a="runs:isHtml">
	<c path="Array"><e path="guise.platform.types.TextRunData"/></c>
	<e path="Bool"/>
	<c path="String"/>
</f></createHtml>
		<setText public="1" set="method" line="103"><f a="run:isHtml">
	<c path="guise.platform.types.TextRun"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setText>
		<getText public="1" set="method" line="100"><f a=""><c path="String"/></f></getText>
		<get_focusedChanged set="method" line="93"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></f></get_focusedChanged>
		<focusedChanged public="1" get="get_focusedChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></focusedChanged>
		<focused public="1" set="null"><e path="Bool"/></focused>
		<get_textChanged set="method" line="85"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></f></get_textChanged>
		<textChanged public="1" get="get_textChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></textChanged>
		<onFocusOut set="method" line="79"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusOut>
		<onFocusIn set="method" line="75"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusIn>
		<onChange set="method" line="71"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onChange>
		<set_selectable set="method" line="65"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_selectable>
		<selectable public="1" set="set_selectable"><e path="Bool"/></selectable>
		<set_inputEnabled set="method" line="58"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_inputEnabled>
		<inputEnabled public="1" set="set_inputEnabled"><e path="Bool"/></inputEnabled>
		<setAntiAliasing public="1" set="method" line="33"><f a="type">
	<e path="guise.platform.types.AntiAliasType"/>
	<e path="Void"/>
</f></setAntiAliasing>
		<getTextHeight public="1" set="method" line="30"><f a=""><c path="Float"/></f></getTextHeight>
		<getTextWidth public="1" set="method" line="27"><f a=""><c path="Float"/></f></getTextWidth>
		<_ignoreChanges><e path="Bool"/></_ignoreChanges>
		<_textField><t path="nme.text.TextField"/></_textField>
		<new public="1" set="method" line="20"><f a="textField">
	<t path="nme.text.TextField"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<typedef path="guise.platform.nme.input.NmeAA" params="" file="../src/guise/platform/nme/input/TextAccess.hx" module="guise.platform.nme.input.TextAccess"><t path="nme.text.AntiAliasType"/></typedef>
	<typedef path="guise.platform.nme.input.NmeTextFormat" params="" file="../src/guise/platform/nme/input/TextAccess.hx" module="guise.platform.nme.input.TextAccess"><t path="nme.text.TextFormat"/></typedef>
	<class path="guise.platform.types.CoreAccessTypes" params="" file="../src/guise/platform/types/CoreAccessTypes.hx"><haxe_doc>* @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.DisplayAccessTypes" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.IScreenInfo" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<availHeight public="1" set="null"><c path="Int"/></availHeight>
		<availWidth public="1" set="null"><c path="Int"/></availWidth>
		<availSizeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.IScreenInfo"/></c></availSizeChanged>
	</class>
	<enum path="guise.platform.types.FilterType" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes">
		<Glow a="size:color:alpha:?inner">
			<c path="Float"/>
			<c path="Int"/>
			<c path="Float"/>
			<e path="Bool"/>
		</Glow>
		<DropShadow a="distance:angle:size:color:alpha:?inner">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Int"/>
			<c path="Float"/>
			<e path="Bool"/>
		</DropShadow>
	</enum>
	<class path="guise.platform.types.DrawingAccessTypes" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx"><haxe_doc>* @author Tom Byrne</haxe_doc></class>
	<enum path="guise.platform.types.GradientType" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<Radial a="?focalPointRatio"><c path="Float"/></Radial>
		<Linear/>
	</enum>
	<enum path="guise.platform.types.SpreadMethod" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<Repeat/>
		<Reflect/>
		<Pad/>
	</enum>
	<enum path="guise.platform.types.InterpolationMethod" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<Rgb/>
		<LinearRgb/>
	</enum>
	<enum path="guise.platform.types.JointStyle" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<JoRound/>
		<JoMiter a="limit"><c path="Float"/></JoMiter>
		<JoBevel/>
	</enum>
	<enum path="guise.platform.types.CapsStyle" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<CsSquare/>
		<CsRound/>
		<CsNone/>
	</enum>
	<class path="guise.platform.types.InteractionAccessTypes" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx"><haxe_doc>* @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.MouseInfo" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<mouseY public="1"><c path="Float"/></mouseY>
		<mouseX public="1"><c path="Float"/></mouseX>
		<new public="1" set="method" line="26"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="guise.platform.types.ClickInfo" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<shiftHeld public="1"><e path="Bool"/></shiftHeld>
		<ctrlHeld public="1"><e path="Bool"/></ctrlHeld>
		<altHeld public="1"><e path="Bool"/></altHeld>
		<left public="1"><e path="Bool"/></left>
		<new public="1" set="method" line="43"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="guise.platform.types.KeyInfo" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<Key a="keyCode:?modKeys">
			<c path="Int"/>
			<c path="Array"><e path="guise.platform.types.ModKeys"/></c>
		</Key>
		<Char a="charCode:?modKeys">
			<c path="Int"/>
			<c path="Array"><e path="guise.platform.types.ModKeys"/></c>
		</Char>
	</enum>
	<enum path="guise.platform.types.ModKeys" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<Shift/>
		<Ctrl/>
		<Alt/>
	</enum>
	<class path="guise.platform.types.TextAccessTypes" params="" file="../src/guise/platform/types/TextAccessTypes.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.TextRun" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<addData public="1" set="method" line="40"><f a="data">
	<e path="guise.platform.types.TextRunData"/>
	<e path="Void"/>
</f></addData>
		<runs public="1"><c path="Array"><e path="guise.platform.types.TextRunData"/></c></runs>
		<style public="1"><e path="guise.platform.types.TextStyle"/></style>
		<new public="1" set="method" line="36"><f a="style:runs">
	<e path="guise.platform.types.TextStyle"/>
	<c path="Array"><e path="guise.platform.types.TextRunData"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="guise.platform.types.TextRunData" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<Text a="text"><c path="String"/></Text>
		<Run a="runs"><c path="guise.platform.types.TextRun"/></Run>
	</enum>
	<enum path="guise.platform.types.AntiAliasType" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<AaSmooth/>
		<AaPixel/>
		<Aa a="sharpness:thickness">
			<c path="Float"/>
			<c path="Float"/>
		</Aa>
	</enum>
	<enum path="guise.platform.types.TextStyle" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes"><Trs a="font:size:color:?mods:?align">
	<t path="Null"><e path="guise.platform.types.Typeface"/></t>
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Int"/></t>
	<c path="Array"><e path="guise.platform.types.TextModifier"/></c>
	<e path="guise.platform.types.Align"/>
</Trs></enum>
	<enum path="guise.platform.types.TextModifier" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<TmUnderline a="?underline"><e path="Bool"/></TmUnderline>
		<TmStrikeThru a="?strikethrough"><e path="Bool"/></TmStrikeThru>
		<TmItalic a="?italic"><e path="Bool"/></TmItalic>
		<TmBold a="?bold"><e path="Bool"/></TmBold>
	</enum>
	<enum path="guise.platform.types.Typeface" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<TfTypewriter/>
		<TfSerif/>
		<TfSans/>
		<Tf a="name"><c path="String"/></Tf>
	</enum>
	<enum path="guise.platform.types.Align" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<Right/>
		<Left/>
		<Justify/>
		<Center/>
	</enum>
	<class path="guise.traits.core.IActive" params="" file="../src/guise/traits/core/IActive.hx" interface="1">
		<set public="1" set="method"><f a="active:explicit">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<explicit public="1" set="null"><e path="Bool"/></explicit>
		<active public="1" set="null"><e path="Bool"/></active>
		<activeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IActive"/></c></activeChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.core.CascadingActive" params="" file="../src/guise/traits/core/CascadingActive.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<implements path="guise.traits.core.IActive"/>
		<onChildRemoved set="method" line="63"><f a="child">
	<c path="guise.traits.core.IActive"/>
	<e path="Void"/>
</f></onChildRemoved>
		<onChildAdded set="method" line="53"><f a="child">
	<c path="guise.traits.core.IActive"/>
	<e path="Void"/>
</f></onChildAdded>
		<set public="1" set="method" line="38"><f a="active:explicit">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<_children><c path="haxe.FastList_guise_traits_core_IActive"/></_children>
		<cascade public="1"><e path="Bool"/></cascade>
		<explicit public="1" set="null"><e path="Bool"/></explicit>
		<active public="1" set="null"><e path="Bool"/></active>
		<activeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IActive"/></c></activeChanged>
		<new public="1" set="method" line="26"><f a="?active:?explicit:?cascade">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.traits.core.IPosition" params="" file="../src/guise/traits/core/IPosition.hx" interface="1">
		<set public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<y public="1" set="null"><c path="Float"/></y>
		<x public="1" set="null"><c path="Float"/></x>
		<posChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IPosition"/></c></posChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.core.ISize" params="" file="../src/guise/traits/core/ISize.hx" interface="1">
		<set public="1" set="method"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<height public="1" set="null"><c path="Float"/></height>
		<width public="1" set="null"><c path="Float"/></width>
		<sizeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.ISize"/></c></sizeChanged>
	</class>
	<class path="guise.traits.core.Position" params="" file="../src/guise/traits/core/Position.hx">
		<implements path="guise.traits.core.IPosition"/>
		<set public="1" set="method" line="22"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<y public="1" set="null"><c path="Float"/></y>
		<x public="1" set="null"><c path="Float"/></x>
		<posChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IPosition"/></c></posChanged>
		<new public="1" set="method" line="16"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.core.Size" params="" file="../src/guise/traits/core/Size.hx">
		<implements path="guise.traits.core.ISize"/>
		<set public="1" set="method" line="21"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<height public="1" set="null"><c path="Float"/></height>
		<width public="1" set="null"><c path="Float"/></width>
		<sizeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.ISize"/></c></sizeChanged>
		<new public="1" set="method" line="15"><f a="?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.traits.states.ControlStates" params="" file="../src/guise/traits/states/ControlStates.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<enum path="guise.traits.states.ControlActiveState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<INACTIVE/>
		<ACTIVE/>
	</enum>
	<enum path="guise.traits.states.ButtonOverState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<OVER/>
		<OUT/>
	</enum>
	<enum path="guise.traits.states.ButtonDownState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UP/>
		<DOWN/>
	</enum>
	<enum path="guise.traits.states.SelectedState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UNSELECTED/>
		<SELECTED/>
	</enum>
	<enum path="guise.traits.states.SelectableState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UNSELECTABLE/>
		<SELECTABLE/>
	</enum>
	<enum path="guise.traits.states.FocusState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UNFOCUSED/>
		<FOCUSED/>
	</enum>
	<class path="guise.traits.states.IState" params="StateEnum" file="../src/guise/traits/states/IState.hx" interface="1">
		<set public="1" set="method"><f a="current">
	<c path="guise.traits.states.IState.StateEnum"/>
	<e path="Void"/>
</f></set>
		<options public="1" set="null"><c path="Array"><c path="guise.traits.states.IState.StateEnum"/></c></options>
		<current public="1" set="null"><c path="guise.traits.states.IState.StateEnum"/></current>
		<stateChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.states.IState"><c path="guise.traits.states.IState.StateEnum"/></c></c></stateChanged>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.states.State" params="StateEnum" file="../src/guise/traits/states/State.hx">
		<implements path="guise.traits.states.IState"><c path="guise.traits.states.State.StateEnum"/></implements>
		<set public="1" set="method" line="22"><f a="current">
	<c path="guise.traits.states.State.StateEnum"/>
	<e path="Void"/>
</f></set>
		<options public="1" set="null"><c path="Array"><c path="guise.traits.states.State.StateEnum"/></c></options>
		<current public="1" set="null"><c path="guise.traits.states.State.StateEnum"/></current>
		<stateChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.states.IState"><c path="guise.traits.states.State.StateEnum"/></c></c></stateChanged>
		<new public="1" set="method" line="16"><f a="?current">
	<c path="guise.traits.states.State.StateEnum"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.states.StateStyledTrait" params="StyleType" file="../src/guise/traits/states/StateStyledTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<_drawStyle set="method" line="192"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="188"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<drawStyle set="dynamic" line="184"><f a=""><e path="Void"/></f></drawStyle>
		<isReadyToDraw set="dynamic" line="180">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Overriding dynamic functions disallows calling the 
	 * super version of the function. By using the _methods
	 * you can super call like normal.</haxe_doc>
		</isReadyToDraw>
		<getStateKey set="method" line="170"><f a="state">
	<c path="EnumValue"/>
	<c path="String"/>
</f></getStateKey>
		<attemptDrawStyle set="method" line="164"><f a=""><e path="Void"/></f></attemptDrawStyle>
		<invalidate public="1" set="method" line="160"><f a=""><e path="Void"/></f></invalidate>
		<sortStyles set="method" line="151"><f a="style1:style2">
	<a>
		<style><c path="guise.traits.states.StateStyledTrait.StyleType"/></style>
		<states><c path="Array"><c path="String"/></c></states>
		<priority><c path="Int"/></priority>
	</a>
	<a>
		<style><c path="guise.traits.states.StateStyledTrait.StyleType"/></style>
		<states><c path="Array"><c path="String"/></c></states>
		<priority><c path="Int"/></priority>
	</a>
	<c path="Int"/>
</f></sortStyles>
		<findDestStyle set="method" line="121"><f a=""><c path="guise.traits.states.StateStyledTrait.StyleType"/></f></findDestStyle>
		<finishTrans set="method" line="115"><f a="finish">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<e path="Void"/>
</f></finishTrans>
		<updateTrans set="method" line="111"><f a="current">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<e path="Void"/>
</f></updateTrans>
		<assessStyle set="method" line="84"><f a=""><e path="Void"/></f></assessStyle>
		<removeStyle public="1" set="method" line="76"><f a="style">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<e path="Void"/>
</f></removeStyle>
		<addStyle public="1" set="method" line="65"><f a="states:style:?priority">
	<c path="Array"><c path="EnumValue"/></c>
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addStyle>
		<onStateChanged set="method" line="61"><f a="state">
	<c path="guise.traits.states.IState"><c path="EnumValue"/></c>
	<e path="Void"/>
</f></onStateChanged>
		<removeState public="1" set="method" line="56">
			<f a="state">
				<c path="guise.traits.states.IState"><c path="EnumValue"/></c>
				<e path="Void"/>
			</f>
			<meta><m n="injectRemove"/></meta>
		</removeState>
		<addState public="1" set="method" line="48">
			<f a="state">
				<c path="guise.traits.states.IState"><c path="EnumValue"/></c>
				<e path="Void"/>
			</f>
			<meta><m n="injectAdd"/></meta>
		</addState>
		<transSubject><d/></transSubject>
		<states><c path="Array"><c path="guise.traits.states.IState"><c path="EnumValue"/></c></c></states>
		<styles><c path="Array"><a>
	<style><c path="guise.traits.states.StateStyledTrait.StyleType"/></style>
	<states><c path="Array"><c path="String"/></c></states>
	<priority><c path="Int"/></priority>
</a></c></styles>
		<destStyle public="1" set="null"><c path="guise.traits.states.StateStyledTrait.StyleType"/></destStyle>
		<previousStyle public="1" set="null"><c path="guise.traits.states.StateStyledTrait.StyleType"/></previousStyle>
		<currentStyle public="1" set="null"><c path="guise.traits.states.StateStyledTrait.StyleType"/></currentStyle>
		<currentTrans><c path="guiseSkins.trans.ITransTracker"/></currentTrans>
		<set_normalStyle set="method" line="21"><f a="value">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
</f></set_normalStyle>
		<normalStyle public="1" set="set_normalStyle"><c path="guise.traits.states.StateStyledTrait.StyleType"/></normalStyle>
		<styleTransitioner public="1"><c path="guiseSkins.trans.ITransitioner"/></styleTransitioner>
		<injStyleTransitioner public="1">
			<c path="guiseSkins.trans.ITransitioner"/>
			<meta><m n="inject"><e>{asc:true}</e></m></meta>
		</injStyleTransitioner>
		<new public="1" set="method" line="38"><f a="?normalStyle:?isReadyToDraw:?drawStyle:?transSubject">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<f a=""><e path="Bool"/></f>
	<f a=""><e path="Void"/></f>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guise.traits.tags.ControlTags" params="" file="../src/guise/traits/tags/ControlTags.hx">
		<TextLabelTag/>
		<TextInputTag/>
		<TextButtonTag/>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</enum>
	<enum path="guise.traits.tags.CoreTags" params="" file="../src/guise/traits/tags/CoreTags.hx">
		<WindowTag/>
		<StageTag/>
		<CursorTag/>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</enum>
	<class path="guise.utils.Clone" params="" file="../src/guise/utils/Clone.hx">
		<clone public="1" params="T" set="method" line="10" static="1"><f a="object">
	<c path="clone.T"/>
	<c path="clone.T"/>
</f></clone>
		<cloneInline public="1" params="T" get="inline" set="null" line="13" static="1"><f a="item">
	<c path="cloneInline.T"/>
	<c path="cloneInline.T"/>
</f></cloneInline>
		<cloneEnum public="1" params="T" set="method" line="29" static="1"><f a="enumVal:?paramMask">
	<c path="cloneEnum.T"/>
	<c path="Array"><d/></c>
	<c path="cloneEnum.T"/>
</f></cloneEnum>
		<cloneObject public="1" params="T" get="inline" set="null" line="48" static="1"><f a="item">
	<c path="cloneObject.T"/>
	<c path="cloneObject.T"/>
</f></cloneObject>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<enum path="guise.utils.MaskValues" params="" file="../src/guise/utils/Clone.hx" module="guise.utils.Clone"><CLONE/></enum>
	<class path="guise.utils.Closures" params="" file="../src/guise/utils/Closures.hx">
		<eq public="1" set="method" line="10" static="1"><f a="val1:val2">
	<d/>
	<d/>
	<e path="Bool"/>
</f></eq>
		<ineq public="1" set="method" line="11" static="1"><f a="val1:val2">
	<d/>
	<d/>
	<e path="Bool"/>
</f></ineq>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.utils.TitleCase" params="" file="../src/guise/utils/TitleCase.hx">
		<toTitleCase public="1" set="method" line="11" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></toTitleCase>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.AbsStyledLayer" params="StyleType" file="../src/guiseSkins/styled/AbsStyledLayer.hx">
		<extends path="guise.traits.states.StateStyledTrait"><c path="guiseSkins.styled.AbsStyledLayer.StyleType"/></extends>
		<implements path="guise.layout.IPositionable"/>
		<setPosition public="1" set="method" line="31"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<h public="1"><c path="Float"/></h>
		<w public="1"><c path="Float"/></w>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<_requireSize><e path="Bool"/></_requireSize>
		<_requirePos><e path="Bool"/></_requirePos>
		<_isReadyToDraw set="method" line="20" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<new public="1" set="method" line="15"><f a="?normalStyle">
	<c path="guiseSkins.styled.AbsStyledLayer.StyleType"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guiseSkins.styled.BoxLayer" params="" file="../src/guiseSkins/styled/BoxLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><e path="guiseSkins.styled.BoxStyle"/></extends>
		<SQUARE_CORNER static="1"><e path="guiseSkins.styled.CornerStyle"/></SQUARE_CORNER>
		<CAPSULE_CORNER static="1"><e path="guiseSkins.styled.CornerStyle"/></CAPSULE_CORNER>
		<drawArc set="method" line="204"><f a="graphics:x:y:radius:angle:startAngle:isInitial:?accuracy">
	<c path="guise.platform.types.IGraphics"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawArc>
		<drawCorner set="method" line="178"><f a="cs:flipH:flipV:angle:isInitial:width:height:cX:cY">
	<e path="guiseSkins.styled.CornerStyle"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCorner>
		<createBoxMatrix set="method" line="172"><f a="rotation:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="guise.geom.Matrix"/>
</f></createBoxMatrix>
		<collectFills set="method" line="158"><f a="fill:fills">
	<e path="guiseSkins.styled.FillStyle"/>
	<c path="Array"><e path="guiseSkins.styled.FillStyle"/></c>
	<e path="Void"/>
</f></collectFills>
		<_drawStyle set="method" line="36" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="33" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<onGraphicsRemove set="method" line="29"><f a="access">
	<c path="guise.platform.types.IGraphics"/>
	<e path="Void"/>
</f></onGraphicsRemove>
		<onGraphicsAdd set="method" line="25"><f a="access">
	<c path="guise.platform.types.IGraphics"/>
	<e path="Void"/>
</f></onGraphicsAdd>
		<_graphics><c path="guise.platform.types.IGraphics"/></_graphics>
		<new public="1" set="method" line="18"><f a="?layerName:?normalStyle">
	<c path="String"/>
	<e path="guiseSkins.styled.BoxStyle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guiseSkins.styled.BoxStyle" params="" file="../src/guiseSkins/styled/BoxLayer.hx" module="guiseSkins.styled.BoxLayer">
		<BsRectComplex a="f:s:c:?extraW:?extraH">
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guiseSkins.styled.StrokeStyle"/>
			<e path="guiseSkins.styled.Corners"/>
			<c path="Float"/>
			<c path="Float"/>
		</BsRectComplex>
		<BsRect a="f:s:?extraW:?extraH">
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guiseSkins.styled.StrokeStyle"/>
			<c path="Float"/>
			<c path="Float"/>
		</BsRect>
		<BsCapsule a="f:s:?extraW:?extraH">
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guiseSkins.styled.StrokeStyle"/>
			<c path="Float"/>
			<c path="Float"/>
		</BsCapsule>
	</enum>
	<enum path="guiseSkins.styled.Corners" params="" file="../src/guiseSkins/styled/BoxLayer.hx" module="guiseSkins.styled.BoxLayer">
		<CSame a="cs"><e path="guiseSkins.styled.CornerStyle"/></CSame>
		<CDiff a="tl:tr:br:bl">
			<e path="guiseSkins.styled.CornerStyle"/>
			<e path="guiseSkins.styled.CornerStyle"/>
			<e path="guiseSkins.styled.CornerStyle"/>
			<e path="guiseSkins.styled.CornerStyle"/>
		</CDiff>
	</enum>
	<enum path="guiseSkins.styled.CornerStyle" params="" file="../src/guiseSkins/styled/BoxLayer.hx" module="guiseSkins.styled.BoxLayer">
		<CsSquare/>
		<CsCirc a="r"><c path="Float"/></CsCirc>
	</enum>
	<class path="guiseSkins.trans.ITransitioner" params="" file="../src/guiseSkins/trans/ITransitioner.hx" interface="1">
		<doTrans public="1" set="method"><f a="from:to:subject:?prop:?update:?finish">
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<c path="guiseSkins.trans.ITransTracker"/>
</f></doTrans>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.StyleTransitioner" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx">
		<implements path="guiseSkins.trans.ITransitioner"/>
		<ease public="1" set="method" line="283" static="1"><f a="paramsTypes">
	<c path="Array"><e path="guiseSkins.trans.SwitchParamType"/></c>
	<t path="guiseSkins.trans.EnumValSwitchFact"/>
</f></ease>
		<goVia public="1" set="method" line="288" static="1"><f a="paramsTypes">
	<c path="Array"><e path="guiseSkins.trans.SwitchParamType"/></c>
	<t path="guiseSkins.trans.EnumValSwitchFact"/>
</f></goVia>
		<createSwitchInfo set="method" line="302" static="1"><f a="paramsTypes:direction:style1:style1Match:style2:style2Match">
	<c path="Array"><e path="guiseSkins.trans.SwitchParamType"/></c>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<t path="guiseSkins.trans.SwitchSpanInfo"/>
</f></createSwitchInfo>
		<transFinished set="method" line="355"><f a="from">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<e path="Void"/>
</f></transFinished>
		<findEaserFact set="method" line="342"><f a="enumVal:paramIndex">
	<d/>
	<c path="Int"/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
</f></findEaserFact>
		<doSwitch2 set="method" line="273"><f a="bundle:span:via:viaParams:destParams:easerFuncs">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<d/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><t path="guiseSkins.trans.EaserFactFunc"/></c>
	<e path="Void"/>
</f></doSwitch2>
		<doSwitch set="method" line="236"><f a="bundle:span:switchInfoList:style1Match:style2Match:direction:parent:prop">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
	<d/>
	<d/>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
</f></doSwitch>
		<addEnumEaser set="method" line="230"><f a="span:parent:prop:enumVal:params">
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<d/>
	<c path="String"/>
	<d/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></addEnumEaser>
		<enumConstMatch set="method" line="227"><f a="enum1:enum2">
	<c path="EnumValue"/>
	<c path="EnumValue"/>
	<e path="Bool"/>
</f></enumConstMatch>
		<checkSpan set="method" line="85"><f a="bundle:span:parent:prop:from:dest:?easerFact">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
	<d/>
</f></checkSpan>
		<findTransStyle set="method" line="82"><f a="from:to:subject:prop">
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="guiseSkins.trans.TransStyle"/>
</f></findTransStyle>
		<doTrans public="1" set="method" line="39"><f a="from:to:subject:?prop:?update:?finish">
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
</f></doTrans>
		<addPropEaser public="1" set="method" line="32"><f a="styleType:paramIndex:propEaserFact">
	<d/>
	<c path="Int"/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
	<e path="Void"/>
</f></addPropEaser>
		<addStyleSwitch public="1" set="method" line="25"><f a="styleSwitch">
	<e path="guiseSkins.trans.StyleSwitch"/>
	<e path="Void"/>
</f></addStyleSwitch>
		<propEasers><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.PropEaserInfo"/></c></propEasers>
		<styleSwitches><c path="Array"><e path="guiseSkins.trans.StyleSwitch"/></c></styleSwitches>
		<normalTransStyle public="1"><c path="guiseSkins.trans.TransStyle"/></normalTransStyle>
		<new public="1" set="method" line="20"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.DefaultStyleTrans" params="" file="../src/guiseSkins/styled/DefaultStyleTrans.hx">
		<extends path="guiseSkins.trans.StyleTransitioner"/>
		<checkCapsultToRoundedRect set="method" line="185"><f a="style1:params1:style2:params2">
	<e path="guiseSkins.styled.BoxStyle"/>
	<c path="Array"><d/></c>
	<e path="guiseSkins.styled.BoxStyle"/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></checkCapsultToRoundedRect>
		<easeCapsuleToRoundedRect set="method" line="148"><f a="subject:direction:style1:style1Match:style2:style2Match">
	<d/>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></easeCapsuleToRoundedRect>
		<setGradPointOpacity set="method" line="134"><f a="gp:to:onlyIfNull">
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setGradPointOpacity>
		<setFillOpacity set="method" line="114"><f a="fill:to:onlyIfNull">
	<e path="guiseSkins.styled.FillStyle"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setFillOpacity>
		<easeFillToFill set="method" line="106"><f a="subject:direction:enum1:style1Match:enum2:style2Match">
	<d/>
	<e path="Bool"/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></easeFillToFill>
		<checkFillToFill set="method" line="83"><f a="style1:params1:style2:params2">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></checkFillToFill>
		<easeFillToDiffFill set="method" line="50"><f a="subject:direction:enum1:style1Match:enum2:style2Match">
	<d/>
	<e path="Bool"/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></easeFillToDiffFill>
		<checkFillToDiffFill set="method" line="35"><f a="style1:params1:style2:params2">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></checkFillToDiffFill>
		<new public="1" set="method" line="22"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.IPropEaser" params="" file="../src/guiseSkins/trans/IPropEaser.hx" interface="1">
		<update public="1" set="method"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method"><f a=""><e path="Void"/></f></release>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.GradientEaser" params="" file="../src/guiseSkins/styled/DefaultStyleTrans.hx" module="guiseSkins.styled.DefaultStyleTrans">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.styled.GradientEaser"/></c></_pool>
		<getNew public="1" set="method" line="213" static="1"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<c path="guiseSkins.styled.GradientEaser"/>
</f></getNew>
		<update public="1" set="method" line="251"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="246"><f a=""><e path="Void"/></f></release>
		<colDiff public="1"><c path="Array"><a>
	<r><c path="Int"/></r>
	<g><c path="Int"/></g>
	<fract><c path="Float"/></fract>
	<b><c path="Int"/></b>
	<a><c path="Float"/></a>
</a></c></colDiff>
		<colStart public="1"><c path="Array"><a>
	<r><c path="Int"/></r>
	<g><c path="Int"/></g>
	<fract><c path="Float"/></fract>
	<b><c path="Int"/></b>
	<a><c path="Float"/></a>
</a></c></colStart>
		<curr public="1"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></curr>
		<inited public="1"><e path="Bool"/></inited>
		<end public="1"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></end>
		<start public="1"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></start>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="239"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guiseSkins.styled.FilterLayer" params="" file="../src/guiseSkins/styled/FilterLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><c path="Array"><e path="guise.platform.types.FilterType"/></c></extends>
		<_drawStyle set="method" line="27" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<onFilterableRemove set="method" line="23"><f a="access">
	<c path="guise.platform.types.IFilterableAccess"/>
	<e path="Void"/>
</f></onFilterableRemove>
		<onFilterableAdd set="method" line="19"><f a="access">
	<c path="guise.platform.types.IFilterableAccess"/>
	<e path="Void"/>
</f></onFilterableAdd>
		<_filterable><c path="guise.platform.types.IFilterableAccess"/></_filterable>
		<new public="1" set="method" line="13"><f a="?layerName:?normalStyle">
	<c path="String"/>
	<c path="Array"><e path="guise.platform.types.FilterType"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guiseSkins.styled.FramingLayer" params="" file="../src/guiseSkins/styled/FramingLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><e path="guiseSkins.styled.FramingStyle"/></extends>
		<_drawStyle set="method" line="49" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="45" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<onMeasChanged set="method" line="42"><f a="from">
	<c path="guise.platform.types.ISizableDisplayAccess"/>
	<e path="Void"/>
</f></onMeasChanged>
		<onSizableRemove set="method" line="37"><f a="access">
	<c path="guise.platform.types.ISizableDisplayAccess"/>
	<e path="Void"/>
</f></onSizableRemove>
		<onSizableAdd set="method" line="30"><f a="access">
	<c path="guise.platform.types.ISizableDisplayAccess"/>
	<e path="Void"/>
</f></onSizableAdd>
		<_expSize><c path="guise.traits.core.Size"/></_expSize>
		<_expPos><c path="guise.traits.core.Position"/></_expPos>
		<_sizableDisplay><c path="guise.platform.types.ISizableDisplayAccess"/></_sizableDisplay>
		<new public="1" set="method" line="20"><f a="layerName:?normalStyle">
	<c path="String"/>
	<e path="guiseSkins.styled.FramingStyle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guiseSkins.styled.FramingStyle" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer"><Frame a="fitMode:?hScale:?vScale:?marginTop:?marginLeft:?marginBottom:?marginRight">
	<e path="guiseSkins.styled.FrameMode"/>
	<e path="guiseSkins.styled.ScaleMode"/>
	<e path="guiseSkins.styled.ScaleMode"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</Frame></enum>
	<enum path="guiseSkins.styled.FrameMode" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer">
		<Fill/>
		<ConstrainMin/>
		<ConstrainMax/>
	</enum>
	<enum path="guiseSkins.styled.ScaleMode" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer">
		<ScaleUpOnly a="?align"><e path="guiseSkins.styled.Align"/></ScaleUpOnly>
		<ScaleNever a="?align"><e path="guiseSkins.styled.Align"/></ScaleNever>
		<ScaleDownOnly a="?align"><e path="guiseSkins.styled.Align"/></ScaleDownOnly>
		<ScaleAlways/>
	</enum>
	<enum path="guiseSkins.styled.Align" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer">
		<AlignMid/>
		<AlignFore/>
		<AlignAft/>
	</enum>
	<class path="guiseSkins.styled.Styles" params="" file="../src/guiseSkins/styled/Styles.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<typedef path="guiseSkins.styled.GradPoint" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><c path="Float"/></a>
</a></typedef>
	<enum path="guiseSkins.styled.FillStyle" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<FsVLinearGradient a="gp"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></FsVLinearGradient>
		<FsTransparent/>
		<FsSolid a="c:?a">
			<c path="Int"/>
			<c path="Float"/>
		</FsSolid>
		<FsRadialGradient a="gp:?mat:?focalPointRatio">
			<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
			<t path="guise.geom.Matrix"/>
			<c path="Float"/>
		</FsRadialGradient>
		<FsNone/>
		<FsMulti a="fs"><c path="Array"><e path="guiseSkins.styled.FillStyle"/></c></FsMulti>
		<FsLinearGradient a="gp:?mat">
			<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
			<t path="guise.geom.Matrix"/>
		</FsLinearGradient>
		<FsHLinearGradient a="gp"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></FsHLinearGradient>
	</enum>
	<enum path="guiseSkins.styled.StrokeStyle" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<SsSolid a="th:fill:?joints">
			<c path="Float"/>
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guise.platform.types.JointStyle"/>
		</SsSolid>
		<SsNone/>
	</enum>
	<enum path="guiseSkins.styled.HAlign" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<Right/>
		<Left/>
		<Center/>
	</enum>
	<enum path="guiseSkins.styled.VAlign" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<Top/>
		<Middle/>
		<Bottom/>
	</enum>
	<class path="guiseSkins.styled.TextStyleLayer" params="" file="../src/guiseSkins/styled/TextStyleLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><e path="guiseSkins.styled.TextLabelStyle"/></extends>
		<onTextChanged set="method" line="80"><f a="from">
	<c path="guise.controls.data.ITextLabel"/>
	<e path="Void"/>
</f></onTextChanged>
		<toCase set="method" line="68"><f a="str:textCase">
	<c path="String"/>
	<e path="guiseSkins.styled.TextCase"/>
	<c path="String"/>
</f></toCase>
		<_drawStyle set="method" line="58" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="54" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<onTextRemove set="method" line="51"><f a="access">
	<c path="guise.platform.types.ITextOutputAccess"/>
	<e path="Void"/>
</f></onTextRemove>
		<onTextAdd set="method" line="47"><f a="access">
	<c path="guise.platform.types.ITextOutputAccess"/>
	<e path="Void"/>
</f></onTextAdd>
		<_textSize><c path="guise.traits.core.Size"/></_textSize>
		<_textPos><c path="guise.traits.core.Position"/></_textPos>
		<_textDisplay><c path="guise.platform.types.ITextOutputAccess"/></_textDisplay>
		<set_textLabel set="method" line="21"><f a="value">
	<c path="guise.controls.data.ITextLabel"/>
	<c path="guise.controls.data.ITextLabel"/>
</f></set_textLabel>
		<textLabel public="1" set="set_textLabel">
			<c path="guise.controls.data.ITextLabel"/>
			<meta><m n="inject"/></meta>
		</textLabel>
		<new public="1" set="method" line="37"><f a="layerName:?normalStyle">
	<c path="String"/>
	<e path="guiseSkins.styled.TextLabelStyle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guiseSkins.styled.TextLabelStyle" params="" file="../src/guiseSkins/styled/TextStyleLayer.hx" module="guiseSkins.styled.TextStyleLayer"><Tls a="ts:selectable:?tc:?antiAliasing">
	<e path="guise.platform.types.TextStyle"/>
	<e path="Bool"/>
	<e path="guiseSkins.styled.TextCase"/>
	<e path="guise.platform.types.AntiAliasType"/>
</Tls></enum>
	<enum path="guiseSkins.styled.TextCase" params="" file="../src/guiseSkins/styled/TextStyleLayer.hx" module="guiseSkins.styled.TextStyleLayer">
		<TcUpper/>
		<TcTitle/>
		<TcNormal/>
		<TcLower/>
	</enum>
	<class path="guiseSkins.styled.styles.ChutzpahStyle" params="" file="../src/guiseSkins/styled/styles/ChutzpahStyle.hx">
		<_labelTextStyle static="1"><e path="guiseSkins.styled.TextLabelStyle"/></_labelTextStyle>
		<_inputTextStyle static="1"><e path="guiseSkins.styled.TextLabelStyle"/></_inputTextStyle>
		<_labelTextAlign static="1"><e path="guiseSkins.styled.FramingStyle"/></_labelTextAlign>
		<_inputTextAlign static="1"><e path="guiseSkins.styled.FramingStyle"/></_inputTextAlign>
		<_buttonTextFiltNorm static="1"><c path="Array"><e path="guise.platform.types.FilterType"/></c></_buttonTextFiltNorm>
		<_buttonBackNorm static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackNorm>
		<_buttonBackOver static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackOver>
		<_buttonBackDownUnsel static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackDownUnsel>
		<_buttonBackSelNorm static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackSelNorm>
		<_buttonBackSelOver static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackSelOver>
		<_inputBackNorm static="1"><e path="guiseSkins.styled.BoxStyle"/></_inputBackNorm>
		<_inputBackFocus static="1"><e path="guiseSkins.styled.BoxStyle"/></_inputBackFocus>
		<_buttonFiltNorm static="1"><c path="Array"><e path="guise.platform.types.FilterType"/></c></_buttonFiltNorm>
		<_buttonFiltDown static="1"><c path="Array"><e path="guise.platform.types.FilterType"/></c></_buttonFiltDown>
		<_styleTransitioner static="1"><c path="guiseSkins.styled.DefaultStyleTrans"/></_styleTransitioner>
		<install public="1" set="method" line="47" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<buttonBacking set="method" line="96" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.BoxLayer"/>
</f></buttonBacking>
		<labelText set="method" line="105" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.TextStyleLayer"/>
</f></labelText>
		<inputText set="method" line="108" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.TextStyleLayer"/>
</f></inputText>
		<textFilt set="method" line="111" static="1"><f a="layerName">
	<c path="String"/>
	<f a="">
		<d/>
		<c path="guiseSkins.styled.FilterLayer"/>
	</f>
</f></textFilt>
		<buttonFilter set="method" line="118" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FilterLayer"/>
</f></buttonFilter>
		<inputTextAlign set="method" line="125" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FramingLayer"/>
</f></inputTextAlign>
		<labelTextAlign set="method" line="128" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FramingLayer"/>
</f></labelTextAlign>
		<inputBacking set="method" line="132" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.BoxLayer"/>
</f></inputBacking>
		<inputFilter set="method" line="138" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FilterLayer"/>
</f></inputFilter>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.styles.NormalLayering" params="" file="../src/guiseSkins/styled/styles/NormalLayering.hx">
		<install public="1" set="method" line="16" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.ColorEaser" params="" file="../src/guiseSkins/trans/ColorEaser.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.ColorEaser"/></c></_pool>
		<getNew public="1" set="method" line="11" static="1"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="guiseSkins.trans.ColorEaser"/>
</f></getNew>
		<update public="1" set="method" line="53"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="48"><f a=""><e path="Void"/></f></release>
		<diffB public="1"><c path="Int"/></diffB>
		<diffG public="1"><c path="Int"/></diffG>
		<diffR public="1"><c path="Int"/></diffR>
		<startB public="1"><c path="Int"/></startB>
		<startG public="1"><c path="Int"/></startG>
		<startR public="1"><c path="Int"/></startR>
		<inited public="1"><e path="Bool"/></inited>
		<end public="1"><c path="Int"/></end>
		<start public="1"><c path="Int"/></start>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="42"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.EnumEaser" params="" file="../src/guiseSkins/trans/EnumEaser.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.EnumEaser"/></c></_pool>
		<getNew public="1" set="method" line="11" static="1"><f a="enumVal:params:parent:prop">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="String"/>
	<c path="guiseSkins.trans.EnumEaser"/>
</f></getNew>
		<update public="1" set="method" line="50"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="44"><f a=""><e path="Void"/></f></release>
		<enumConst><c path="String"/></enumConst>
		<enumType><c path="Enum"><d/></c></enumType>
		<inited><e path="Bool"/></inited>
		<prop public="1"><c path="String"/></prop>
		<parent public="1"><d/></parent>
		<params public="1"><c path="Array"><d/></c></params>
		<enumVal public="1"><d/></enumVal>
		<new public="1" set="method" line="36"><f a="enumVal:params:parent:prop">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.ITransTracker" params="" file="../src/guiseSkins/trans/ITransitioner.hx" module="guiseSkins.trans.ITransitioner" interface="1">
		<stopTrans public="1" set="method"><f a="gotoEnd">
	<e path="Bool"/>
	<e path="Void"/>
</f></stopTrans>
		<setFinishHandler public="1" set="method"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setFinishHandler>
		<setUpdateHandler public="1" set="method"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setUpdateHandler>
	</class>
	<class path="guiseSkins.trans.PropEaser" params="" file="../src/guiseSkins/trans/PropEaser.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.PropEaser"/></c></_pool>
		<getNew public="1" set="method" line="10" static="1"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="guiseSkins.trans.PropEaser"/>
</f></getNew>
		<update public="1" set="method" line="46"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="41"><f a=""><e path="Void"/></f></release>
		<diff public="1"><c path="Float"/></diff>
		<inited public="1"><e path="Bool"/></inited>
		<end public="1"><c path="Float"/></end>
		<start public="1"><c path="Float"/></start>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="34"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.PropSetter" params="" file="../src/guiseSkins/trans/PropSetter.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.PropSetter"/></c></_pool>
		<getNew public="1" set="method" line="11" static="1"><f a="subject:prop:value">
	<d/>
	<d/>
	<d/>
	<c path="guiseSkins.trans.PropSetter"/>
</f></getNew>
		<update public="1" set="method" line="40"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="35"><f a=""><e path="Void"/></f></release>
		<value public="1"><d/></value>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="30"><f a="subject:prop:value">
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<enum path="guiseSkins.trans.Easing" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner">
		<EaseOut/>
		<EaseInOut/>
		<EaseIn/>
	</enum>
	<class path="guiseSkins.trans._StyleTransitioner.TransTracker" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" private="1" module="guiseSkins.trans.StyleTransitioner">
		<implements path="guiseSkins.trans.ITransTracker"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.TransTracker"/></c></_pool>
		<getNew public="1" set="method" line="368" static="1"><f a="stopHandler">
	<f a="">
		<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
		<e path="Void"/>
	</f>
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
</f></getNew>
		<onComplete set="method" line="473"><f a=""><e path="Void"/></f></onComplete>
		<onUpdate set="method" line="470"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></onUpdate>
		<tweenFract public="1" set="method" line="461"><f a="to:time:easing">
	<c path="Float"/>
	<c path="Float"/>
	<t path="Null"><t path="feffects.Easing"/></t>
	<e path="Void"/>
</f></tweenFract>
		<set_fract set="method" line="438"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_fract>
		<fract public="1" set="set_fract"><c path="Float"/></fract>
		<setFinishHandler public="1" set="method" line="433"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setFinishHandler>
		<setUpdateHandler public="1" set="method" line="430"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setUpdateHandler>
		<stopTrans public="1" set="method" line="420"><f a="gotoEnd">
	<e path="Bool"/>
	<e path="Void"/>
</f></stopTrans>
		<_tween><c path="feffects.Tween"/></_tween>
		<transSpans public="1"><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.TransSpan"/></c></transSpans>
		<transStyle public="1"><c path="guiseSkins.trans.TransStyle"/></transStyle>
		<subject public="1"><d/></subject>
		<curr public="1"><d/></curr>
		<from public="1"><d/></from>
		<to public="1"><d/></to>
		<stopHandler><f a="">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<e path="Void"/>
</f></stopHandler>
		<finish public="1" set="dynamic" line="400"><f a="curr">
	<d/>
	<e path="Void"/>
</f></finish>
		<update public="1" set="dynamic" line="399"><f a="curr">
	<d/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="380"><f a=""><e path="Void"/></f></release>
		<new public="1" set="method" line="416"><f a="stopHandler">
	<f a="">
		<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guiseSkins.trans._StyleTransitioner.TransSpan" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" private="1" module="guiseSkins.trans.StyleTransitioner">
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.TransSpan"/></c></_pool>
		<getNew public="1" set="method" line="479" static="1"><f a=""><c path="guiseSkins.trans._StyleTransitioner.TransSpan"/></f></getNew>
		<easeProps public="1"><c path="Array"><c path="guiseSkins.trans.IPropEaser"/></c></easeProps>
		<length public="1"><c path="Float"/></length>
		<start public="1"><c path="Float"/></start>
		<release public="1" set="method" line="489"><f a=""><e path="Void"/></f></release>
		<new public="1" set="method" line="504"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="guiseSkins.trans._StyleTransitioner.PropEaserInfo" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" private="1" module="guiseSkins.trans.StyleTransitioner">
		<propEaserFact public="1"><t path="guiseSkins.trans.EaserFactFunc"/></propEaserFact>
		<paramIndex public="1"><c path="Int"/></paramIndex>
		<styleType public="1"><d/></styleType>
		<new public="1" set="method" line="511"><f a="styleType:paramIndex:propEaserFact">
	<d/>
	<c path="Int"/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="guiseSkins.trans.EaserFactFunc" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::">
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="guiseSkins.trans.IPropEaser"/>
</f></typedef>
	<typedef path="guiseSkins.trans.SwitchCheck" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></typedef>
	<typedef path="guiseSkins.trans.SwitchSpanInfo" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><a>
	<via><d/></via>
	<toParams><c path="Array"><d/></c></toParams>
	<easerFuncs><c path="Array"><t path="guiseSkins.trans.EaserFactFunc"/></c></easerFuncs>
</a></typedef>
	<typedef path="guiseSkins.trans.EnumValSwitchFact" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::::">
	<d/>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></typedef>
	<typedef path="guiseSkins.trans.EnumSwitchFact" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::::">
	<d/>
	<e path="Bool"/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></typedef>
	<enum path="guiseSkins.trans.StyleSwitch" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner">
		<EnumValueSwitch a="switchFact:enumVal1:enumVal2:?check">
			<t path="guiseSkins.trans.EnumValSwitchFact"/>
			<d/>
			<d/>
			<t path="guiseSkins.trans.SwitchCheck"/>
		</EnumValueSwitch>
		<EnumTypeSwitch a="switchFact:enum1:enum2:?check">
			<t path="guiseSkins.trans.EnumSwitchFact"/>
			<c path="Enum"><d/></c>
			<c path="Enum"><d/></c>
			<t path="guiseSkins.trans.SwitchCheck"/>
		</EnumTypeSwitch>
	</enum>
	<enum path="guiseSkins.trans.SwitchParamType" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner">
		<UseStyle/>
		<SwitchEase a="?easerFact"><t path="guiseSkins.trans.EaserFactFunc"/></SwitchEase>
		<NormalEase a="?easerFact"><t path="guiseSkins.trans.EaserFactFunc"/></NormalEase>
	</enum>
	<class path="guiseSkins.trans.TransStyle" params="" file="../src/guiseSkins/trans/TransStyle.hx">
		<easing public="1"><e path="guiseSkins.trans.Easing"/></easing>
		<time public="1"><c path="Float"/></time>
		<new public="1" set="method" line="14"><f a="time:easing">
	<c path="Float"/>
	<e path="guiseSkins.trans.Easing"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.UtilFunctions" params="" file="../src/guiseSkins/trans/UtilFunctions.hx">
		<setProperty public="1" get="inline" set="null" line="10" static="1"><f a="subject:prop:value">
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></setProperty>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="haxe.FastCell_feffects_Tween" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<next public="1"><c path="haxe.FastCell_feffects_Tween"/></next>
		<elt public="1"><c path="feffects.Tween"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="feffects.Tween"/>
	<c path="haxe.FastCell_feffects_Tween"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastCell_guise_traits_core_IActive" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<next public="1"><c path="haxe.FastCell_guise_traits_core_IActive"/></next>
		<elt public="1"><c path="guise.traits.core.IActive"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="guise.traits.core.IActive"/>
	<c path="haxe.FastCell_guise_traits_core_IActive"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastCell" params="T" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx" module="haxe.FastList">
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe._FastList.FastListIterator" params="T" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx" private="1" module="haxe.FastList">
		<extends path="cpp.FastIterator"><c path="haxe._FastList.FastListIterator.T"/></extends>
		<next public="1" set="method" line="43" override="1"><f a=""><c path="haxe._FastList.FastListIterator.T"/></f></next>
		<hasNext public="1" set="method" line="42" override="1"><f a=""><e path="Bool"/></f></hasNext>
		<current public="1"><c path="haxe.FastCell"><c path="haxe._FastList.FastListIterator.T"/></c></current>
		<new public="1" set="method" line="45"><f a="head">
	<c path="haxe.FastCell"><c path="haxe._FastList.FastListIterator.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="129">
			<f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. A different class is created for each container used in platforms where it matters</haxe_doc>
	</class>
	<class path="haxe.FastList_guise_traits_core_IActive" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="129">
			<f a=""><t path="Iterator"><c path="guise.traits.core.IActive"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="guise.traits.core.IActive"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="guise.traits.core.IActive"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="guise.traits.core.IActive"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="guise.traits.core.IActive"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell_guise_traits_core_IActive"/></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
	</class>
	<class path="haxe.Int32" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/haxe/Int32.hx" extern="1">
		<make public="1" set="method" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" set="method" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" set="method" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<add public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<complement public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
		<isNeg public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isZero>
		<ucompare public="1" set="method" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></ucompare>
		<toNativeInt public="1" set="method" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<meta><m n=":native"><e>cpp.CppInt32__</e></m></meta>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\haxe\std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\haxe\std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Serializer" params="" file="C:\Motion-Twin\haxe\std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.
		This is less reliable but more compact.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="436" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serialize a single value and return the string.</haxe_doc>
		</run>
		<serializeException public="1" set="method" line="417"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<useCache public="1"><e path="Bool"/></useCache>
		<scount><c path="Int"/></scount>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<cache><c path="Array"><d/></c></cache>
		<buf><c path="StringBuf"/></buf>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.TimerList" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/haxe/Timer.hx" module="haxe.Timer"><c path="Array"><c path="haxe.Timer"/></c></typedef>
	<class path="neash.Loader" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/Loader.hx">
		<moduleInit line="15" static="1"><e path="Bool"/></moduleInit>
		<moduleName line="16" static="1"><c path="String"/></moduleName>
		<findHaxeLib public="1" set="method" line="30" static="1"><f a="inLib">
	<c path="String"/>
	<c path="String"/>
</f></findHaxeLib>
		<load public="1" set="method" line="63" static="1"><f a="func:args">
	<c path="String"/>
	<c path="Int"/>
	<d/>
</f></load>
		<loaderTrace public="1" set="method" line="125" static="1"><f a="inStr">
	<c path="String"/>
	<e path="Void"/>
</f></loaderTrace>
		<sysName set="method" line="140" static="1"><f a=""><a><substr set="null"><f a="">
	<c path="Int"/>
	<a><toLowerCase set="null"><f a=""><c path="String"/></f></toLowerCase></a>
</f></substr></a></f></sysName>
		<tryLoad public="1" set="method" line="152" static="1"><f a="inName:func:args">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<d/>
</f></tryLoad>
	</class>
	<class path="sys.io.Process" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/io/Process.hx">
		<_run line="126" static="1"><f a=":">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<unknown/>
</f></_run>
		<_exit line="127" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_exit>
		<_pid line="128" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></_pid>
		<_close line="129" static="1"><f a="">
	<d/>
	<unknown/>
</f></_close>
		<kill public="1" set="method" line="122"><f a=""><e path="Void"/></f></kill>
		<close public="1" set="method" line="118"><f a=""><e path="Void"/></f></close>
		<exitCode public="1" set="method" line="114"><f a=""><c path="Int"/></f></exitCode>
		<getPid public="1" set="method" line="110"><f a=""><c path="Int"/></f></getPid>
		<stdin public="1" set="null"><c path="haxe.io.Output"/></stdin>
		<stderr public="1" set="null"><c path="haxe.io.Input"/></stderr>
		<stdout public="1" set="null"><c path="haxe.io.Input"/></stdout>
		<p><d/></p>
		<new public="1" set="method" line="103"><f a="cmd:args">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></new>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="C:\Motion-Twin\haxe\std/haxe/io/Output.hx">
		<LN2 line="34" static="1"><c path="Float"/></LN2>
		<_float_bytes line="364" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="365" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<writeString public="1" set="method" line="348"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<writeInput public="1" set="method" line="326"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<prepare public="1" set="method" line="323">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInt32 public="1" set="method" line="303"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<writeUInt30 public="1" set="method" line="288"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt31 public="1" set="method" line="271"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt24 public="1" set="method" line="258"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt24 public="1" set="method" line="253"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt16 public="1" set="method" line="242"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt16 public="1" set="method" line="237"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeInt8 public="1" set="method" line="231"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeDouble public="1" set="method" line="154"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="100"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeFullBytes public="1" set="method" line="92"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<write public="1" set="method" line="81"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<setEndian set="method" line="74"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="71"><f a=""><e path="Void"/></f></close>
		<flush public="1" set="method" line="68"><f a=""><e path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="45"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="41"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<class path="sys.io._Process.Stdin" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Output"/>
		<_stdin_write line="56" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></_stdin_write>
		<_stdin_close line="57" static="1"><f a="">
	<d/>
	<unknown/>
</f></_stdin_close>
		<writeBytes public="1" set="method" line="47" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="42" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<close public="1" set="method" line="37" override="1"><f a=""><e path="Void"/></f></close>
		<buf><c path="haxe.io.Bytes"/></buf>
		<p><d/></p>
		<new public="1" set="method" line="32"><f a="p">
	<unknown/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Motion-Twin\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="259" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="291" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="340" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<getData public="1" get="inline" set="null" line="255"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="241"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="218"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="168"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="130"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="103"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="71"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="53"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><c path="Int"/></length>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Input" params="" file="C:\Motion-Twin\haxe\std/haxe/io/Input.hx">
		<_float_of_bytes line="425" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="426" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_double_of_bytes>
		<readString public="1" set="method" line="408"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<readInt32 public="1" set="method" line="393"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readUInt30 public="1" set="method" line="384"><f a=""><c path="Int"/></f></readUInt30>
		<readInt31 public="1" set="method" line="367"><f a=""><c path="Int"/></f></readInt31>
		<readUInt24 public="1" set="method" line="360"><f a=""><c path="Int"/></f></readUInt24>
		<readInt24 public="1" set="method" line="350"><f a=""><c path="Int"/></f></readInt24>
		<readUInt16 public="1" set="method" line="344"><f a=""><c path="Int"/></f></readUInt16>
		<readInt16 public="1" set="method" line="335"><f a=""><c path="Int"/></f></readInt16>
		<readInt8 public="1" set="method" line="328"><f a=""><c path="Int"/></f></readInt8>
		<readDouble public="1" set="method" line="255"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="201"><f a=""><c path="Float"/></f></readFloat>
		<readLine public="1" set="method" line="184"><f a=""><c path="String"/></f></readLine>
		<readUntil public="1" set="method" line="176"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<read public="1" set="method" line="164"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readFullBytes public="1" set="method" line="156"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<readAll public="1" set="method" line="80"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<setEndian set="method" line="73"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="70"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="49"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="40"><f a=""><c path="Int"/></f></readByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="sys.io._Process.Stdout" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/io/Process.hx" private="1" module="sys.io.Process">
		<extends path="haxe.io.Input"/>
		<_stdout_read line="90" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></_stdout_read>
		<_stderr_read line="91" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></_stderr_read>
		<readBytes public="1" set="method" line="79" override="1"><f a="str:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="73" override="1"><f a=""><c path="Int"/></f></readByte>
		<buf><c path="haxe.io.Bytes"/></buf>
		<out><e path="Bool"/></out>
		<p><d/></p>
		<new public="1" set="method" line="67"><f a="p:out">
	<unknown/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Timer" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/haxe/Timer.hx">
		<sRunningTimers line="106" static="1"><t path="haxe.TimerList"/></sRunningTimers>
		<measure public="1" params="T" set="method" line="123" static="1"><f a="f:?pos">
	<f a=""><c path="measure.T"/></f>
	<t path="haxe.PosInfos"/>
	<c path="measure.T"/>
</f></measure>
		<nmeNextWake public="1" set="method" line="154" static="1">
			<f a="limit">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</nmeNextWake>
		<nmeCheckTimers public="1" set="method" line="196" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* @private</haxe_doc>
		</nmeCheckTimers>
		<GetMS set="method" line="209" static="1"><f a=""><c path="Float"/></f></GetMS>
		<delay public="1" set="method" line="217" static="1"><f a="f:time">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="haxe.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="231" static="1"><f a=""><c path="Float"/></f></stamp>
		<nme_time_stamp line="238" static="1"><f a=""><c path="Float"/></f></nme_time_stamp>
		<nmeCheck set="method" line="181"><f a="inTime">
	<c path="Float"/>
	<e path="Void"/>
</f></nmeCheck>
		<stop public="1" set="method" line="139"><f a=""><e path="Void"/></f></stop>
		<run public="1" set="dynamic" line="132"><f a=""><e path="Void"/></f></run>
		<mRunning><e path="Bool"/></mRunning>
		<mFireAt><c path="Float"/></mFireAt>
		<mTime><c path="Float"/></mTime>
		<new public="1" set="method" line="113"><f a="time">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="C:\Motion-Twin\haxe\std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="haxe.Unserializer" params="" file="C:\Motion-Twin\haxe\std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="Array"><c path="Int"/></c></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="Array"><c path="Int"/></c></f></initCodes>
		<run public="1" set="method" line="351" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserialize a single value and return it.</haxe_doc>
		</run>
		<unserialize public="1" set="method" line="151"><f a=""><d/></f></unserialize>
		<unserializeEnum set="method" line="139"><f a="edecl:tag">
	<c path="Enum"><unknown/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserializeObject set="method" line="124"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<readDigits set="method" line="99"><f a=""><c path="Int"/></f></readDigits>
		<get get="inline" set="null" line="95"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<getResolver public="1" set="method" line="91"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<setResolver public="1" set="method" line="81"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<scache><c path="Array"><c path="String"/></c></scache>
		<cache><c path="Array"><d/></c></cache>
		<length><c path="Int"/></length>
		<pos><c path="Int"/></pos>
		<buf><c path="String"/></buf>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe._FastList.FastListIterator_feffects_Tween" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<extends path="cpp.FastIterator_feffects_Tween"/>
		<next public="1" set="method" line="43" override="1"><f a=""><c path="feffects.Tween"/></f></next>
		<hasNext public="1" set="method" line="42" override="1"><f a=""><e path="Bool"/></f></hasNext>
		<current public="1"><c path="haxe.FastCell_feffects_Tween"/></current>
		<new public="1" set="method" line="45"><f a="head">
	<c path="haxe.FastCell_feffects_Tween"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe._FastList.FastListIterator_guise_traits_core_IActive" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<extends path="cpp.FastIterator_guise_traits_core_IActive"/>
		<next public="1" set="method" line="43" override="1"><f a=""><c path="guise.traits.core.IActive"/></f></next>
		<hasNext public="1" set="method" line="42" override="1"><f a=""><e path="Bool"/></f></hasNext>
		<current public="1"><c path="haxe.FastCell_guise_traits_core_IActive"/></current>
		<new public="1" set="method" line="45"><f a="head">
	<c path="haxe.FastCell_guise_traits_core_IActive"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\Motion-Twin\haxe\std/haxe/io/BytesBuffer.hx">
		<getBytes public="1" set="method" line="126">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<addBytes public="1" get="inline" set="null" line="100"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<add public="1" get="inline" set="null" line="81"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addByte public="1" get="inline" set="null" line="63"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<b><t path="haxe.io.BytesData"/></b>
		<new public="1" set="method" line="45"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Unsigned_char__" params="" file="C:\Motion-Twin\haxe\std/haxe/io/BytesData.hx" module="haxe.io.BytesData" extern="1"/>
	<typedef path="haxe.io.BytesData" params="" file="C:\Motion-Twin\haxe\std/haxe/io/BytesData.hx"><c path="Array"><c path="haxe.io.Unsigned_char__"/></c></typedef>
	<class path="haxe.io.Eof" params="" file="C:\Motion-Twin\haxe\std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="C:\Motion-Twin\haxe\std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<typedef path="haxe.macro.Position" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><c path="Int"/></min>
	<max><c path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CType a="s"><c path="String"/></CType>
		<CString a="s"><c path="String"/></CString>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
		<CInt a="v"><c path="String"/></CInt>
		<CIdent a="s"><c path="String"/></CIdent>
		<CFloat a="f"><c path="String"/></CFloat>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpXor/>
		<OpUShr/>
		<OpSub/>
		<OpShr/>
		<OpShl/>
		<OpOr/>
		<OpNotEq/>
		<OpMult/>
		<OpMod/>
		<OpLte/>
		<OpLt/>
		<OpInterval/>
		<OpGte/>
		<OpGt/>
		<OpEq/>
		<OpDiv/>
		<OpBoolOr/>
		<OpBoolAnd/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpAssign/>
		<OpAnd/>
		<OpAdd/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpNot/>
		<OpNegBits/>
		<OpNeg/>
		<OpIncrement/>
		<OpDecrement/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprRequire" params="T" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EWhile>
		<EVars a="vars"><c path="Array"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></c></EVars>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<e path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EType a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EType>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
		</ETry>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</ESwitch>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EDisplay>
		<EContinue/>
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
		</ECheckType>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<EBreak/>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TOptional a="t"><e path="haxe.macro.ComplexType"/></TOptional>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.Function" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<c path="Array"><e path="haxe.macro.Access"/></c>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<AStatic/>
		<APublic/>
		<APrivate/>
		<AOverride/>
		<AInline/>
		<ADynamic/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FProp a="get:set:t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><e path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDStructure/>
		<TDEnum/>
		<TDClass a="?extend:?implement:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<e path="Bool"/>
		</TDClass>
	</enum>
	<class path="haxe.macro.Error" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<message public="1"><c path="String"/></message>
		<new public="1" set="method" line="213"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>This error can be used to handle or produce compilation errors in macros.</haxe_doc>
	</class>
	<typedef path="haxe.macro.Ref" params="T" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<enum path="haxe.macro.Type" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx">
		<TType a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.DefType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TType>
		<TMono a="t"><t path="haxe.macro.Ref"><t path="Null"><e path="haxe.macro.Type"/></t></t></TMono>
		<TLazy a="f"><f a=""><e path="haxe.macro.Type"/></f></TLazy>
		<TInst a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TInst>
		<TFun a="args:ret">
			<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="haxe.macro.Type"/>
		</TFun>
		<TEnum a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.EnumType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TEnum>
		<TDynamic a="t"><t path="Null"><e path="haxe.macro.Type"/></t></TDynamic>
		<TAnonymous a="a"><t path="haxe.macro.Ref"><t path="haxe.macro.AnonType"/></t></TAnonymous>
	</enum>
	<typedef path="haxe.macro.AnonType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a><fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields></a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><e path="Bool"/></isPublic>
	<expr set="method"><f a=""><t path="Null"><e path="haxe.macro.TypedExpr"/></t></f></expr>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<enum path="haxe.macro.ClassKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<KTypeParameter/>
		<KNormal/>
		<KMacroType/>
		<KGenericInstance a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KGenericInstance>
		<KGeneric/>
		<KExtension a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KExtension>
		<KExpr a="expr"><t path="haxe.macro.Expr"/></KExpr>
	</enum>
	<typedef path="haxe.macro.ClassType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.ClassKind"/></kind>
	<isPrivate><e path="Bool"/></isPrivate>
	<isInterface><e path="Bool"/></isInterface>
	<isExtern><e path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><e path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><c path="Int"/></index>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructs><c path="Hash"><t path="haxe.macro.EnumField"/></c></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<remove set="method"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
	<has set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></has>
	<get set="method"><f a=""><t path="haxe.macro.Metadata"/></f></get>
	<add set="method"><f a="name:params:pos">
	<c path="String"/>
	<c path="Array"><t path="haxe.macro.Expr"/></c>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></add>
</a></typedef>
	<enum path="haxe.macro.FieldKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<FVar a="read:write">
			<e path="haxe.macro.VarAccess"/>
			<e path="haxe.macro.VarAccess"/>
		</FVar>
		<FMethod a="k"><e path="haxe.macro.MethodKind"/></FMethod>
	</enum>
	<enum path="haxe.macro.VarAccess" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<AccResolve/>
		<AccRequire a="r"><c path="String"/></AccRequire>
		<AccNormal/>
		<AccNo/>
		<AccNever/>
		<AccInline/>
		<AccCall a="m"><c path="String"/></AccCall>
	</enum>
	<enum path="haxe.macro.MethodKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<MethNormal/>
		<MethMacro/>
		<MethInline/>
		<MethDynamic/>
	</enum>
	<enum path="haxe.macro.TypedExpr" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"/>
	<typedef path="msignal.AnySignal" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal"><c path="msignal.Signal">
	<d/>
	<d/>
</c></typedef>
	<class path="msignal.Signal" params="TSlot:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx">
		<get_numListeners set="method" line="167"><f a=""><c path="Int"/></f></get_numListeners>
		<createSlot set="method" line="162">
			<f a="listener:?once:?priority">
				<c path="msignal.Signal.TListener"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<meta><m n="IgnoreCover"/></meta>
		</createSlot>
		<registrationPossible set="method" line="144"><f a="listener:once">
	<c path="msignal.Signal.TListener"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></registrationPossible>
		<registerListener set="method" line="128"><f a="listener:?once:?priority">
	<c path="msignal.Signal.TListener"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Signal.TSlot"/>
</f></registerListener>
		<removeAll public="1" set="method" line="123">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Unsubscribes all listeners from the signal.</haxe_doc>
		</removeAll>
		<remove public="1" set="method" line="111">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Unsubscribes a listener from the signal.
	
	@param listener The listener to remove
	@return The removed listener slot</haxe_doc>
		</remove>
		<addOnceWithPriority public="1" set="method" line="100">
			<f a="listener:?priority">
				<c path="msignal.Signal.TListener"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a one-time listener for this signal.
	The signal will remove the listener automatically the first time it is called,
	after the dispatch to all listeners is complete.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addOnceWithPriority>
		<addWithPriority public="1" set="method" line="87">
			<f a="listener:?priority">
				<c path="msignal.Signal.TListener"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a listener for the signal.
	After you successfully register an event listener,
	you cannot change its priority through additional calls to add().
	To change a listener's priority, you must first call remove().
	Then you can register the listener again with the new priority level.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addWithPriority>
		<addOnce public="1" set="method" line="72">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a one-time listener for this signal.
	The signal will remove the listener automatically the first time it is called,
	after the dispatch to all listeners is complete.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addOnce>
		<add public="1" set="method" line="59">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a listener for the signal.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</add>
		<priorityBased><e path="Bool"/></priorityBased>
		<slots><c path="msignal.SlotList">
	<c path="msignal.Signal.TSlot"/>
	<c path="msignal.Signal.TListener"/>
</c></slots>
		<numListeners public="1" get="get_numListeners" set="null">
			<c path="Int"/>
			<haxe_doc>The current number of listeners for the signal.</haxe_doc>
		</numListeners>
		<valueClasses public="1"><c path="Array"><d/></c></valueClasses>
		<new set="method" line="45"><f a="?valueClasses">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>A Signal manages a list of listeners, which are executed when the signal is 
dispatched.</haxe_doc>
	</class>
	<class path="msignal.Signal0" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot0"/>
			<f a=""><e path="Void"/></f>
		</extends>
		<createSlot set="method" line="197" override="1"><f a="listener:?once:?priority">
	<f a=""><e path="Void"/></f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot0"/>
</f></createSlot>
		<dispatch public="1" set="method" line="186">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Executes the signals listeners with no arguements.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="178"><f a=""><e path="Void"/></f></new>
		<haxe_doc>Signal that executes listeners with no arguments.</haxe_doc>
	</class>
	<class path="msignal.Signal1" params="TValue" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
			<f a="">
				<c path="msignal.Signal1.TValue"/>
				<e path="Void"/>
			</f>
		</extends>
		<createSlot set="method" line="227" override="1"><f a="listener:?once:?priority">
	<f a="">
		<c path="msignal.Signal1.TValue"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
</f></createSlot>
		<dispatch public="1" set="method" line="216">
			<f a="value">
				<c path="msignal.Signal1.TValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Executes the signals listeners with one arguement.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="208"><f a="?type">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Signal that executes listeners with one arguments.</haxe_doc>
	</class>
	<class path="msignal.Signal2" params="TValue1:TValue2" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot2">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
			</c>
			<f a=":">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
				<e path="Void"/>
			</f>
		</extends>
		<createSlot set="method" line="257" override="1"><f a="listener:?once:?priority">
	<f a=":">
		<c path="msignal.Signal2.TValue1"/>
		<c path="msignal.Signal2.TValue2"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot2">
		<c path="msignal.Signal2.TValue1"/>
		<c path="msignal.Signal2.TValue2"/>
	</c>
</f></createSlot>
		<dispatch public="1" set="method" line="246">
			<f a="value1:value2">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Executes the signals listeners with two arguements.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="238"><f a="?type1:?type2">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Signal that executes listeners with two arguments.</haxe_doc>
	</class>
	<typedef path="msignal.AnySlot" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot"><c path="msignal.Slot">
	<d/>
	<d/>
</c></typedef>
	<class path="msignal.Slot" params="TSignal:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx">
		<set_listener set="method" line="91"><f a="value">
	<c path="msignal.Slot.TListener"/>
	<c path="msignal.Slot.TListener"/>
</f></set_listener>
		<get_listener set="method" line="85">
			<f a=""><c path="msignal.Slot.TListener"/></f>
			<haxe_doc>Hxcpp 2.10 requires a getter method for a typed function property in order to compile</haxe_doc>
		</get_listener>
		<remove public="1" set="method" line="76">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Removes the slot from its signal.</haxe_doc>
		</remove>
		<signal><c path="msignal.Slot.TSignal"/></signal>
		<enabled public="1">
			<e path="Bool"/>
			<haxe_doc>Whether the listener is called on execution. Defaults to true.</haxe_doc>
		</enabled>
		<priority public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The priority of this slot should be given in the execution order.
	An Signal will call higher numbers before lower ones.
	Defaults to 0.</haxe_doc>
		</priority>
		<once public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>Whether this slot is automatically removed after it has been used once.</haxe_doc>
		</once>
		<listener public="1" get="get_listener" set="set_listener">
			<c path="msignal.Slot.TListener"/>
			<haxe_doc>The listener associated with this slot.
	Note: for hxcpp 2.10 this requires a getter method to compile</haxe_doc>
		</listener>
		<new set="method" line="64"><f a="signal:listener:?once:?priority">
	<c path="msignal.Slot.TSignal"/>
	<c path="msignal.Slot.TListener"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Defines the basic properties of a listener associated with a Signal.</haxe_doc>
	</class>
	<class path="msignal.Slot0" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal0"/>
			<f a=""><e path="Void"/></f>
		</extends>
		<execute public="1" set="method" line="111">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Executes a listener with no arguments.</haxe_doc>
		</execute>
		<new public="1" set="method" line="103"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal0"/>
	<f a=""><e path="Void"/></f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with no arguments.</haxe_doc>
	</class>
	<class path="msignal.Slot1" params="TValue" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
			<f a="">
				<c path="msignal.Slot1.TValue"/>
				<e path="Void"/>
			</f>
		</extends>
		<execute public="1" set="method" line="138">
			<f a="value1">
				<c path="msignal.Slot1.TValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Executes a listener with one argument.
	If <code>param</code> is not null, it overrides the value provided.]]></haxe_doc>
		</execute>
		<param public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the argument to dispatch.</haxe_doc>
		</param>
		<new public="1" set="method" line="129"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
	<f a="">
		<c path="msignal.Slot1.TValue"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with one argument.</haxe_doc>
	</class>
	<class path="msignal.Slot2" params="TValue1:TValue2" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal2">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
			</c>
			<f a=":">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
				<e path="Void"/>
			</f>
		</extends>
		<execute public="1" set="method" line="172">
			<f a="value1:value2">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Executes a listener with two arguments.
	If <code>param1</code> or <code>param2</code> is set, 
	they override the values provided.]]></haxe_doc>
		</execute>
		<param2 public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the second argument to dispatch.</haxe_doc>
		</param2>
		<param1 public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the first argument to dispatch.</haxe_doc>
		</param1>
		<new public="1" set="method" line="162"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal2">
		<c path="msignal.Slot2.TValue1"/>
		<c path="msignal.Slot2.TValue2"/>
	</c>
	<f a=":">
		<c path="msignal.Slot2.TValue1"/>
		<c path="msignal.Slot2.TValue2"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with two arguments.</haxe_doc>
	</class>
	<class path="msignal.SlotList" params="TSlot:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/SlotList.hx">
		<NIL public="1" static="1">
			<c path="msignal.SlotList">
				<d/>
				<d/>
			</c>
			<haxe_doc>Represents an empty list. Used as the list terminator.</haxe_doc>
		</NIL>
		<find public="1" set="method" line="240">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList.TSlot"/>
			</f>
			<haxe_doc>Retrieves the Slot associated with a supplied listener within the SlotList.
	@param   listener The Function being searched for
	@return  The ISlot in this list associated with the listener parameter through the ISlot.listener property.
			 Returns null if no such ISlot instance exists or the list is empty.</haxe_doc>
		</find>
		<contains public="1" set="method" line="220">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Determines whether the supplied listener Function is contained within this list</haxe_doc>
		</contains>
		<filterNot public="1" set="method" line="189">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Returns the slots in this list that do not contain the supplied listener.
	Note: assumes the listener is not repeated within the list.
	@param	listener The function to remove.
	@return A list consisting of all elements of this list that do not have listener.</haxe_doc>
		</filterNot>
		<insertWithPriority public="1" set="method" line="152"><f a="slot">
	<c path="msignal.SlotList.TSlot"/>
	<c path="msignal.SlotList">
		<c path="msignal.SlotList.TSlot"/>
		<c path="msignal.SlotList.TListener"/>
	</c>
</f></insertWithPriority>
		<append public="1" set="method" line="118">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Appends a slot to this list.
	Note: appending is O(n). Where possible, prepend which is O(1).
	In some cases, many list items must be cloned to 
	avoid changing existing lists.
	@param	slot The item to be appended.
	@return	A list consisting of all elements of this list followed by slot.</haxe_doc>
		</append>
		<prepend public="1" set="method" line="105">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Prepends a slot to this list.
	@param	slot The item to be prepended.
	@return	A list consisting of slot followed by all elements of this list.</haxe_doc>
		</prepend>
		<get_length set="method" line="79"><f a=""><c path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<c path="Int"/>
			<haxe_doc>The number of slots in the list.</haxe_doc>
		</length>
		<nonEmpty public="1"><e path="Bool"/></nonEmpty>
		<tail public="1"><c path="msignal.SlotList">
	<c path="msignal.SlotList.TSlot"/>
	<c path="msignal.SlotList.TListener"/>
</c></tail>
		<head public="1"><c path="msignal.SlotList.TSlot"/></head>
		<new public="1" set="method" line="49">
			<f a="head:?tail">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Creates and returns a new SlotList object.
	 *
	<p>A user never has to create a SlotList manually. 
	Use the <code>NIL</code> element to represent an empty list. 
	<code>NIL.prepend(value)</code> would create a list containing <code>value</code></p>.
	 *
	@param head The first slot in the list.
	@param tail A list containing all slots except head.]]></haxe_doc>
		</new>
	</class>
	<class path="neash.Lib" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/Lib.hx">
		<FULLSCREEN public="1" line="23" static="1"><c path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="24" static="1"><c path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="25" static="1"><c path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="26" static="1"><c path="Int"/></HARDWARE>
		<VSYNC public="1" line="27" static="1"><c path="Int"/></VSYNC>
		<HW_AA public="1" line="28" static="1"><c path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="29" static="1"><c path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="30" static="1"><c path="Int"/></ALLOW_SHADERS>
		<current public="1" get="nmeGetCurrent" set="null" static="1"><c path="neash.display.MovieClip"/></current>
		<initHeight public="1" set="null" static="1"><c path="Int"/></initHeight>
		<initWidth public="1" set="null" static="1"><c path="Int"/></initWidth>
		<stage public="1" get="nmeGetStage" set="null" static="1"><c path="neash.display.Stage"/></stage>
		<nmeCurrent line="37" static="1"><c path="neash.display.MovieClip"/></nmeCurrent>
		<nmeMainFrame line="38" static="1"><d/></nmeMainFrame>
		<nmeStage line="39" static="1"><c path="neash.display.Stage"/></nmeStage>
		<sIsInit line="40" static="1"><e path="Bool"/></sIsInit>
		<company public="1" set="null" static="1"><c path="String"/></company>
		<version public="1" set="null" static="1"><c path="String"/></version>
		<packageName public="1" set="null" static="1"><c path="String"/></packageName>
		<file public="1" set="null" static="1"><c path="String"/></file>
		<close public="1" set="method" line="47" static="1"><f a=""><e path="Void"/></f></close>
		<create public="1" set="method" line="54" static="1"><f a="inOnLoaded:inWidth:inHeight:?inFrameRate:?inColour:?inFlags:?inTitle:?inIcon">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<c path="neash.display.BitmapData"/>
	<e path="Void"/>
</f></create>
		<createManagedStage public="1" set="method" line="82" static="1"><f a="inWidth:inHeight:?inFlags">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="neash.display.ManagedStage"/>
</f></createManagedStage>
		<exit public="1" set="method" line="92" static="1"><f a=""><e path="Void"/></f></exit>
		<forceClose public="1" set="method" line="108" static="1"><f a=""><e path="Void"/></f></forceClose>
		<getTimer public="1" set="method" line="116" static="1"><f a=""><c path="Int"/></f></getTimer>
		<getURL public="1" set="method" line="123" static="1"><f a="url:?target">
	<c path="neash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<nmeSetCurrentStage public="1" set="method" line="132" static="1">
			<f a="inStage">
				<c path="neash.display.Stage"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</nmeSetCurrentStage>
		<pause public="1" set="method" line="138" static="1"><f a=""><e path="Void"/></f></pause>
		<postUICallback public="1" set="method" line="144" static="1"><f a="inCallback">
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></postUICallback>
		<resume public="1" set="method" line="156" static="1"><f a=""><e path="Void"/></f></resume>
		<setIcon public="1" set="method" line="169" static="1"><f a="path">
	<c path="String"/>
	<e path="Void"/>
</f></setIcon>
		<setPackage public="1" set="method" line="176" static="1"><f a="inCompany:inFile:inPack:inVersion">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setPackage>
		<nmeGetCurrent set="method" line="188" static="1"><f a=""><c path="neash.display.MovieClip"/></f></nmeGetCurrent>
		<nmeGetStage set="method" line="200" static="1"><f a=""><c path="neash.display.Stage"/></f></nmeGetStage>
		<nme_set_package line="216" static="1"><f a=":::">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></nme_set_package>
		<nme_get_frame_stage line="217" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_get_frame_stage>
		<nme_get_url line="218" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></nme_get_url>
		<nme_pause_animation line="219" static="1"><f a=""><unknown/></f></nme_pause_animation>
		<nme_resume_animation line="220" static="1"><f a=""><unknown/></f></nme_resume_animation>
	</class>
	<class path="neash.display.IBitmapDrawable" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/IBitmapDrawable.hx" interface="1"><nmeDrawToSurface public="1" set="method">
	<f a="inSurface:matrix:colorTransform:blendMode:clipRect:smoothing">
		<d/>
		<c path="neash.geom.Matrix"/>
		<c path="neash.geom.ColorTransform"/>
		<c path="String"/>
		<c path="neash.geom.Rectangle"/>
		<e path="Bool"/>
		<e path="Void"/>
	</f>
	<haxe_doc>@private</haxe_doc>
</nmeDrawToSurface></class>
	<class path="neash.display.BitmapData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/BitmapData.hx">
		<implements path="neash.display.IBitmapDrawable"/>
		<CLEAR public="1" line="22" static="1"><c path="Int"/></CLEAR>
		<BLACK public="1" line="23" static="1"><t path="neash.display.BitmapInt32"/></BLACK>
		<WHITE public="1" line="24" static="1"><t path="neash.display.BitmapInt32"/></WHITE>
		<RED public="1" line="25" static="1"><t path="neash.display.BitmapInt32"/></RED>
		<GREEN public="1" line="26" static="1"><t path="neash.display.BitmapInt32"/></GREEN>
		<BLUE public="1" line="27" static="1"><t path="neash.display.BitmapInt32"/></BLUE>
		<PNG public="1" get="inline" set="null" line="28" static="1"><c path="String"/></PNG>
		<JPG public="1" get="inline" set="null" line="29" static="1"><c path="String"/></JPG>
		<TRANSPARENT public="1" line="31" static="1"><c path="Int"/></TRANSPARENT>
		<HARDWARE public="1" line="32" static="1"><c path="Int"/></HARDWARE>
		<FORMAT_8888 public="1" line="33" static="1"><c path="Int"/></FORMAT_8888>
		<FORMAT_4444 public="1" line="34" static="1"><c path="Int"/></FORMAT_4444>
		<FORMAT_565 public="1" line="35" static="1"><c path="Int"/></FORMAT_565>
		<createColor public="1" get="inline" set="null" line="171" static="1"><f a="inRGB:?inAlpha">
	<c path="Int"/>
	<c path="Int"/>
	<t path="neash.display.BitmapInt32"/>
</f></createColor>
		<extractAlpha public="1" get="inline" set="null" line="219" static="1"><f a="v">
	<t path="neash.display.BitmapInt32"/>
	<c path="Int"/>
</f></extractAlpha>
		<extractColor public="1" get="inline" set="null" line="229" static="1"><f a="v">
	<t path="neash.display.BitmapInt32"/>
	<c path="Int"/>
</f></extractColor>
		<load public="1" set="method" line="325" static="1">
			<f a="inFilename:?format">
				<c path="String"/>
				<c path="Int"/>
				<c path="neash.display.BitmapData"/>
			</f>
			<haxe_doc>* Load from a file path
	*
	* @param inFilename Full or relative path to image file
	* @return New BitmapData instance representing file</haxe_doc>
		</load>
		<loadFromBytes public="1" set="method" line="341" static="1">
			<f a="inBytes:?inRawAlpha">
				<c path="neash.utils.ByteArray"/>
				<c path="neash.utils.ByteArray"/>
				<c path="neash.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[* Create BitmapData from a compressed image stream.
	* PNG & JPG supported on all platforms.
	*
	* @param inBytes - A buffer of compressed image data
	* @param inAlpha - optional alpha values to go with image RGB values - there should
	*                   be width*height values.]]></haxe_doc>
		</loadFromBytes>
		<loadFromHaxeBytes public="1" set="method" line="357" static="1">
			<f a="inBytes:?inRawAlpha">
				<c path="haxe.io.Bytes"/>
				<c path="haxe.io.Bytes"/>
				<c path="neash.display.BitmapData"/>
			</f>
			<haxe_doc><![CDATA[* Create BitmapData from a compressed image stream.
	* PNG & JPG supported on all platforms.
	*
	* @param inBytes - A buffer of compressed image data
	* @param inAlpha - optional alpha values to go with image RGB values - there should
	*                   be width*height values.]]></haxe_doc>
		</loadFromHaxeBytes>
		<nme_bitmap_data_create line="467" static="1"><f a="::::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_create>
		<nme_bitmap_data_load line="468" static="1"><f a=":">
	<c path="String"/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_load>
		<nme_bitmap_data_from_bytes line="469" static="1"><f a=":">
	<c path="neash.utils.ByteArray"/>
	<c path="neash.utils.ByteArray"/>
	<unknown/>
</f></nme_bitmap_data_from_bytes>
		<nme_bitmap_data_clear line="470" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_clear>
		<nme_bitmap_data_clone line="471" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_bitmap_data_clone>
		<nme_bitmap_data_apply_filter line="472" static="1"><f a="::::">
	<d/>
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="neash.geom.Point"/>
	<c path="neash.filters.BitmapFilter"/>
	<unknown/>
</f></nme_bitmap_data_apply_filter>
		<nme_bitmap_data_color_transform line="473" static="1"><f a="::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="neash.geom.ColorTransform"/>
	<unknown/>
</f></nme_bitmap_data_color_transform>
		<nme_bitmap_data_copy line="474" static="1"><f a="::::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<d/>
	<c path="neash.geom.Point"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_bitmap_data_copy>
		<nme_bitmap_data_copy_channel line="475" static="1"><f a=":::::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<d/>
	<c path="neash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_copy_channel>
		<nme_bitmap_data_fill line="476" static="1"><f a=":::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_fill>
		<nme_bitmap_data_get_pixels line="477" static="1"><f a=":">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="neash.utils.ByteArray"/>
</f></nme_bitmap_data_get_pixels>
		<nme_bitmap_data_get_pixel line="478" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></nme_bitmap_data_get_pixel>
		<nme_bitmap_data_get_pixel32 line="479" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="neash.display.BitmapInt32"/>
</f></nme_bitmap_data_get_pixel32>
		<nme_bitmap_data_get_pixel_rgba line="480" static="1"><unknown/></nme_bitmap_data_get_pixel_rgba>
		<nme_bitmap_data_get_array line="482" static="1"><f a="::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="Array"><c path="Int"/></c>
	<unknown/>
</f></nme_bitmap_data_get_array>
		<nme_bitmap_data_get_color_bounds_rect line="484" static="1"><f a="::::">
	<d/>
	<t path="neash.display.BitmapInt32"/>
	<t path="neash.display.BitmapInt32"/>
	<e path="Bool"/>
	<c path="neash.geom.Rectangle"/>
	<unknown/>
</f></nme_bitmap_data_get_color_bounds_rect>
		<nme_bitmap_data_scroll line="485" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_scroll>
		<nme_bitmap_data_set_pixel line="486" static="1"><f a=":::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_set_pixel>
		<nme_bitmap_data_set_pixel32 line="487" static="1"><f a=":::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="neash.display.BitmapInt32"/>
	<unknown/>
</f></nme_bitmap_data_set_pixel32>
		<nme_bitmap_data_set_pixel_rgba line="488" static="1"><unknown/></nme_bitmap_data_set_pixel_rgba>
		<nme_bitmap_data_set_bytes line="489" static="1"><f a=":::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="neash.utils.ByteArray"/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_set_bytes>
		<nme_bitmap_data_set_format line="490" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_set_format>
		<nme_bitmap_data_set_array line="492" static="1"><f a="::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="Array"><c path="Int"/></c>
	<unknown/>
</f></nme_bitmap_data_set_array>
		<nme_bitmap_data_create_hardware_surface line="493" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_bitmap_data_create_hardware_surface>
		<nme_bitmap_data_destroy_hardware_surface line="494" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_bitmap_data_destroy_hardware_surface>
		<nme_bitmap_data_generate_filter_rect line="496" static="1"><f a="::">
	<c path="neash.geom.Rectangle"/>
	<c path="neash.filters.BitmapFilter"/>
	<c path="neash.geom.Rectangle"/>
	<unknown/>
</f></nme_bitmap_data_generate_filter_rect>
		<nme_render_surface_to_surface line="497" static="1"><f a="::::::">
	<d/>
	<d/>
	<c path="neash.geom.Matrix"/>
	<c path="neash.geom.ColorTransform"/>
	<c path="String"/>
	<c path="neash.geom.Rectangle"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_render_surface_to_surface>
		<nme_bitmap_data_height line="498" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_bitmap_data_height>
		<nme_bitmap_data_width line="499" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_bitmap_data_width>
		<nme_bitmap_data_get_transparent line="500" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_bitmap_data_get_transparent>
		<nme_bitmap_data_set_flags line="501" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_bitmap_data_set_flags>
		<nme_bitmap_data_encode line="502" static="1"><f a="::">
	<d/>
	<c path="String"/>
	<c path="Float"/>
	<c path="neash.utils.ByteArray"/>
</f></nme_bitmap_data_encode>
		<nme_bitmap_data_dump_bits line="503" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_bitmap_data_dump_bits>
		<nme_bitmap_data_noise line="504" static="1"><f a=":::::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_bitmap_data_noise>
		<nmeGetTransparent set="method" line="459">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTransparent>
		<nmeGetHeight set="method" line="458">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetHeight>
		<nmeGetWidth set="method" line="457">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetWidth>
		<nmeGetRect set="method" line="456">
			<f a=""><c path="neash.geom.Rectangle"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetRect>
		<noise public="1" set="method" line="448"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<setFormat public="1" set="method" line="443"><f a="format">
	<c path="Int"/>
	<e path="Void"/>
</f></setFormat>
		<unlock public="1" set="method" line="438"><f a="?changeRect">
	<c path="neash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<setVector public="1" set="method" line="421"><f a="rect:inPixels">
	<c path="neash.geom.Rectangle"/>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></setVector>
		<setPixels public="1" set="method" line="412"><f a="rect:pixels">
	<c path="neash.geom.Rectangle"/>
	<c path="neash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method" line="402"><f a="inX:inY:inColour">
	<c path="Int"/>
	<c path="Int"/>
	<t path="neash.display.BitmapInt32"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method" line="396"><f a="inX:inY:inColour">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setPixel>
		<setFlags public="1" set="method" line="389"><f a="inFlags">
	<c path="Int"/>
	<e path="Void"/>
</f></setFlags>
		<scroll public="1" set="method" line="383"><f a="inDX:inDY">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<perlinNoise public="1" set="method" line="376"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Array"><c path="neash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<nmeDrawToSurface public="1" set="method" line="369">
			<f a="inSurface:matrix:colorTransform:blendMode:clipRect:smoothing">
				<d/>
				<c path="neash.geom.Matrix"/>
				<c path="neash.geom.ColorTransform"/>
				<c path="String"/>
				<c path="neash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeDrawToSurface>
		<lock public="1" set="method" line="363"><f a=""><e path="Void"/></f></lock>
		<getVector public="1" set="method" line="296"><f a="rect">
	<c path="neash.geom.Rectangle"/>
	<c path="Array"><c path="Int"/></c>
</f></getVector>
		<getPixels public="1" set="method" line="285"><f a="rect">
	<c path="neash.geom.Rectangle"/>
	<c path="neash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method" line="275"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="neash.display.BitmapInt32"/>
</f></getPixel32>
		<getPixel public="1" set="method" line="269"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method" line="261"><f a="mask:color:?findColor">
	<t path="neash.display.BitmapInt32"/>
	<t path="neash.display.BitmapInt32"/>
	<e path="Bool"/>
	<c path="neash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method" line="253"><f a="sourceRect:filter">
	<c path="neash.geom.Rectangle"/>
	<c path="neash.filters.BitmapFilter"/>
	<c path="neash.geom.Rectangle"/>
</f></generateFilterRect>
		<fillRectEx public="1" set="method" line="247"><f a="rect:inColour:?inAlpha">
	<c path="neash.geom.Rectangle"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></fillRectEx>
		<fillRect public="1" set="method" line="239"><f a="rect:inColour">
	<c path="neash.geom.Rectangle"/>
	<t path="neash.display.BitmapInt32"/>
	<e path="Void"/>
</f></fillRect>
		<encode public="1" set="method" line="213"><f a="inFormat:?inQuality">
	<c path="String"/>
	<c path="Float"/>
	<c path="neash.utils.ByteArray"/>
</f></encode>
		<dumpBits public="1" set="method" line="207"><f a=""><e path="Void"/></f></dumpBits>
		<draw public="1" set="method" line="201"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="neash.display.IBitmapDrawable"/>
	<c path="neash.geom.Matrix"/>
	<c path="neash.geom.ColorTransform"/>
	<c path="String"/>
	<c path="neash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<dispose public="1" set="method" line="195"><f a=""><e path="Void"/></f></dispose>
		<destroyHardwareSurface public="1" set="method" line="188"><f a=""><e path="Void"/></f></destroyHardwareSurface>
		<createHardwareSurface public="1" set="method" line="182"><f a=""><e path="Void"/></f></createHardwareSurface>
		<copyPixels public="1" set="method" line="165">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
				<c path="neash.display.BitmapData"/>
				<c path="neash.geom.Rectangle"/>
				<c path="neash.geom.Point"/>
				<c path="neash.display.BitmapData"/>
				<c path="neash.geom.Point"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Copies pixels from a bitmap data object into this instance
	 * @param	sourceBitmapData		The source bitmap data object
	 * @param	sourceRect		The source rectangle to pull from
	 * @param	destPoint		The destination point on this bitmap data object
	 * @param	alphaBitmapData		(Optional) A source bitmap data object to use for alpha information
	 * @param	alphaPoint		(Optional) A source point to use when copying from the alpha bitmap data object
	 * @param	mergeAlpha		(Optional) Whether copied pixels should have their alpha merged with pixels at the destination</haxe_doc>
		</copyPixels>
		<copyChannel public="1" set="method" line="150">
			<f a="sourceBitmapData:sourceRect:destPoint:inSourceChannel:inDestChannel">
				<c path="neash.display.BitmapData"/>
				<c path="neash.geom.Rectangle"/>
				<c path="neash.geom.Point"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Copies a channel (red, green, blue or alpha) into another channel or object
	 * @param	sourceBitmapData		The source bitmap data object
	 * @param	sourceRect		The source rectangle to pull from
	 * @param	destPoint		The destination point on this bitmap data object
	 * @param	inSourceChannel		The source channel to copy
	 * @param	inDestChannel		The destination channel to paste into</haxe_doc>
		</copyChannel>
		<colorTransform public="1" set="method" line="136">
			<f a="rect:colorTransform">
				<c path="neash.geom.Rectangle"/>
				<c path="neash.geom.ColorTransform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Applies a color transform to a portion of this bitmap data object
	 * @param	rect		A rectangular area to transform
	 * @param	colorTransform		The color transform to use</haxe_doc>
		</colorTransform>
		<clone public="1" set="method" line="123">
			<f a=""><c path="neash.display.BitmapData"/></f>
			<haxe_doc>* Duplicates the current instance as a new bitmap data object
	 * @return		A new duplicate bitmap data object</haxe_doc>
		</clone>
		<clear public="1" set="method" line="113">
			<f a="color">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fills this bitmap data object using a solid color
	 * @param	color		The color to fill</haxe_doc>
		</clear>
		<applyFilter public="1" set="method" line="103">
			<f a="sourceBitmapData:sourceRect:destPoint:filter">
				<c path="neash.display.BitmapData"/>
				<c path="neash.geom.Rectangle"/>
				<c path="neash.geom.Point"/>
				<c path="neash.filters.BitmapFilter"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Draws the result of a bitmap data object, plus a bitmap filter, to this bitmap data
	 * @param	sourceBitmapData		The source bitmap data object
	 * @param	sourceRect		A rectangle which defines the area to use from the source bitmap data object
	 * @param	destPoint		The location to place the result in this bitmap data object
	 * @param	filter		The bitmap filter to use</haxe_doc>
		</applyFilter>
		<nmeHandle public="1">
			<d/>
			<haxe_doc>* @private</haxe_doc>
		</nmeHandle>
		<width public="1" get="nmeGetWidth" set="null">
			<c path="Int"/>
			<haxe_doc>* Returns the width in pixels of the bitmap data</haxe_doc>
		</width>
		<transparent public="1" get="nmeGetTransparent" set="null">
			<e path="Bool"/>
			<haxe_doc>* Returns whether the bitmap data includes transparency</haxe_doc>
		</transparent>
		<rect public="1" get="nmeGetRect" set="null">
			<c path="neash.geom.Rectangle"/>
			<haxe_doc>* Returns a rectangle with the dimensions of the bitmap data</haxe_doc>
		</rect>
		<height public="1" get="nmeGetHeight" set="null">
			<c path="Int"/>
			<haxe_doc>* Returns the height in pixels of the bitmap data</haxe_doc>
		</height>
		<new public="1" set="method" line="63"><f a="inWidth:inHeight:?inTransparent:?inFillRGBA">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="neash.display.BitmapInt32"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author   Hugh Sanderson
* @author   Russell Weir
* @todo getPixel, getPixel32 should be optimized to use library methods</haxe_doc>
	</class>
	<class path="neash.display.OptimizedPerlin" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/BitmapData.hx" module="neash.display.BitmapData">
		<P line="512" static="1"><c path="Array"><c path="Int"/></c></P>
		<seedOffset set="method" line="722"><f a="iSeed">
	<c path="Int"/>
	<e path="Void"/>
</f></seedOffset>
		<octFreqPers set="method" line="702"><f a="fPersistence">
	<c path="Float"/>
	<e path="Void"/>
</f></octFreqPers>
		<fill public="1" set="method" line="589"><f a="bitmap:_x:_y:_z:?_">
	<c path="neash.display.BitmapData"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<unknown/>
	<e path="Void"/>
</f></fill>
		<baseFactor><c path="Float"/></baseFactor>
		<iZoffset><c path="Float"/></iZoffset>
		<iYoffset><c path="Float"/></iYoffset>
		<iXoffset><c path="Float"/></iXoffset>
		<fPersMax><c path="Float"/></fPersMax>
		<aOctPers><c path="Array"><c path="Float"/></c></aOctPers>
		<aOctFreq><c path="Array"><c path="Float"/></c></aOctFreq>
		<octaves><c path="Int"/></octaves>
		<new public="1" set="method" line="581"><f a="?seed:?octaves:?falloff">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="neash.display.BitmapInt32" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/BitmapInt32.hx"><c path="Int"/></typedef>
	<enum path="neash.display.BlendMode" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/BlendMode.hx">
		<SUBTRACT/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
	</enum>
	<enum path="neash.display.CapsStyle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
	</enum>
	<class path="neash.events.IEventDispatcher" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/IEventDispatcher.hx" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<t path="neash.events.Function"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="neash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<t path="neash.events.Function"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
	</class>
	<class path="neash.events.EventDispatcher" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/EventDispatcher.hx">
		<implements path="neash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method" line="150"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method" line="144"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method" line="120"><f a="type:listener:?capture">
	<c path="String"/>
	<t path="neash.events.Function"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method" line="106"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<DispatchIOErrorEvent public="1" set="method" line="99">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Creates and dispatches a typical IOErrorEvent.IO_ERROR
   * @private</haxe_doc>
		</DispatchIOErrorEvent>
		<dispatchEvent public="1" set="method" line="50"><f a="event">
	<c path="neash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<DispatchCompleteEvent public="1" set="method" line="43">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Creates and dispatches a typical Event.COMPLETE
   * @private</haxe_doc>
		</DispatchCompleteEvent>
		<addEventListener public="1" set="method" line="23"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<t path="neash.events.Function"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<nmeTarget>
			<c path="neash.events.IEventDispatcher"/>
			<haxe_doc>@private</haxe_doc>
		</nmeTarget>
		<nmeEventMap>
			<t path="neash.events.EventMap"/>
			<haxe_doc>@private</haxe_doc>
		</nmeEventMap>
		<new public="1" set="method" line="16"><f a="?target">
	<c path="neash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.display.DisplayObject" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/DisplayObject.hx">
		<extends path="neash.events.EventDispatcher"/>
		<implements path="neash.display.IBitmapDrawable"/>
		<nme_create_display_object line="773" static="1"><f a=""><unknown/></f></nme_create_display_object>
		<nme_display_object_get_graphics line="774" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_display_object_get_graphics>
		<nme_display_object_draw_to_surface line="775" static="1"><f a=":::::">
	<d/>
	<d/>
	<c path="neash.geom.Matrix"/>
	<c path="neash.geom.ColorTransform"/>
	<c path="String"/>
	<c path="neash.geom.Rectangle"/>
	<unknown/>
</f></nme_display_object_draw_to_surface>
		<nme_display_object_get_id line="776" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_display_object_get_id>
		<nme_display_object_get_x line="777" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_x>
		<nme_display_object_set_x line="778" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_x>
		<nme_display_object_get_y line="779" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_y>
		<nme_display_object_set_y line="780" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_y>
		<nme_display_object_get_scale_x line="781" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_scale_x>
		<nme_display_object_set_scale_x line="782" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_scale_x>
		<nme_display_object_get_scale_y line="783" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_scale_y>
		<nme_display_object_set_scale_y line="784" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_scale_y>
		<nme_display_object_get_mouse_x line="785" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_mouse_x>
		<nme_display_object_get_mouse_y line="786" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_mouse_y>
		<nme_display_object_get_rotation line="787" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_rotation>
		<nme_display_object_set_rotation line="788" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_rotation>
		<nme_display_object_get_bg line="789" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_display_object_get_bg>
		<nme_display_object_set_bg line="790" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_display_object_set_bg>
		<nme_display_object_get_name line="791" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></nme_display_object_get_name>
		<nme_display_object_set_name line="792" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></nme_display_object_set_name>
		<nme_display_object_get_width line="793" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_width>
		<nme_display_object_set_width line="794" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_width>
		<nme_display_object_get_height line="795" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_height>
		<nme_display_object_set_height line="796" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_height>
		<nme_display_object_get_alpha line="797" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_display_object_get_alpha>
		<nme_display_object_set_alpha line="798" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_display_object_set_alpha>
		<nme_display_object_get_blend_mode line="799" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_display_object_get_blend_mode>
		<nme_display_object_set_blend_mode line="800" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_display_object_set_blend_mode>
		<nme_display_object_get_cache_as_bitmap line="801" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_display_object_get_cache_as_bitmap>
		<nme_display_object_set_cache_as_bitmap line="802" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_set_cache_as_bitmap>
		<nme_display_object_get_pedantic_bitmap_caching line="803" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_display_object_get_pedantic_bitmap_caching>
		<nme_display_object_set_pedantic_bitmap_caching line="804" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_set_pedantic_bitmap_caching>
		<nme_display_object_get_pixel_snapping line="805" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_display_object_get_pixel_snapping>
		<nme_display_object_set_pixel_snapping line="806" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_display_object_set_pixel_snapping>
		<nme_display_object_get_visible line="807" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_display_object_get_visible>
		<nme_display_object_set_visible line="808" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_set_visible>
		<nme_display_object_set_filters line="809" static="1"><f a=":">
	<d/>
	<c path="Array"><d/></c>
	<unknown/>
</f></nme_display_object_set_filters>
		<nme_display_object_global_to_local line="810" static="1"><f a=":">
	<d/>
	<c path="neash.geom.Point"/>
	<unknown/>
</f></nme_display_object_global_to_local>
		<nme_display_object_local_to_global line="811" static="1"><f a=":">
	<d/>
	<c path="neash.geom.Point"/>
	<unknown/>
</f></nme_display_object_local_to_global>
		<nme_display_object_set_scale9_grid line="812" static="1"><f a=":">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<unknown/>
</f></nme_display_object_set_scale9_grid>
		<nme_display_object_set_scroll_rect line="813" static="1"><f a=":">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<unknown/>
</f></nme_display_object_set_scroll_rect>
		<nme_display_object_set_mask line="814" static="1"><f a=":">
	<d/>
	<t path="Null"><unknown/></t>
	<unknown/>
</f></nme_display_object_set_mask>
		<nme_display_object_set_matrix line="815" static="1"><f a=":">
	<d/>
	<c path="neash.geom.Matrix"/>
	<unknown/>
</f></nme_display_object_set_matrix>
		<nme_display_object_get_matrix line="816" static="1"><f a="::">
	<d/>
	<c path="neash.geom.Matrix"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_get_matrix>
		<nme_display_object_get_color_transform line="817" static="1"><f a="::">
	<d/>
	<c path="neash.geom.ColorTransform"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_get_color_transform>
		<nme_display_object_set_color_transform line="818" static="1"><f a=":">
	<d/>
	<c path="neash.geom.ColorTransform"/>
	<unknown/>
</f></nme_display_object_set_color_transform>
		<nme_display_object_get_pixel_bounds line="819" static="1"><f a=":">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<unknown/>
</f></nme_display_object_get_pixel_bounds>
		<nme_display_object_get_bounds line="820" static="1"><f a=":::">
	<d/>
	<d/>
	<c path="neash.geom.Rectangle"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_get_bounds>
		<nme_display_object_hit_test_point line="821" static="1"><f a="::::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nme_display_object_hit_test_point>
		<nmeSetY set="method" line="761">
			<f a="inVal">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetY>
		<nmeGetY set="method" line="760">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetY>
		<nmeSetX set="method" line="753">
			<f a="inVal">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetX>
		<nmeGetX set="method" line="752">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetX>
		<nmeSetWidth set="method" line="745">
			<f a="inVal">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetWidth>
		<nmeGetWidth set="method" line="744">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetWidth>
		<nmeSetVisible set="method" line="737">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetVisible>
		<nmeGetVisible set="method" line="736">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetVisible>
		<nmeSetTransform set="method" line="728">
			<f a="inTransform">
				<c path="neash.geom.Transform"/>
				<c path="neash.geom.Transform"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetTransform>
		<nmeGetTransform set="method" line="727">
			<f a=""><c path="neash.geom.Transform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTransform>
		<nmeGetStage public="1" set="method" line="718">
			<f a=""><c path="neash.display.Stage"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetStage>
		<nmeSetScrollRect set="method" line="710">
			<f a="inRect">
				<c path="neash.geom.Rectangle"/>
				<c path="neash.geom.Rectangle"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetScrollRect>
		<nmeGetScrollRect set="method" line="709">
			<f a=""><c path="neash.geom.Rectangle"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetScrollRect>
		<nmeSetScaleY set="method" line="702">
			<f a="inVal">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetScaleY>
		<nmeGetScaleY set="method" line="701">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetScaleY>
		<nmeSetScaleX set="method" line="694">
			<f a="inVal">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetScaleX>
		<nmeGetScaleX set="method" line="693">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetScaleX>
		<nmeSetScale9Grid set="method" line="685">
			<f a="inRect">
				<c path="neash.geom.Rectangle"/>
				<c path="neash.geom.Rectangle"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetScale9Grid>
		<nmeGetScale9Grid set="method" line="684">
			<f a=""><c path="neash.geom.Rectangle"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetScale9Grid>
		<nmeSetRotation set="method" line="677">
			<f a="inVal">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetRotation>
		<nmeGetRotation set="method" line="676">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetRotation>
		<nmeSetParent public="1" set="method" line="648">
			<f a="inParent">
				<c path="neash.display.DisplayObjectContainer"/>
				<c path="neash.display.DisplayObjectContainer"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetParent>
		<nmeGetParent set="method" line="645">
			<f a=""><c path="neash.display.DisplayObjectContainer"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetParent>
		<nmeSetName set="method" line="638">
			<f a="inVal">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetName>
		<nmeGetName set="method" line="637">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetName>
		<nmeGetMouseY set="method" line="634">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMouseY>
		<nmeGetMouseX set="method" line="633">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMouseX>
		<nmeSetMask set="method" line="625">
			<f a="inObject">
				<c path="neash.display.DisplayObject"/>
				<c path="neash.display.DisplayObject"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMask>
		<nmeSetHeight set="method" line="618">
			<f a="inVal">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetHeight>
		<nmeGetHeight set="method" line="617">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetHeight>
		<nmeGetGraphics public="1" set="method" line="609">
			<f a=""><c path="neash.display.Graphics"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetGraphics>
		<nmeSetFilters set="method" line="589">
			<f a="inFilters">
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetFilters>
		<nmeGetFilters set="method" line="576">
			<f a=""><c path="Array"><d/></c></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetFilters>
		<nmeSetPixelSnapping set="method" line="568">
			<f a="inVal">
				<e path="neash.display.PixelSnapping"/>
				<e path="neash.display.PixelSnapping"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetPixelSnapping>
		<nmeGetPixelSnapping set="method" line="563">
			<f a=""><e path="neash.display.PixelSnapping"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetPixelSnapping>
		<nmeSetPedanticBitmapCaching set="method" line="558">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetPedanticBitmapCaching>
		<nmeGetPedanticBitmapCaching set="method" line="557">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetPedanticBitmapCaching>
		<nmeSetCacheAsBitmap set="method" line="551">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetCacheAsBitmap>
		<nmeGetCacheAsBitmap set="method" line="550">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetCacheAsBitmap>
		<nmeSetBlendMode set="method" line="543">
			<f a="inMode">
				<e path="neash.display.BlendMode"/>
				<e path="neash.display.BlendMode"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBlendMode>
		<nmeGetBlendMode set="method" line="536">
			<f a=""><e path="neash.display.BlendMode"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBlendMode>
		<nmeSetBG set="method" line="525">
			<f a="inBG">
				<t path="Null"><c path="Int"/></t>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBG>
		<nmeGetBG set="method" line="515">
			<f a=""><t path="Null"><c path="Int"/></t></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBG>
		<nmeSetAlpha set="method" line="508">
			<f a="inAlpha">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetAlpha>
		<nmeGetAlpha set="method" line="507">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetAlpha>
		<toString public="1" set="method" line="496" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</toString>
		<nmeSetMatrix public="1" set="method" line="487">
			<f a="inMatrix">
				<c path="neash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMatrix>
		<nmeSetColorTransform public="1" set="method" line="481">
			<f a="inTrans">
				<c path="neash.geom.ColorTransform"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetColorTransform>
		<nmeOnRemoved set="method" line="463">
			<f a="inObj:inWasOnStage">
				<c path="neash.display.DisplayObject"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnRemoved>
		<nmeOnAdded set="method" line="445">
			<f a="inObj:inIsOnStage">
				<c path="neash.display.DisplayObject"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnAdded>
		<nmeGetPixelBounds public="1" set="method" line="437">
			<f a=""><c path="neash.geom.Rectangle"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetPixelBounds>
		<nmeGetObjectsUnderPoint public="1" set="method" line="430">
			<f a="point:result">
				<c path="neash.geom.Point"/>
				<c path="Array"><c path="neash.display.DisplayObject"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetObjectsUnderPoint>
		<nmeGetMatrix public="1" set="method" line="422">
			<f a=""><c path="neash.geom.Matrix"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMatrix>
		<nmeGetInteractiveObjectStack public="1" set="method" line="410">
			<f a="outStack">
				<c path="Array"><c path="neash.display.InteractiveObject"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetInteractiveObjectStack>
		<nmeGetConcatenatedMatrix public="1" set="method" line="402">
			<f a=""><c path="neash.geom.Matrix"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetConcatenatedMatrix>
		<nmeGetConcatenatedColorTransform public="1" set="method" line="394">
			<f a=""><c path="neash.geom.ColorTransform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetConcatenatedColorTransform>
		<nmeGetColorTransform public="1" set="method" line="386">
			<f a=""><c path="neash.geom.ColorTransform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetColorTransform>
		<nmeFireEvent set="method" line="334">
			<f a="inEvt">
				<c path="neash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeFireEvent>
		<nmeFindByID set="method" line="326">
			<f a="inID">
				<c path="Int"/>
				<c path="neash.display.DisplayObject"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeFindByID>
		<nmeDrawToSurface public="1" set="method" line="319">
			<f a="inSurface:matrix:colorTransform:blendMode:clipRect:smoothing">
				<d/>
				<c path="neash.geom.Matrix"/>
				<c path="neash.geom.ColorTransform"/>
				<c path="String"/>
				<c path="neash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeDrawToSurface>
		<nmeDispatchEvent public="1" set="method" line="308">
			<f a="inEvt">
				<c path="neash.events.Event"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeDispatchEvent>
		<nmeBroadcast public="1" set="method" line="302">
			<f a="inEvt">
				<c path="neash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeBroadcast>
		<nmeAsInteractiveObject set="method" line="296">
			<f a=""><c path="neash.display.InteractiveObject"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeAsInteractiveObject>
		<localToGlobal public="1" set="method" line="288">
			<f a="inLocal">
				<c path="neash.geom.Point"/>
				<c path="neash.geom.Point"/>
			</f>
			<haxe_doc>* Converts a point from local coordinates to global coordinates.
	 * @param	inGlobal		A point in local coordinates
	 * @return		A point in global coordinates</haxe_doc>
		</localToGlobal>
		<getRect public="1" set="method" line="273"><f a="targetCoordinateSpace">
	<c path="neash.display.DisplayObject"/>
	<c path="neash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method" line="266"><f a="targetCoordinateSpace">
	<c path="neash.display.DisplayObject"/>
	<c path="neash.geom.Rectangle"/>
</f></getBounds>
		<hitTestPoint public="1" set="method" line="261">
			<f a="x:y:?shapeFlag">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>* Determines if the specified global coordinate point overlaps the
	 * contents of this object.
	 * 
	 * This method does not check for transparency, so if the object contains
	 * a bitmap image, transparent pixels will return "true" for a hit test.
	 * @param	x		The x coordinate point to test
	 * @param	y		The y coordinate point to test
	 * @param	shapeFlag		Whether to use the exact shape of this object (slower) or a bounding box
	 * @return		Whether the point intersects with the contents of this object</haxe_doc>
		</hitTestPoint>
		<hitTestObject public="1" set="method" line="225"><f a="object">
	<c path="neash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<globalToLocal public="1" set="method" line="217">
			<f a="inGlobal">
				<c path="neash.geom.Point"/>
				<c path="neash.geom.Point"/>
			</f>
			<haxe_doc>* Converts a point from global coordinates to local coordinates.
	 * @param	inGlobal		A point in global coordinates
	 * @return		A point in local coordinates</haxe_doc>
		</globalToLocal>
		<dispatchEvent public="1" set="method" line="196" override="1"><f a="event">
	<c path="neash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<nmeScrollRect>
			<c path="neash.geom.Rectangle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeScrollRect>
		<nmeScale9Grid>
			<c path="neash.geom.Rectangle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeScale9Grid>
		<nmeParent>
			<c path="neash.display.DisplayObjectContainer"/>
			<haxe_doc>@private</haxe_doc>
		</nmeParent>
		<nmeID>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</nmeID>
		<nmeGraphicsCache>
			<c path="neash.display.Graphics"/>
			<haxe_doc>@private</haxe_doc>
		</nmeGraphicsCache>
		<nmeFilters>
			<c path="Array"><d/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeFilters>
		<y public="1" get="nmeGetY" set="nmeSetY">
			<c path="Float"/>
			<haxe_doc>* The y position for this object, local to its parent</haxe_doc>
		</y>
		<x public="1" get="nmeGetX" set="nmeSetX">
			<c path="Float"/>
			<haxe_doc>* The x position for this object, local to its parent</haxe_doc>
		</x>
		<width public="1" get="nmeGetWidth" set="nmeSetWidth">
			<c path="Float"/>
			<haxe_doc>* The width in pixels for this object</haxe_doc>
		</width>
		<visible public="1" get="nmeGetVisible" set="nmeSetVisible">
			<e path="Bool"/>
			<haxe_doc>* Controls whether this object is visible and rendered, or if
	 * it is invisible.
	 * 
	 * An object that has visible set to false will perform faster than
	 * and object that only has its alpha set to 0.</haxe_doc>
		</visible>
		<transform public="1" get="nmeGetTransform" set="nmeSetTransform">
			<c path="neash.geom.Transform"/>
			<haxe_doc>* Set the matrix and color transform for this object.
	 * 
	 * If you want to change the object's transform, you need to re-assign
	 * the property, like "displayObject.transform = newTransform;"</haxe_doc>
		</transform>
		<stage public="1" get="nmeGetStage" set="null">
			<c path="neash.display.Stage"/>
			<haxe_doc>* If this object has been added to the display list, which has been added
	 * to the stage, this will return the root Stage object. Otherwise, this will
	 * return null.</haxe_doc>
		</stage>
		<scrollRect public="1" get="nmeGetScrollRect" set="nmeSetScrollRect">
			<c path="neash.geom.Rectangle"/>
			<haxe_doc>* Set a "scroll rect" to control how much of the object should be rendered</haxe_doc>
		</scrollRect>
		<scaleY public="1" get="nmeGetScaleY" set="nmeSetScaleY">
			<c path="Float"/>
			<haxe_doc>* Control the vertical scale of the object, as a percentage value</haxe_doc>
		</scaleY>
		<scaleX public="1" get="nmeGetScaleX" set="nmeSetScaleX">
			<c path="Float"/>
			<haxe_doc>* Control the horizontal scale of the object, as a percentage value</haxe_doc>
		</scaleX>
		<scale9Grid public="1" get="nmeGetScale9Grid" set="nmeSetScale9Grid">
			<c path="neash.geom.Rectangle"/>
			<haxe_doc>* Set a "scale 9" grid to control how the object stretches or
	 * squashes when its scale is changed.</haxe_doc>
		</scale9Grid>
		<rotation public="1" get="nmeGetRotation" set="nmeSetRotation">
			<c path="Float"/>
			<haxe_doc>* Control the rotation of this object, in degrees.</haxe_doc>
		</rotation>
		<parent public="1" get="nmeGetParent" set="null">
			<c path="neash.display.DisplayObjectContainer"/>
			<haxe_doc>* If this object has been added to the display list, then this is
	 * the "parent" DisplayObjectContainer. Otherwise this will be
	 * null.</haxe_doc>
		</parent>
		<opaqueBackground public="1" get="nmeGetBG" set="nmeSetBG">
			<t path="Null"><c path="Int"/></t>
			<haxe_doc>* Set or change an opaque background color for this object.</haxe_doc>
		</opaqueBackground>
		<nmeHandle public="1">
			<d/>
			<haxe_doc>* @private</haxe_doc>
		</nmeHandle>
		<name public="1" get="nmeGetName" set="nmeSetName">
			<c path="String"/>
			<haxe_doc>* Get or set the name for this object.</haxe_doc>
		</name>
		<mouseY public="1" get="nmeGetMouseY" set="null">
			<c path="Float"/>
			<haxe_doc>* Indicates the current mouse y position, using the coordinate system of
	 * this object.</haxe_doc>
		</mouseY>
		<mouseX public="1" get="nmeGetMouseX" set="null">
			<c path="Float"/>
			<haxe_doc>* Indicates the current mouse x position, using the coordinate system of
	 * this object.</haxe_doc>
		</mouseX>
		<mask public="1" set="nmeSetMask">
			<c path="neash.display.DisplayObject"/>
			<haxe_doc>* Define a mask to control how much of this object should
	 * be visible.</haxe_doc>
		</mask>
		<height public="1" get="nmeGetHeight" set="nmeSetHeight">
			<c path="Float"/>
			<haxe_doc>* The height in pixels for this object</haxe_doc>
		</height>
		<graphics public="1" get="nmeGetGraphics" set="null">
			<c path="neash.display.Graphics"/>
			<haxe_doc>* Returns a reference to the nme.display.Graphics interface
	 * for this object. You can use this class to draw primitives
	 * like squares, circles, lines, curves or tiles.</haxe_doc>
		</graphics>
		<filters public="1" get="nmeGetFilters" set="nmeSetFilters">
			<c path="Array"><d/></c>
			<haxe_doc>* An array of BitmapFilters being used with this object.
	 * 
	 * If you want to add, remove or change a filter, you need to re-assign
	 * the property, like "displayObject.filters = newFilters;"</haxe_doc>
		</filters>
		<pixelSnapping public="1" get="nmeGetPixelSnapping" set="nmeSetPixelSnapping">
			<e path="neash.display.PixelSnapping"/>
			<haxe_doc>* This allows translations to be aligned to pixel boundaries, giving more predicatble results.
  * Note that this more general that the flash.display.Bitmap.pixelSnapping in that it can be applied to any DisplayObject.</haxe_doc>
		</pixelSnapping>
		<pedanticBitmapCaching public="1" get="nmeGetPedanticBitmapCaching" set="nmeSetPedanticBitmapCaching">
			<e path="Bool"/>
			<haxe_doc>* When cacheAsBitmap is true, new bitmaps are generated when the DisplayObject changes.
	 * When pedanticBitmapCaching=true, new bitmaps will be generated for non-integer sub-pixel movements.
	 * When pedanticBitmapCaching=false, new bitmaps will not be generated for general translations.
    * This allows for the number of renders to be kept small, while maintaining sub-pixel anti-aliasing,
    *  at the cost of sub-pixel accuracy in position.
    * Note that this is not supported in flash (which effectively defaults to true), an it is generally a perfromance optimisation.</haxe_doc>
		</pedanticBitmapCaching>
		<cacheAsBitmap public="1" get="nmeGetCacheAsBitmap" set="nmeSetCacheAsBitmap">
			<e path="Bool"/>
			<haxe_doc>* If set to true, NME will render the object using its software renderer,
	 * then it will cache the result. This can improve performance for certain
	 * types of complex objects.</haxe_doc>
		</cacheAsBitmap>
		<blendMode public="1" get="nmeGetBlendMode" set="nmeSetBlendMode">
			<e path="neash.display.BlendMode"/>
			<haxe_doc>* Adjusts this object blends with other objects on-screen</haxe_doc>
		</blendMode>
		<alpha public="1" get="nmeGetAlpha" set="nmeSetAlpha">
			<c path="Float"/>
			<haxe_doc>* The opacity of the object, as a percentage value from 0 to 1</haxe_doc>
		</alpha>
		<new public="1" set="method" line="185"><f a="inHandle:inType">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.display.InteractiveObject" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/InteractiveObject.hx">
		<extends path="neash.display.DisplayObject"/>
		<nme_display_object_set_mouse_enabled line="84" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_set_mouse_enabled>
		<nme_display_object_set_needs_soft_keyboard line="85" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_set_needs_soft_keyboard>
		<nme_display_object_get_needs_soft_keyboard line="86" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_display_object_get_needs_soft_keyboard>
		<nme_display_object_set_moves_for_soft_keyboard line="87" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_display_object_set_moves_for_soft_keyboard>
		<nme_display_object_get_moves_for_soft_keyboard line="88" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_display_object_get_moves_for_soft_keyboard>
		<nme_display_object_request_soft_keyboard line="89" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_display_object_request_soft_keyboard>
		<nmeGetNeedsSoftKeyboard set="method" line="73">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetNeedsSoftKeyboard>
		<nmeSetNeedsSoftKeyboard set="method" line="66">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetNeedsSoftKeyboard>
		<nmeGetMoveForSoftKeyboard set="method" line="60">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMoveForSoftKeyboard>
		<nmeSetMoveForSoftKeyboard set="method" line="53">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMoveForSoftKeyboard>
		<nmeSetMouseEnabled set="method" line="45">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMouseEnabled>
		<nmeGetMouseEnabled set="method" line="44">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMouseEnabled>
		<requestSoftKeyboard public="1" set="method" line="33"><f a=""><e path="Bool"/></f></requestSoftKeyboard>
		<nmeAsInteractiveObject set="method" line="27" override="1">
			<f a=""><c path="neash.display.InteractiveObject"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeAsInteractiveObject>
		<nmeMouseEnabled>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</nmeMouseEnabled>
		<needsSoftKeyboard public="1" get="nmeGetNeedsSoftKeyboard" set="nmeSetNeedsSoftKeyboard"><e path="Bool"/></needsSoftKeyboard>
		<moveForSoftKeyboard public="1" get="nmeGetMoveForSoftKeyboard" set="nmeSetMoveForSoftKeyboard"><e path="Bool"/></moveForSoftKeyboard>
		<mouseEnabled public="1" get="nmeGetMouseEnabled" set="nmeSetMouseEnabled"><e path="Bool"/></mouseEnabled>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<new public="1" set="method" line="18"><f a="inHandle:inType">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.display.DisplayObjectContainer" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/DisplayObjectContainer.hx">
		<extends path="neash.display.InteractiveObject"/>
		<nme_create_display_object_container line="363" static="1"><f a=""><unknown/></f></nme_create_display_object_container>
		<nme_doc_add_child line="364" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></nme_doc_add_child>
		<nme_doc_remove_child line="365" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_doc_remove_child>
		<nme_doc_set_child_index line="366" static="1"><f a="::">
	<d/>
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_doc_set_child_index>
		<nme_doc_get_mouse_children line="367" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_doc_get_mouse_children>
		<nme_doc_set_mouse_children line="368" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_doc_set_mouse_children>
		<nme_doc_swap_children line="369" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_doc_swap_children>
		<nmeSetTabChildren set="method" line="355">
			<f a="inValue">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetTabChildren>
		<nmeGetTabChildren set="method" line="354">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTabChildren>
		<nmeGetNumChildren set="method" line="353">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetNumChildren>
		<nmeSetMouseChildren set="method" line="346">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMouseChildren>
		<nmeGetMouseChildren set="method" line="345">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMouseChildren>
		<swapChildrenAt public="1" set="method" line="334"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method" line="324"><f a="child1:child2">
	<c path="neash.display.DisplayObject"/>
	<c path="neash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method" line="318"><f a="child:index">
	<c path="neash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<removeChildAt public="1" set="method" line="305"><f a="index">
	<c path="Int"/>
	<c path="neash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method" line="289"><f a="child">
	<c path="neash.display.DisplayObject"/>
	<c path="neash.display.DisplayObject"/>
</f></removeChild>
		<nmeSwapChildrenAt get="inline" set="null" line="274">
			<f a="index1:index2">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSwapChildrenAt>
		<nmeSetChildIndex get="inline" set="null" line="211">
			<f a="child:index">
				<c path="neash.display.DisplayObject"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetChildIndex>
		<nmeRemoveChildFromArray public="1" set="method" line="199">
			<f a="child">
				<c path="neash.display.DisplayObject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeRemoveChildFromArray>
		<nmeOnRemoved set="method" line="190" override="1">
			<f a="inObj:inWasOnStage">
				<c path="neash.display.DisplayObject"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnRemoved>
		<nmeOnAdded set="method" line="181" override="1">
			<f a="inObj:inIsOnStage">
				<c path="neash.display.DisplayObject"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnAdded>
		<nmeGetObjectsUnderPoint public="1" set="method" line="172" override="1">
			<f a="point:result">
				<c path="neash.geom.Point"/>
				<c path="Array"><c path="neash.display.DisplayObject"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetObjectsUnderPoint>
		<nmeGetChildIndex set="method" line="163">
			<f a="child">
				<c path="neash.display.DisplayObject"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetChildIndex>
		<nmeFindByID set="method" line="146" override="1">
			<f a="inID">
				<c path="Int"/>
				<c path="neash.display.DisplayObject"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeFindByID>
		<nmeBroadcast public="1" set="method" line="121" override="1">
			<f a="inEvt">
				<c path="neash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeBroadcast>
		<nmeAddChild get="inline" set="null" line="101">
			<f a="child">
				<c path="neash.display.DisplayObject"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeAddChild>
		<getObjectsUnderPoint public="1" set="method" line="93"><f a="point">
	<c path="neash.geom.Point"/>
	<c path="Array"><c path="neash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method" line="87"><f a="child">
	<c path="neash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method" line="78"><f a="name">
	<c path="String"/>
	<c path="neash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method" line="66"><f a="index">
	<c path="Int"/>
	<c path="neash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method" line="50"><f a="child">
	<c path="neash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method" line="44"><f a="point">
	<c path="neash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method" line="36"><f a="child:index">
	<c path="neash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="neash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method" line="29"><f a="child">
	<c path="neash.display.DisplayObject"/>
	<c path="neash.display.DisplayObject"/>
</f></addChild>
		<nmeChildren>
			<c path="Array"><c path="neash.display.DisplayObject"/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeChildren>
		<tabChildren public="1" get="nmeGetTabChildren" set="nmeSetTabChildren"><e path="Bool"/></tabChildren>
		<numChildren public="1" get="nmeGetNumChildren" set="null"><c path="Int"/></numChildren>
		<mouseChildren public="1" get="nmeGetMouseChildren" set="nmeSetMouseChildren"><e path="Bool"/></mouseChildren>
		<new public="1" set="method" line="22"><f a="inHandle:inType">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="neash.display.GradientType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
	</enum>
	<class path="neash.display.Graphics" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/Graphics.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="11" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="12" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="13" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="14" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="16" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_SMOOTH get="inline" set="null" line="18" static="1"><c path="Int"/></TILE_SMOOTH>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="20" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="21" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<RGBA public="1" get="inline" set="null" line="190" static="1"><f a="inRGB:?inA">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></RGBA>
		<nme_gfx_clear line="205" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gfx_clear>
		<nme_gfx_begin_fill line="206" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_begin_fill>
		<nme_gfx_begin_bitmap_fill line="207" static="1"><f a="::::">
	<d/>
	<d/>
	<c path="neash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_gfx_begin_bitmap_fill>
		<nme_gfx_line_bitmap_fill line="208" static="1"><f a="::::">
	<d/>
	<d/>
	<c path="neash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_gfx_line_bitmap_fill>
		<nme_gfx_begin_gradient_fill line="209" static="1"><f a="::::::::">
	<d/>
	<c path="Int"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="neash.geom.Matrix"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_begin_gradient_fill>
		<nme_gfx_line_gradient_fill line="210" static="1"><f a="::::::::">
	<d/>
	<c path="Int"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="neash.geom.Matrix"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_line_gradient_fill>
		<nme_gfx_end_fill line="211" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_gfx_end_fill>
		<nme_gfx_line_style line="212" static="1"><f a="::::::::">
	<d/>
	<t path="Null"><c path="Float"/></t>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_line_style>
		<nme_gfx_move_to line="213" static="1"><f a="::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_move_to>
		<nme_gfx_line_to line="214" static="1"><f a="::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_line_to>
		<nme_gfx_curve_to line="215" static="1"><f a="::::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_curve_to>
		<nme_gfx_arc_to line="216" static="1"><f a="::::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_arc_to>
		<nme_gfx_draw_ellipse line="217" static="1"><f a="::::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_draw_ellipse>
		<nme_gfx_draw_data line="218" static="1"><f a=":">
	<d/>
	<c path="Array"><d/></c>
	<unknown/>
</f></nme_gfx_draw_data>
		<nme_gfx_draw_datum line="219" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></nme_gfx_draw_datum>
		<nme_gfx_draw_rect line="220" static="1"><f a="::::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_draw_rect>
		<nme_gfx_draw_path line="221" static="1"><f a=":::">
	<d/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Float"/></c>
	<e path="Bool"/>
	<unknown/>
</f></nme_gfx_draw_path>
		<nme_gfx_draw_tiles line="222" static="1"><f a=":::">
	<d/>
	<d/>
	<c path="Array"><c path="Float"/></c>
	<c path="Int"/>
	<unknown/>
</f></nme_gfx_draw_tiles>
		<nme_gfx_draw_points line="223" static="1"><f a=":::::">
	<d/>
	<c path="Array"><c path="Float"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Float"/>
	<unknown/>
</f></nme_gfx_draw_points>
		<nme_gfx_draw_round_rect line="224" static="1"><f a="::::::">
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="Null"><c path="Float"/></t>
	<unknown/>
</f></nme_gfx_draw_round_rect>
		<nme_gfx_draw_triangles line="225" static="1"><f a=":::::::">
	<d/>
	<c path="Array"><c path="Float"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
	<c path="Array"><c path="Float"/></c>
	<unknown/>
</f></nme_gfx_draw_triangles>
		<moveTo public="1" set="method" line="184"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method" line="178"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method" line="172"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="neash.display.LineScaleMode"/>
	<e path="neash.display.CapsStyle"/>
	<e path="neash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineGradientStyle public="1" set="method" line="160"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="neash.display.GradientType"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="neash.geom.Matrix"/>
	<e path="neash.display.SpreadMethod"/>
	<e path="neash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method" line="154"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="neash.display.BitmapData"/>
	<c path="neash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></lineBitmapStyle>
		<endFill public="1" set="method" line="148"><f a=""><e path="Void"/></f></endFill>
		<drawTriangles public="1" set="method" line="141"><f a="vertices:?indices:?uvtData:?culling:?colours:?blendMode:?viewport">
	<c path="Array"><c path="Float"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Float"/></c>
	<e path="neash.display.TriangleCulling"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Void"/>
</f></drawTriangles>
		<drawTiles public="1" set="method" line="130">
			<f a="sheet:inXYID:?inSmooth:?inFlags">
				<c path="neash.display.Tilesheet"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</drawTiles>
		<drawPath public="1" set="method" line="121"><f a="commands:data:?winding">
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Float"/></c>
	<c path="String"/>
	<e path="Void"/>
</f></drawPath>
		<drawRoundRect public="1" set="method" line="116"><f a="inX:inY:inWidth:inHeight:inRadX:?inRadY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method" line="110"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawPoints public="1" set="method" line="104"><f a="inXY:?inPointRGBA:?inDefaultRGBA:?inSize">
	<c path="Array"><c path="Float"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawPoints>
		<drawGraphicsDatum public="1" set="method" line="98"><f a="graphicsDatum">
	<c path="neash.display.IGraphicsData"/>
	<e path="Void"/>
</f></drawGraphicsDatum>
		<drawGraphicsData public="1" set="method" line="87"><f a="graphicsData">
	<c path="Array"><c path="neash.display.IGraphicsData"/></c>
	<e path="Void"/>
</f></drawGraphicsData>
		<drawEllipse public="1" set="method" line="81"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method" line="75"><f a="inX:inY:inRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method" line="69"><f a="inCX:inCY:inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<clear public="1" set="method" line="63"><f a=""><e path="Void"/></f></clear>
		<beginGradientFill public="1" set="method" line="51"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="neash.display.GradientType"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="neash.geom.Matrix"/>
	<e path="neash.display.SpreadMethod"/>
	<e path="neash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method" line="45"><f a="color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method" line="39"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="neash.display.BitmapData"/>
	<c path="neash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<arcTo public="1" set="method" line="33"><f a="inCX:inCY:inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></arcTo>
		<nmeHandle>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<new public="1" set="method" line="27"><f a="inHandle">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.display.GraphicsPathWinding" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/GraphicsPathWinding.hx">
		<EVEN_ODD public="1" get="inline" set="null" line="5" static="1"><c path="String"/></EVEN_ODD>
		<NON_ZERO public="1" get="inline" set="null" line="6" static="1"><c path="String"/></NON_ZERO>
	</class>
	<class path="neash.display.IGraphicsData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/IGraphicsData.hx">
		<nmeHandle public="1">
			<d/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<new public="1" set="method" line="10"><f a="inHandle">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="neash.display.InterpolationMethod" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
	</enum>
	<enum path="neash.display.JointStyle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
	</enum>
	<enum path="neash.display.LineScaleMode" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/LineScaleMode.hx">
		<VERTICAL/>
		<OPENGL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
	</enum>
	<class path="neash.events.Event" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/Event.hx">
		<ACTIVATE public="1" line="7" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" line="8" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" line="9" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" line="10" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" line="11" static="1"><c path="String"/></CHANGE>
		<CLOSE public="1" line="12" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" line="13" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" line="14" static="1"><c path="String"/></CONNECT>
		<DEACTIVATE public="1" line="15" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" line="16" static="1"><c path="String"/></ENTER_FRAME>
		<ID3 public="1" line="17" static="1"><c path="String"/></ID3>
		<INIT public="1" line="18" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" line="19" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" line="20" static="1"><c path="String"/></OPEN>
		<REMOVED public="1" line="21" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" line="22" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" line="23" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" line="24" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" line="25" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" line="26" static="1"><c path="String"/></SELECT>
		<SOUND_COMPLETE public="1" line="27" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" line="28" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" line="29" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" line="30" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" line="31" static="1"><c path="String"/></UNLOAD>
		<nmeGetType set="method" line="120"><f a=""><c path="String"/></f></nmeGetType>
		<nmeSetTarget set="method" line="119"><f a="v">
	<d/>
	<d/>
</f></nmeSetTarget>
		<nmeGetTarget set="method" line="118"><f a=""><d/></f></nmeGetTarget>
		<nmeGetEventPhase set="method" line="117"><f a=""><c path="Int"/></f></nmeGetEventPhase>
		<nmeSetCurrentTarget set="method" line="116"><f a="v">
	<d/>
	<d/>
</f></nmeSetCurrentTarget>
		<nmeGetCurrentTarget set="method" line="115"><f a=""><d/></f></nmeGetCurrentTarget>
		<nmeGetCancelable set="method" line="114"><f a=""><e path="Bool"/></f></nmeGetCancelable>
		<nmeGetBubbles set="method" line="113"><f a=""><e path="Bool"/></f></nmeGetBubbles>
		<toString public="1" set="method" line="102"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method" line="95"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method" line="88"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<nmeSetPhase public="1" set="method" line="81">
			<f a="inPhase">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetPhase>
		<nmeGetIsCancelledNow public="1" set="method" line="75">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetIsCancelledNow>
		<nmeGetIsCancelled public="1" set="method" line="69">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetIsCancelled>
		<clone public="1" set="method" line="63"><f a=""><c path="neash.events.Event"/></f></clone>
		<nmeIsCancelledNow>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</nmeIsCancelledNow>
		<nmeIsCancelled>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</nmeIsCancelled>
		<_type>
			<c path="String"/>
			<haxe_doc>@private</haxe_doc>
		</_type>
		<_target>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</_target>
		<_eventPhase>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</_eventPhase>
		<_currentTarget>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</_currentTarget>
		<_cancelable>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</_cancelable>
		<_bubbles>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</_bubbles>
		<type public="1" get="nmeGetType" set="null"><c path="String"/></type>
		<target public="1" get="nmeGetTarget" set="nmeSetTarget"><d/></target>
		<eventPhase public="1" get="nmeGetEventPhase" set="null"><c path="Int"/></eventPhase>
		<currentTarget public="1" get="nmeGetCurrentTarget" set="nmeSetCurrentTarget"><d/></currentTarget>
		<cancelable public="1" get="nmeGetCancelable" set="null"><e path="Bool"/></cancelable>
		<bubbles public="1" get="nmeGetBubbles" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method" line="50"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.MouseEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/MouseEvent.hx">
		<extends path="neash.events.Event"/>
		<DOUBLE_CLICK public="1" line="11" static="1"><c path="String"/></DOUBLE_CLICK>
		<CLICK public="1" line="12" static="1"><c path="String"/></CLICK>
		<MIDDLE_CLICK public="1" line="13" static="1"><c path="String"/></MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" line="14" static="1"><c path="String"/></MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" line="15" static="1"><c path="String"/></MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" line="16" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" line="17" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" line="18" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" line="19" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" line="20" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" line="21" static="1"><c path="String"/></MOUSE_WHEEL>
		<RIGHT_CLICK public="1" line="22" static="1"><c path="String"/></RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" line="23" static="1"><c path="String"/></RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" line="24" static="1"><c path="String"/></RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" line="25" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" line="26" static="1"><c path="String"/></ROLL_OVER>
		<efLeftDown line="41" static="1"><c path="Int"/></efLeftDown>
		<efShiftDown line="42" static="1"><c path="Int"/></efShiftDown>
		<efCtrlDown line="43" static="1"><c path="Int"/></efCtrlDown>
		<efAltDown line="44" static="1"><c path="Int"/></efAltDown>
		<efCommandDown line="45" static="1"><c path="Int"/></efCommandDown>
		<nmeCreate public="1" set="method" line="70" static="1">
			<f a="inType:inEvent:inLocal:inTarget">
				<c path="String"/>
				<d/>
				<c path="neash.geom.Point"/>
				<c path="neash.display.InteractiveObject"/>
				<c path="neash.events.MouseEvent"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeCreate>
		<updateAfterEvent public="1" set="method" line="99"><f a=""><e path="Void"/></f></updateAfterEvent>
		<toString public="1" set="method" line="93" override="1"><f a=""><c path="String"/></f></toString>
		<nmeCreateSimilar public="1" set="method" line="81">
			<f a="inType:?related:?targ">
				<c path="String"/>
				<c path="neash.display.InteractiveObject"/>
				<c path="neash.display.InteractiveObject"/>
				<c path="neash.events.MouseEvent"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeCreateSimilar>
		<clone public="1" set="method" line="64" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<stageY public="1"><c path="Float"/></stageY>
		<stageX public="1"><c path="Float"/></stageX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="neash.display.InteractiveObject"/></relatedObject>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<delta public="1"><c path="Int"/></delta>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<commandKey public="1"><e path="Bool"/></commandKey>
		<clickCount public="1"><c path="Int"/></clickCount>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method" line="48"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta:?commandKey:?clickCount">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="neash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.TouchEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/TouchEvent.hx">
		<extends path="neash.events.MouseEvent"/>
		<TOUCH_BEGIN public="1" line="11" static="1"><c path="String"/></TOUCH_BEGIN>
		<TOUCH_END public="1" line="12" static="1"><c path="String"/></TOUCH_END>
		<TOUCH_MOVE public="1" line="13" static="1"><c path="String"/></TOUCH_MOVE>
		<TOUCH_OUT public="1" line="14" static="1"><c path="String"/></TOUCH_OUT>
		<TOUCH_OVER public="1" line="15" static="1"><c path="String"/></TOUCH_OVER>
		<TOUCH_ROLL_OUT public="1" line="16" static="1"><c path="String"/></TOUCH_ROLL_OUT>
		<TOUCH_ROLL_OVER public="1" line="17" static="1"><c path="String"/></TOUCH_ROLL_OVER>
		<TOUCH_TAP public="1" line="18" static="1"><c path="String"/></TOUCH_TAP>
		<nmeCreate public="1" set="method" line="36" static="1"><f a="inType:inEvent:inLocal:inTarget:sizeX:sizeY">
	<c path="String"/>
	<d/>
	<c path="neash.geom.Point"/>
	<c path="neash.display.InteractiveObject"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="neash.events.TouchEvent"/>
</f></nmeCreate>
		<nmeCreateSimilar public="1" set="method" line="47" override="1"><f a="inType:?related:?targ">
	<c path="String"/>
	<c path="neash.display.InteractiveObject"/>
	<c path="neash.display.InteractiveObject"/>
	<c path="neash.events.MouseEvent"/>
</f></nmeCreateSimilar>
		<sizeY public="1"><c path="Float"/></sizeY>
		<sizeX public="1"><c path="Float"/></sizeX>
		<touchPointID public="1"><c path="Int"/></touchPointID>
		<isPrimaryTouchPoint public="1"><e path="Bool"/></isPrimaryTouchPoint>
		<new public="1" set="method" line="26"><f a="type:?bubbles:?cancelable:?in_localX:?in_localY:?in_sizeX:?in_sizeY:?in_relatedObject:?in_ctrlKey:?in_altKey:?in_shiftKey:?in_buttonDown:?in_delta:?in_commandKey:?in_clickCount">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="neash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.display.Stage" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/Stage.hx">
		<extends path="neash.display.DisplayObjectContainer"/>
		<nmeEarlyWakeup public="1" line="30" static="1">
			<c path="Float"/>
			<haxe_doc>* Time, in seconds, we wake up before the frame is due.  We then do a
	 * "busy wait" to ensure the frame comes at the right time.  By increasing this number,
	 * the frame rate will be more constant, but the busy wait will take more CPU.
	 * @private</haxe_doc>
		</nmeEarlyWakeup>
		<OrientationPortrait public="1" line="32" static="1"><c path="Int"/></OrientationPortrait>
		<OrientationPortraitUpsideDown public="1" line="33" static="1"><c path="Int"/></OrientationPortraitUpsideDown>
		<OrientationLandscapeRight public="1" line="34" static="1"><c path="Int"/></OrientationLandscapeRight>
		<OrientationLandscapeLeft public="1" line="35" static="1"><c path="Int"/></OrientationLandscapeLeft>
		<OrientationFaceUp public="1" line="36" static="1"><c path="Int"/></OrientationFaceUp>
		<OrientationFaceDown public="1" line="37" static="1"><c path="Int"/></OrientationFaceDown>
		<efLeftDown line="56" static="1"><c path="Int"/></efLeftDown>
		<efShiftDown line="57" static="1"><c path="Int"/></efShiftDown>
		<efCtrlDown line="58" static="1"><c path="Int"/></efCtrlDown>
		<efAltDown line="59" static="1"><c path="Int"/></efAltDown>
		<efCommandDown line="60" static="1"><c path="Int"/></efCommandDown>
		<efLocationRight line="61" static="1"><c path="Int"/></efLocationRight>
		<efNoNativeClick line="62" static="1"><c path="Int"/></efNoNativeClick>
		<nmeMouseChanges line="63" static="1"><c path="Array"><c path="String"/></c></nmeMouseChanges>
		<nmeTouchChanges line="64" static="1"><c path="Array"><c path="String"/></c></nmeTouchChanges>
		<sClickEvents line="65" static="1"><c path="Array"><c path="String"/></c></sClickEvents>
		<sDownEvents line="66" static="1"><c path="Array"><c path="String"/></c></sDownEvents>
		<sUpEvents line="67" static="1"><c path="Array"><c path="String"/></c></sUpEvents>
		<getOrientation public="1" set="dynamic" line="109" static="1"><f a=""><c path="Int"/></f></getOrientation>
		<getNormalOrientation public="1" set="dynamic" line="114" static="1"><f a=""><c path="Int"/></f></getNormalOrientation>
		<setFixedOrientation public="1" set="method" line="740" static="1"><f a="inOrientation">
	<c path="Int"/>
	<e path="Void"/>
</f></setFixedOrientation>
		<shouldRotateInterface public="1" set="dynamic" line="747" static="1"><f a="inOrientation">
	<c path="Int"/>
	<e path="Bool"/>
</f></shouldRotateInterface>
		<nme_set_stage_handler line="883" static="1"><f a=":::">
	<d/>
	<f a="inEvent">
		<d/>
		<d/>
	</f>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_set_stage_handler>
		<nme_render_stage line="884" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_render_stage>
		<nme_stage_get_focus_id line="885" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_stage_get_focus_id>
		<nme_stage_set_focus line="886" static="1"><f a="::">
	<d/>
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></nme_stage_set_focus>
		<nme_stage_get_focus_rect line="887" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_stage_get_focus_rect>
		<nme_stage_set_focus_rect line="888" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_stage_set_focus_rect>
		<nme_stage_is_opengl line="889" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_stage_is_opengl>
		<nme_stage_get_stage_width line="890" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_stage_get_stage_width>
		<nme_stage_get_stage_height line="891" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_stage_get_stage_height>
		<nme_stage_get_dpi_scale line="892" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_stage_get_dpi_scale>
		<nme_stage_get_scale_mode line="893" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_stage_get_scale_mode>
		<nme_stage_set_scale_mode line="894" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_stage_set_scale_mode>
		<nme_stage_get_align line="895" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_stage_get_align>
		<nme_stage_set_align line="896" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_stage_set_align>
		<nme_stage_get_quality line="897" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_stage_get_quality>
		<nme_stage_set_quality line="898" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_stage_set_quality>
		<nme_stage_get_display_state line="899" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_stage_get_display_state>
		<nme_stage_set_display_state line="900" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_stage_set_display_state>
		<nme_stage_set_next_wake line="901" static="1"><f a=":">
	<d/>
	<c path="Float"/>
	<unknown/>
</f></nme_stage_set_next_wake>
		<nme_stage_request_render line="902" static="1"><unknown/></nme_stage_request_render>
		<nme_stage_show_cursor line="903" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_stage_show_cursor>
		<nme_stage_set_fixed_orientation line="904" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></nme_stage_set_fixed_orientation>
		<nme_stage_get_orientation line="905" static="1"><f a=""><c path="Int"/></f></nme_stage_get_orientation>
		<nme_stage_get_normal_orientation line="906" static="1"><f a=""><c path="Int"/></f></nme_stage_get_normal_orientation>
		<nmeGetStageWidth set="method" line="872">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetStageWidth>
		<nmeGetStageHeight set="method" line="866">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetStageHeight>
		<nmeSetStageFocusRect set="method" line="859">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetStageFocusRect>
		<nmeGetStageFocusRect set="method" line="858">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetStageFocusRect>
		<nmeSetScaleMode set="method" line="851">
			<f a="inMode">
				<e path="neash.display.StageScaleMode"/>
				<e path="neash.display.StageScaleMode"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetScaleMode>
		<nmeGetScaleMode set="method" line="844">
			<f a=""><e path="neash.display.StageScaleMode"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetScaleMode>
		<nmeSetQuality set="method" line="837">
			<f a="inQuality">
				<e path="neash.display.StageQuality"/>
				<e path="neash.display.StageQuality"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetQuality>
		<nmeGetQuality set="method" line="830">
			<f a=""><e path="neash.display.StageQuality"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetQuality>
		<nmeIsOpenGL set="method" line="824">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeIsOpenGL>
		<nmeSetFrameRate set="method" line="816">
			<f a="inRate">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetFrameRate>
		<nmeSetFocus set="method" line="806">
			<f a="inObject">
				<c path="neash.display.InteractiveObject"/>
				<c path="neash.display.InteractiveObject"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetFocus>
		<nmeGetFocus set="method" line="798">
			<f a=""><c path="neash.display.InteractiveObject"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetFocus>
		<nmeGetDPIScale set="method" line="792">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetDPIScale>
		<nmeSetDisplayState set="method" line="785">
			<f a="inState">
				<e path="neash.display.StageDisplayState"/>
				<e path="neash.display.StageDisplayState"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetDisplayState>
		<nmeGetDisplayState set="method" line="778">
			<f a=""><e path="neash.display.StageDisplayState"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetDisplayState>
		<nmeSetAlign set="method" line="771">
			<f a="inMode">
				<e path="neash.display.StageAlign"/>
				<e path="neash.display.StageAlign"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetAlign>
		<nmeGetAlign set="method" line="764">
			<f a=""><e path="neash.display.StageAlign"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetAlign>
		<showCursor public="1" set="method" line="753"><f a="inShow">
	<e path="Bool"/>
	<e path="Void"/>
</f></showCursor>
		<nmeUpdateNextWake public="1" set="method" line="724">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeUpdateNextWake>
		<nmeStopDrag public="1" set="method" line="717">
			<f a="sprite">
				<c path="neash.display.Sprite"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeStopDrag>
		<nmeStartDrag public="1" set="method" line="691">
			<f a="sprite:lockCenter:bounds">
				<c path="neash.display.Sprite"/>
				<e path="Bool"/>
				<c path="neash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeStartDrag>
		<nmeSetActive public="1" set="method" line="674">
			<f a="inActive">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetActive>
		<nmeRender public="1" set="method" line="655">
			<f a="inSendEnterFrame">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeRender>
		<nmePollTimers public="1" set="method" line="645">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmePollTimers>
		<nmeOnTouch set="method" line="606">
			<f a="inEvent:inType:touchInfo">
				<d/>
				<c path="String"/>
				<c path="neash.display.TouchInfo"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnTouch>
		<nmeOnResize set="method" line="599">
			<f a="inW:inH">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnResize>
		<nmeOnMouse set="method" line="516">
			<f a="inEvent:inType:inFromMouse">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnMouse>
		<nmeOnKey set="method" line="498">
			<f a="inEvent:inType">
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnKey>
		<nmeOnJoystick set="method" line="438">
			<f a="inEvent:inType">
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnJoystick>
		<nmeOnFocus set="method" line="414">
			<f a="inEvent">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnFocus>
		<nmeOnChange set="method" line="406">
			<f a="inEvent">
				<a><id set="null"><c path="Int"/></id></a>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnChange>
		<nmeNextFrameDue set="method" line="392">
			<f a="inOtherTimers">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeNextFrameDue>
		<nmeGetStage public="1" set="method" line="386" override="1">
			<f a=""><c path="neash.display.Stage"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetStage>
		<nmeDrag set="method" line="363">
			<f a="inMouse">
				<c path="neash.geom.Point"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeDrag>
		<nmeProcessStageEvent set="method" line="356">
			<f a="inEvent">
				<d/>
				<d/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeProcessStageEvent>
		<dummyTrace set="method" line="350"><f a=""><e path="Void"/></f></dummyTrace>
		<nmeDoProcessStageEvent set="method" line="234">
			<f a="inEvent">
				<d/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeDoProcessStageEvent>
		<nmeCheckRender set="method" line="216">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeCheckRender>
		<nmeCheckInOuts set="method" line="164">
			<f a="inEvent:inStack:?touchInfo">
				<c path="neash.events.MouseEvent"/>
				<c path="Array"><c path="neash.display.InteractiveObject"/></c>
				<c path="neash.display.TouchInfo"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeCheckInOuts>
		<nmeCheckFocusInOuts set="method" line="126">
			<f a="inEvent:inStack">
				<d/>
				<c path="Array"><c path="neash.display.InteractiveObject"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeCheckFocusInOuts>
		<invalidate public="1" set="method" line="120"><f a=""><e path="Void"/></f></invalidate>
		<nmeTouchInfo>
			<c path="IntHash"><c path="neash.display.TouchInfo"/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeTouchInfo>
		<nmeMouseOverObjects>
			<c path="Array"><c path="neash.display.InteractiveObject"/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeMouseOverObjects>
		<nmeLastRender>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</nmeLastRender>
		<nmeLastDown>
			<c path="Array"><c path="neash.display.InteractiveObject"/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeLastDown>
		<nmeLastClickTime>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</nmeLastClickTime>
		<nmeInvalid>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</nmeInvalid>
		<nmeFramePeriod>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</nmeFramePeriod>
		<nmeFocusOverObjects>
			<c path="Array"><c path="neash.display.InteractiveObject"/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeFocusOverObjects>
		<nmeDragOffsetY>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</nmeDragOffsetY>
		<nmeDragOffsetX>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</nmeDragOffsetX>
		<nmeDragObject>
			<c path="neash.display.Sprite"/>
			<haxe_doc>@private</haxe_doc>
		</nmeDragObject>
		<nmeDragBounds>
			<c path="neash.geom.Rectangle"/>
			<haxe_doc>@private</haxe_doc>
		</nmeDragBounds>
		<nmeJoyAxisData>
			<c path="IntHash"><t path="neash.display.JoyAxisData"/></c>
			<haxe_doc>@private</haxe_doc>
		</nmeJoyAxisData>
		<stageWidth public="1" get="nmeGetStageWidth" set="null"><c path="Int"/></stageWidth>
		<stageHeight public="1" get="nmeGetStageHeight" set="null"><c path="Int"/></stageHeight>
		<stageFocusRect public="1" get="nmeGetStageFocusRect" set="nmeSetStageFocusRect"><e path="Bool"/></stageFocusRect>
		<scaleMode public="1" get="nmeGetScaleMode" set="nmeSetScaleMode"><e path="neash.display.StageScaleMode"/></scaleMode>
		<renderRequest public="1"><f a=""><e path="Void"/></f></renderRequest>
		<quality public="1" get="nmeGetQuality" set="nmeSetQuality"><e path="neash.display.StageQuality"/></quality>
		<pauseWhenDeactivated public="1"><e path="Bool"/></pauseWhenDeactivated>
		<onQuit public="1"><f a=""><e path="Void"/></f></onQuit>
		<onKey public="1"><f a=":::">
	<c path="Int"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></onKey>
		<isOpenGL public="1" get="nmeIsOpenGL" set="null"><e path="Bool"/></isOpenGL>
		<frameRate public="1" set="nmeSetFrameRate"><c path="Float"/></frameRate>
		<focus public="1" get="nmeGetFocus" set="nmeSetFocus"><c path="neash.display.InteractiveObject"/></focus>
		<dpiScale public="1" get="nmeGetDPIScale" set="null"><c path="Float"/></dpiScale>
		<displayState public="1" get="nmeGetDisplayState" set="nmeSetDisplayState"><e path="neash.display.StageDisplayState"/></displayState>
		<align public="1" get="nmeGetAlign" set="nmeSetAlign"><e path="neash.display.StageAlign"/></align>
		<active public="1" set="null"><e path="Bool"/></active>
		<new public="1" set="method" line="84"><f a="inHandle:inWidth:inHeight">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.display.ManagedStage" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/ManagedStage.hx">
		<extends path="neash.display.Stage"/>
		<etUnknown public="1" get="inline" set="null" line="10" static="1"><c path="Int"/></etUnknown>
		<etKeyDown public="1" get="inline" set="null" line="11" static="1"><c path="Int"/></etKeyDown>
		<etChar public="1" get="inline" set="null" line="12" static="1"><c path="Int"/></etChar>
		<etKeyUp public="1" get="inline" set="null" line="13" static="1"><c path="Int"/></etKeyUp>
		<etMouseMove public="1" get="inline" set="null" line="14" static="1"><c path="Int"/></etMouseMove>
		<etMouseDown public="1" get="inline" set="null" line="15" static="1"><c path="Int"/></etMouseDown>
		<etMouseClick public="1" get="inline" set="null" line="16" static="1"><c path="Int"/></etMouseClick>
		<etMouseUp public="1" get="inline" set="null" line="17" static="1"><c path="Int"/></etMouseUp>
		<etResize public="1" get="inline" set="null" line="18" static="1"><c path="Int"/></etResize>
		<etPoll public="1" get="inline" set="null" line="19" static="1"><c path="Int"/></etPoll>
		<etQuit public="1" get="inline" set="null" line="20" static="1"><c path="Int"/></etQuit>
		<etFocus public="1" get="inline" set="null" line="21" static="1"><c path="Int"/></etFocus>
		<etShouldRotate public="1" get="inline" set="null" line="22" static="1"><c path="Int"/></etShouldRotate>
		<etDestroyHandler public="1" get="inline" set="null" line="23" static="1"><c path="Int"/></etDestroyHandler>
		<etRedraw public="1" get="inline" set="null" line="24" static="1"><c path="Int"/></etRedraw>
		<etTouchBegin public="1" get="inline" set="null" line="25" static="1"><c path="Int"/></etTouchBegin>
		<etTouchMove public="1" get="inline" set="null" line="26" static="1"><c path="Int"/></etTouchMove>
		<etTouchEnd public="1" get="inline" set="null" line="27" static="1"><c path="Int"/></etTouchEnd>
		<etTouchTap public="1" get="inline" set="null" line="28" static="1"><c path="Int"/></etTouchTap>
		<etChange public="1" get="inline" set="null" line="29" static="1"><c path="Int"/></etChange>
		<efLeftDown public="1" get="inline" set="null" line="30" static="1"><c path="Int"/></efLeftDown>
		<efShiftDown public="1" get="inline" set="null" line="31" static="1"><c path="Int"/></efShiftDown>
		<efCtrlDown public="1" get="inline" set="null" line="32" static="1"><c path="Int"/></efCtrlDown>
		<efAltDown public="1" get="inline" set="null" line="33" static="1"><c path="Int"/></efAltDown>
		<efCommandDown public="1" get="inline" set="null" line="34" static="1"><c path="Int"/></efCommandDown>
		<efMiddleDown public="1" get="inline" set="null" line="35" static="1"><c path="Int"/></efMiddleDown>
		<efRightDown public="1" get="inline" set="null" line="36" static="1"><c path="Int"/></efRightDown>
		<efLocationRight public="1" get="inline" set="null" line="37" static="1"><c path="Int"/></efLocationRight>
		<efPrimaryTouch public="1" get="inline" set="null" line="38" static="1"><c path="Int"/></efPrimaryTouch>
		<nme_managed_stage_create line="110" static="1"><f a="::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_managed_stage_create>
		<nme_managed_stage_pump_event line="111" static="1"><f a=":">
	<d/>
	<d/>
	<unknown/>
</f></nme_managed_stage_pump_event>
		<setNextWake public="1" set="dynamic" line="99"><f a="inDelay">
	<c path="Float"/>
	<e path="Void"/>
</f></setNextWake>
		<sendQuit public="1" set="method" line="93"><f a=""><e path="Void"/></f></sendQuit>
		<resize public="1" set="method" line="87"><f a="inWidth:inHeight">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></resize>
		<pumpEvent public="1" set="method" line="81"><f a="inEvent">
	<d/>
	<e path="Void"/>
</f></pumpEvent>
		<nmeRender public="1" set="method" line="73" override="1">
			<f a="inSendEnterFrame">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</nmeRender>
		<nmeDoProcessStageEvent set="method" line="59" override="1"><f a="inEvent">
	<d/>
	<c path="Float"/>
</f></nmeDoProcessStageEvent>
		<endRender public="1" set="dynamic" line="53"><f a=""><e path="Void"/></f></endRender>
		<beginRender public="1" set="dynamic" line="47"><f a=""><e path="Void"/></f></beginRender>
		<new public="1" set="method" line="41"><f a="inWidth:inHeight:?inFlags">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.display.Sprite" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/Sprite.hx">
		<extends path="neash.display.DisplayObjectContainer"/>
		<stopDrag public="1" set="method" line="38"><f a=""><e path="Void"/></f></stopDrag>
		<startDrag public="1" set="method" line="31"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="neash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<nmeGetType set="method" line="23">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetType>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<new public="1" set="method" line="17"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="neash.display.MovieClip" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/MovieClip.hx">
		<extends path="neash.display.Sprite"/>
		<nmeGetTotalFrames set="method" line="60">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTotalFrames>
		<nmeGetCurrentFrame set="method" line="59">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetCurrentFrame>
		<stop public="1" set="method" line="48"><f a=""><e path="Void"/></f></stop>
		<play public="1" set="method" line="42"><f a=""><e path="Void"/></f></play>
		<nmeGetType set="method" line="36" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetType>
		<gotoAndStop public="1" set="method" line="30"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method" line="24"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<mTotalFrames>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</mTotalFrames>
		<mCurrentFrame>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</mCurrentFrame>
		<totalFrames public="1" get="nmeGetTotalFrames" set="null"><c path="Int"/></totalFrames>
		<framesLoaded public="1" get="nmeGetTotalFrames" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentFrame public="1" get="nmeGetCurrentFrame" set="null"><c path="Int"/></currentFrame>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="neash.display.PixelSnapping" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
	</enum>
	<class path="neash.display.Shape" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/Shape.hx">
		<extends path="neash.display.DisplayObject"/>
		<new public="1" set="method" line="7"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="neash.display.SpreadMethod" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
	</enum>
	<typedef path="neash.display.JoyAxisData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/Stage.hx" module="neash.display.Stage"><a>
	<z><c path="Float"/></z>
	<y><c path="Float"/></y>
	<x><c path="Float"/></x>
</a></typedef>
	<class path="neash.display.TouchInfo" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/Stage.hx" module="neash.display.Stage">
		<touchOverObjects public="1"><c path="Array"><c path="neash.display.InteractiveObject"/></c></touchOverObjects>
		<new public="1" set="method" line="925"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="neash.display.StageAlign" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
	</enum>
	<enum path="neash.display.StageDisplayState" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
	</enum>
	<enum path="neash.display.StageQuality" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH/>
		<BEST/>
	</enum>
	<enum path="neash.display.StageScaleMode" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
	</enum>
	<class path="neash.display.Tilesheet" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="13" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="14" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="15" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="16" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="17" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="19" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="20" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<nme_tilesheet_create line="69" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_tilesheet_create>
		<nme_tilesheet_add_rect line="70" static="1"><f a="::">
	<d/>
	<c path="neash.geom.Rectangle"/>
	<c path="neash.geom.Point"/>
	<unknown/>
</f></nme_tilesheet_add_rect>
		<drawTiles public="1" set="method" line="58">
			<f a="graphics:tileData:?smooth:?flags">
				<c path="neash.display.Graphics"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fast method to draw a batch of tiles using a Tilesheet
	 * 
	 * The input array accepts the x, y and tile ID for each tile you wish to draw.
	 * For example, an array of [ 0, 0, 0, 10, 10, 1 ] would draw tile 0 to (0, 0) and
	 * tile 1 to (10, 10)
	 * 
	 * You can also set flags for TILE_SCALE, TILE_ROTATION, TILE_RGB and
	 * TILE_ALPHA.
	 * 
	 * Depending on which flags are active, this is the full order of the array:
	 * 
	 * [ x, y, tile ID, scale, rotation, red, green, blue, alpha, x, y ... ]
	 * 
	 * @param	graphics		The nme.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether drawn tiles should be smoothed (Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing (Default: 0)</haxe_doc>
		</drawTiles>
		<addTileRect public="1" set="method" line="33"><f a="rectangle:?centerPoint">
	<c path="neash.geom.Rectangle"/>
	<c path="neash.geom.Point"/>
	<e path="Void"/>
</f></addTileRect>
		<nmeHandle public="1">
			<d/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<nmeBitmap public="1">
			<c path="neash.display.BitmapData"/>
			<haxe_doc>@private</haxe_doc>
		</nmeBitmap>
		<new public="1" set="method" line="26"><f a="inImage">
	<c path="neash.display.BitmapData"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="neash.display.TriangleCulling" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
	</enum>
	<class path="neash.errors.Error" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/errors/Error.hx">
		<toString public="1" set="method" line="24"><f a=""><c path="String"/></f></toString>
		<getStackTrace set="method" line="18"><f a=""><c path="String"/></f></getStackTrace>
		<name>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</name>
		<message>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</message>
		<errorID>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</errorID>
		<new public="1" set="method" line="11"><f a="?inMessage:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.errors.ArgumentError" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/errors/ArgumentError.hx">
		<extends path="neash.errors.Error"/>
		<new public="1" set="method" line="4"><f a="?inMessage:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.errors.EOFError" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/errors/EOFError.hx">
		<extends path="neash.errors.Error"/>
		<new public="1" set="method" line="7"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="neash.errors.RangeError" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/errors/RangeError.hx">
		<extends path="neash.errors.Error"/>
		<new public="1" set="method" line="7"><f a="?inMessage">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.TextEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/TextEvent.hx">
		<extends path="neash.events.Event"/>
		<LINK public="1" line="7" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" line="8" static="1"><c path="String"/></TEXT_INPUT>
		<toString public="1" set="method" line="26" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="20" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<text public="1" set="null"><c path="String"/></text>
		<new public="1" set="method" line="13"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.ErrorEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/ErrorEvent.hx">
		<extends path="neash.events.TextEvent"/>
		<toString public="1" set="method" line="23" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="17" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<new public="1" set="method" line="10"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.Listener" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/EventDispatcher.hx" module="neash.events.EventDispatcher">
		<sIDs line="168" static="1"><c path="Int"/></sIDs>
		<Is public="1" set="method" line="186"><f a="inListener:inCapture">
	<t path="neash.events.Function"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></Is>
		<dispatchEvent public="1" set="method" line="180"><f a="event">
	<c path="neash.events.Event"/>
	<e path="Void"/>
</f></dispatchEvent>
		<mUseCapture public="1"><e path="Bool"/></mUseCapture>
		<mPriority public="1"><c path="Int"/></mPriority>
		<mListner public="1"><t path="neash.events.Function"/></mListner>
		<mID public="1"><c path="Int"/></mID>
		<new public="1" set="method" line="171"><f a="inListener:inUseCapture:inPriority">
	<t path="neash.events.Function"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="neash.events.ListenerList" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/EventDispatcher.hx" module="neash.events.EventDispatcher"><c path="Array"><c path="neash.utils.WeakRef"><c path="neash.events.Listener"/></c></c></typedef>
	<typedef path="neash.events.EventMap" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/EventDispatcher.hx" module="neash.events.EventDispatcher"><c path="Hash"><t path="neash.events.ListenerList"/></c></typedef>
	<class path="neash.events.EventPhase" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/EventPhase.hx">
		<CAPTURING_PHASE public="1" line="6" static="1"><c path="Int"/></CAPTURING_PHASE>
		<AT_TARGET public="1" line="7" static="1"><c path="Int"/></AT_TARGET>
		<BUBBLING_PHASE public="1" line="8" static="1"><c path="Int"/></BUBBLING_PHASE>
	</class>
	<class path="neash.events.FocusEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/FocusEvent.hx">
		<extends path="neash.events.Event"/>
		<FOCUS_IN public="1" line="10" static="1"><c path="String"/></FOCUS_IN>
		<FOCUS_OUT public="1" line="11" static="1"><c path="String"/></FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" line="12" static="1"><c path="String"/></KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" line="13" static="1"><c path="String"/></MOUSE_FOCUS_CHANGE>
		<toString public="1" set="method" line="35" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="29" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<shiftKey public="1" set="null"><e path="Bool"/></shiftKey>
		<relatedObject public="1" set="null"><c path="neash.display.InteractiveObject"/></relatedObject>
		<keyCode public="1" set="null"><c path="Int"/></keyCode>
		<new public="1" set="method" line="20"><f a="inType:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode:?direction">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="neash.display.InteractiveObject"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.HTTPStatusEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/HTTPStatusEvent.hx">
		<extends path="neash.events.Event"/>
		<HTTP_STATUS public="1" line="7" static="1"><c path="String"/></HTTP_STATUS>
		<toString public="1" set="method" line="24" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="18" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<status public="1"><c path="Int"/></status>
		<new public="1" set="method" line="11"><f a="inType:?bubbles:?cancelable:?status">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="neash.events.Function" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/IEventDispatcher.hx" module="neash.events.IEventDispatcher"><f a="">
	<d/>
	<e path="Void"/>
</f></typedef>
	<class path="neash.events.IOErrorEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/IOErrorEvent.hx">
		<extends path="neash.events.ErrorEvent"/>
		<IO_ERROR public="1" line="7" static="1"><c path="String"/></IO_ERROR>
		<toString public="1" set="method" line="22" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="16" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<new public="1" set="method" line="10"><f a="inType:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.JoystickEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/JoystickEvent.hx">
		<extends path="neash.events.Event"/>
		<AXIS_MOVE public="1" line="7" static="1"><c path="String"/></AXIS_MOVE>
		<BALL_MOVE public="1" line="8" static="1"><c path="String"/></BALL_MOVE>
		<BUTTON_DOWN public="1" line="9" static="1"><c path="String"/></BUTTON_DOWN>
		<BUTTON_UP public="1" line="10" static="1"><c path="String"/></BUTTON_UP>
		<HAT_MOVE public="1" line="11" static="1"><c path="String"/></HAT_MOVE>
		<toString public="1" set="method" line="38" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="32" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<id public="1"><c path="Int"/></id>
		<device public="1"><c path="Int"/></device>
		<new public="1" set="method" line="20"><f a="type:?bubbles:?cancelable:?device:?id:?x:?y:?z">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.KeyboardEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/KeyboardEvent.hx">
		<extends path="neash.events.Event"/>
		<KEY_DOWN public="1" line="7" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" line="8" static="1"><c path="String"/></KEY_UP>
		<toString public="1" set="method" line="42" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="36" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<keyLocation public="1"><c path="Int"/></keyLocation>
		<keyCode public="1"><c path="Int"/></keyCode>
		<commandKey public="1"><e path="Bool"/></commandKey>
		<controlKey public="1"><e path="Bool"/></controlKey>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<charCode public="1"><c path="Int"/></charCode>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method" line="20"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue:?controlKeyValue:?commandKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.ProgressEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/ProgressEvent.hx">
		<extends path="neash.events.Event"/>
		<PROGRESS public="1" get="inline" set="null" line="7" static="1"><c path="String"/></PROGRESS>
		<SOCKET_DATA public="1" get="inline" set="null" line="8" static="1"><c path="String"/></SOCKET_DATA>
		<toString public="1" set="method" line="28" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="22" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><c path="Int"/></bytesLoaded>
		<new public="1" set="method" line="14"><f a="type:?bubbles:?cancelable:?bytesLoaded:?bytesTotal">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.events.SampleDataEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/events/SampleDataEvent.hx">
		<extends path="neash.events.Event"/>
		<SAMPLE_DATA public="1" line="9" static="1"><c path="String"/></SAMPLE_DATA>
		<toString public="1" set="method" line="31" override="1"><f a=""><c path="String"/></f></toString>
		<clone public="1" set="method" line="25" override="1"><f a=""><c path="neash.events.Event"/></f></clone>
		<position public="1"><c path="Float"/></position>
		<data public="1"><c path="neash.utils.ByteArray"/></data>
		<new public="1" set="method" line="16"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.filters.BitmapFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/filters/BitmapFilter.hx">
		<clone public="1" set="method" line="16"><f a=""><c path="neash.filters.BitmapFilter"/></f></clone>
		<type>
			<c path="String"/>
			<haxe_doc>@private</haxe_doc>
		</type>
		<new public="1" set="method" line="10"><f a="inType">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.filters.DropShadowFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/filters/DropShadowFilter.hx">
		<extends path="neash.filters.BitmapFilter"/>
		<clone public="1" set="method" line="38" override="1"><f a=""><c path="neash.filters.BitmapFilter"/></f></clone>
		<strength>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</strength>
		<quality>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</quality>
		<knockout>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</knockout>
		<inner>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</inner>
		<hideObject>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</hideObject>
		<distance>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</distance>
		<color>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</color>
		<blurY>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</blurY>
		<blurX>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</blurX>
		<angle>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</angle>
		<alpha>
			<c path="Float"/>
			<haxe_doc>@private</haxe_doc>
		</alpha>
		<new public="1" set="method" line="20"><f a="?in_distance:?in_angle:?in_color:?in_alpha:?in_blurX:?in_blurY:?in_strength:?in_quality:?in_inner:?in_knockout:?in_hideObject">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.filters.GlowFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/filters/GlowFilter.hx">
		<extends path="neash.filters.DropShadowFilter"/>
		<new public="1" set="method" line="7"><f a="?in_color:?in_alpha:?in_blurX:?in_blurY:?in_strength:?in_quality:?in_inner:?in_knockout">
	<c path="Int"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.geom.ColorTransform" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/geom/ColorTransform.hx">
		<nmeSetColor set="method" line="54"><f a="value">
	<c path="Int"/>
	<c path="Int"/>
</f></nmeSetColor>
		<nmeGetColor set="method" line="48"><f a=""><c path="Int"/></f></nmeGetColor>
		<concat public="1" set="method" line="36"><f a="second">
	<c path="neash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<redOffset public="1"><c path="Float"/></redOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<color public="1" get="nmeGetColor" set="nmeSetColor"><c path="Int"/></color>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<new public="1" set="method" line="23"><f a="?inRedMultiplier:?inGreenMultiplier:?inBlueMultiplier:?inAlphaMultiplier:?inRedOffset:?inGreenOffset:?inBlueOffset:?inAlphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author	Hugh Sanderson
* @author	Russell Weir
* @todo Check concat() mirrors flash behaviour</haxe_doc>
	</class>
	<class path="neash.geom.Matrix" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/geom/Matrix.hx">
		<implements path="cpp.rtti.FieldNumericIntegerLookup"/>
		<translate public="1" set="method" line="236"><f a="inDX:inDY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<transformPoint public="1" set="method" line="230"><f a="inPos">
	<c path="neash.geom.Point"/>
	<c path="neash.geom.Point"/>
</f></transformPoint>
		<setRotation public="1" set="method" line="220"><f a="inTheta:?inScale">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setRotation>
		<scale public="1" set="method" line="207"><f a="inSX:inSY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<rotate public="1" set="method" line="181"><f a="inTheta">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<mult public="1" set="method" line="153"><f a="m">
	<c path="neash.geom.Matrix"/>
	<c path="neash.geom.Matrix"/>
</f></mult>
		<invert public="1" set="method" line="125"><f a=""><c path="neash.geom.Matrix"/></f></invert>
		<identity public="1" set="method" line="114"><f a=""><e path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method" line="108"><f a="point">
	<c path="neash.geom.Point"/>
	<c path="neash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method" line="83"><f a="in_width:in_height:?rotation:?in_tx:?in_ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method" line="73"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<concat public="1" set="method" line="56"><f a="m">
	<c path="neash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<clone public="1" set="method" line="36"><f a=""><c path="neash.geom.Matrix"/></f></clone>
		<ty public="1"><c path="Float"/></ty>
		<tx public="1"><c path="Float"/></tx>
		<d public="1"><c path="Float"/></d>
		<c public="1"><c path="Float"/></c>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<new public="1" set="method" line="25"><f a="?in_a:?in_b:?in_c:?in_d:?in_tx:?in_ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author	Hugh Sanderson
* @author	Russell Weir</haxe_doc>
	</class>
	<class path="neash.geom.Point" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/geom/Point.hx">
		<distance public="1" set="method" line="57" static="1"><f a="pt1:pt2">
	<c path="neash.geom.Point"/>
	<c path="neash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" line="71" static="1"><f a="pt1:pt2:f">
	<c path="neash.geom.Point"/>
	<c path="neash.geom.Point"/>
	<c path="Float"/>
	<c path="neash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" line="99" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="neash.geom.Point"/>
</f></polar>
		<nmeGetLength set="method" line="116">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetLength>
		<subtract public="1" set="method" line="105"><f a="v">
	<c path="neash.geom.Point"/>
	<c path="neash.geom.Point"/>
</f></subtract>
		<offset public="1" set="method" line="92"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<normalize public="1" set="method" line="77"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<equals public="1" set="method" line="65"><f a="toCompare">
	<c path="neash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<clone public="1" set="method" line="51"><f a=""><c path="neash.geom.Point"/></f></clone>
		<add public="1" set="method" line="45"><f a="v">
	<c path="neash.geom.Point"/>
	<c path="neash.geom.Point"/>
</f></add>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<length public="1" get="nmeGetLength" set="null"><c path="Float"/></length>
		<new public="1" set="method" line="38"><f a="?inX:?inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.geom.Rectangle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/geom/Rectangle.hx">
		<nmeSetTopLeft set="method" line="231">
			<f a="p">
				<c path="neash.geom.Point"/>
				<c path="neash.geom.Point"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetTopLeft>
		<nmeGetTopLeft set="method" line="230">
			<f a=""><c path="neash.geom.Point"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTopLeft>
		<nmeSetTop set="method" line="229">
			<f a="t">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetTop>
		<nmeGetTop set="method" line="228">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTop>
		<nmeSetSize set="method" line="227">
			<f a="p">
				<c path="neash.geom.Point"/>
				<c path="neash.geom.Point"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetSize>
		<nmeGetSize set="method" line="226">
			<f a=""><c path="neash.geom.Point"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetSize>
		<nmeSetRight set="method" line="225">
			<f a="r">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetRight>
		<nmeGetRight set="method" line="224">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetRight>
		<nmeSetLeft set="method" line="223">
			<f a="l">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetLeft>
		<nmeGetLeft set="method" line="222">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetLeft>
		<nmeSetBottomRight set="method" line="221">
			<f a="p">
				<c path="neash.geom.Point"/>
				<c path="neash.geom.Point"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBottomRight>
		<nmeGetBottomRight set="method" line="220">
			<f a=""><c path="neash.geom.Point"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBottomRight>
		<nmeSetBottom set="method" line="219">
			<f a="b">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBottom>
		<nmeGetBottom set="method" line="218">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBottom>
		<union public="1" set="method" line="203"><f a="toUnion">
	<c path="neash.geom.Rectangle"/>
	<c path="neash.geom.Rectangle"/>
</f></union>
		<transform public="1" set="method" line="171"><f a="m">
	<c path="neash.geom.Matrix"/>
	<c path="neash.geom.Rectangle"/>
</f></transform>
		<setEmpty public="1" set="method" line="165"><f a=""><e path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method" line="158"><f a="point">
	<c path="neash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method" line="151"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<isEmpty public="1" set="method" line="145"><f a=""><e path="Bool"/></f></isEmpty>
		<intersects public="1" set="method" line="132"><f a="toIntersect">
	<c path="neash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<intersection public="1" set="method" line="116"><f a="toIntersect">
	<c path="neash.geom.Rectangle"/>
	<c path="neash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method" line="110"><f a="point">
	<c path="neash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method" line="103"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<extendBounds public="1" set="method" line="82"><f a="r">
	<c path="neash.geom.Rectangle"/>
	<e path="Void"/>
</f></extendBounds>
		<equals public="1" set="method" line="76"><f a="toCompare">
	<c path="neash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<containsRect public="1" set="method" line="70"><f a="rect">
	<c path="neash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method" line="64"><f a="point">
	<c path="neash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method" line="58"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<clone public="1" set="method" line="52"><f a=""><c path="neash.geom.Rectangle"/></f></clone>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<topLeft public="1" get="nmeGetTopLeft" set="nmeSetTopLeft"><c path="neash.geom.Point"/></topLeft>
		<top public="1" get="nmeGetTop" set="nmeSetTop"><c path="Float"/></top>
		<size public="1" get="nmeGetTopLeft" set="nmeSetTopLeft"><c path="neash.geom.Point"/></size>
		<right public="1" get="nmeGetRight" set="nmeSetRight"><c path="Float"/></right>
		<left public="1" get="nmeGetLeft" set="nmeSetLeft"><c path="Float"/></left>
		<height public="1"><c path="Float"/></height>
		<bottomRight public="1" get="nmeGetBottomRight" set="nmeSetBottomRight"><c path="neash.geom.Point"/></bottomRight>
		<bottom public="1" get="nmeGetBottom" set="nmeSetBottom"><c path="Float"/></bottom>
		<new public="1" set="method" line="43"><f a="?inX:?inY:?inWidth:?inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.geom.Transform" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/geom/Transform.hx">
		<nmeGetPixelBounds set="method" line="36">
			<f a=""><c path="neash.geom.Rectangle"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetPixelBounds>
		<nmeSetMatrix set="method" line="35">
			<f a="inMatrix">
				<c path="neash.geom.Matrix"/>
				<c path="neash.geom.Matrix"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMatrix>
		<nmeGetMatrix set="method" line="34">
			<f a=""><c path="neash.geom.Matrix"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMatrix>
		<nmeGetConcatenatedMatrix set="method" line="33">
			<f a=""><c path="neash.geom.Matrix"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetConcatenatedMatrix>
		<nmeGetConcatenatedColorTransform set="method" line="32">
			<f a=""><c path="neash.geom.ColorTransform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetConcatenatedColorTransform>
		<nmeSetColorTransform set="method" line="31">
			<f a="inTrans">
				<c path="neash.geom.ColorTransform"/>
				<c path="neash.geom.ColorTransform"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetColorTransform>
		<nmeGetColorTransform set="method" line="30">
			<f a=""><c path="neash.geom.ColorTransform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetColorTransform>
		<nmeObj>
			<c path="neash.display.DisplayObject"/>
			<haxe_doc>@private</haxe_doc>
		</nmeObj>
		<pixelBounds public="1" get="nmeGetPixelBounds" set="null"><c path="neash.geom.Rectangle"/></pixelBounds>
		<matrix public="1" get="nmeGetMatrix" set="nmeSetMatrix"><c path="neash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" get="nmeGetConcatenatedMatrix" set="null"><c path="neash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" get="nmeGetConcatenatedColorTransform" set="null"><c path="neash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1" get="nmeGetColorTransform" set="nmeSetColorTransform"><c path="neash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method" line="19"><f a="inParent">
	<c path="neash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.media.ID3Info" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/media/ID3Info.hx">
		<year public="1"><c path="String"/></year>
		<track public="1"><c path="String"/></track>
		<songName public="1"><c path="String"/></songName>
		<genre public="1"><c path="String"/></genre>
		<comment public="1"><c path="String"/></comment>
		<artist public="1"><c path="String"/></artist>
		<album public="1"><c path="String"/></album>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="neash.media.Sound" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/media/Sound.hx">
		<extends path="neash.events.EventDispatcher"/>
		<nme_sound_from_file line="219" static="1"><f a=":">
	<c path="String"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_sound_from_file>
		<nme_sound_from_data line="220" static="1"><f a="::">
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<e path="Bool"/>
	<unknown/>
</f></nme_sound_from_data>
		<nme_sound_get_id3 line="221" static="1"><f a=":">
	<d/>
	<c path="neash.media.ID3Info"/>
	<unknown/>
</f></nme_sound_get_id3>
		<nme_sound_get_length line="222" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_sound_get_length>
		<nme_sound_close line="223" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_sound_close>
		<nme_sound_get_status line="224" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_sound_get_status>
		<nme_sound_channel_create_dynamic line="225" static="1"><f a=":">
	<c path="neash.utils.ByteArray"/>
	<c path="neash.media.SoundTransform"/>
	<unknown/>
</f></nme_sound_channel_create_dynamic>
		<nmeGetLength set="method" line="206">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetLength>
		<nmeGetIsBuffering set="method" line="199">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetIsBuffering>
		<nmeGetID3 set="method" line="188">
			<f a=""><c path="neash.media.ID3Info"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetID3>
		<play public="1" set="method" line="157"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="neash.media.SoundTransform"/>
	<c path="neash.media.SoundChannel"/>
</f></play>
		<nmeOnError set="method" line="149">
			<f a="msg">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnError>
		<nmeCheckLoading set="method" line="130">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeCheckLoading>
		<loadPCMFromByteArray public="1" set="method" line="89"><f a="Bytes:samples:?format:?stereo:?sampleRate">
	<t path="nme.utils.ByteArray"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Float"/>
	<e path="Void"/>
</f></loadPCMFromByteArray>
		<loadCompressedDataFromByteArray public="1" set="method" line="80"><f a="bytes:length:?forcePlayAsMusic">
	<t path="nme.utils.ByteArray"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></loadCompressedDataFromByteArray>
		<load public="1" set="method" line="63"><f a="stream:?context:?forcePlayAsMusic">
	<c path="neash.net.URLRequest"/>
	<c path="neash.media.SoundLoaderContext"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method" line="54"><f a=""><e path="Void"/></f></close>
		<addEventListener public="1" set="method" line="40" override="1"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<t path="neash.events.Function"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<nmeDynamicSound>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</nmeDynamicSound>
		<nmeLoading>
			<e path="Bool"/>
			<haxe_doc>@private</haxe_doc>
		</nmeLoading>
		<nmeHandle>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<url public="1" set="null"><c path="String"/></url>
		<length public="1" get="nmeGetLength" set="null"><c path="Float"/></length>
		<isBuffering public="1" get="nmeGetIsBuffering" set="null"><e path="Bool"/></isBuffering>
		<id3 public="1" get="nmeGetID3" set="null"><c path="neash.media.ID3Info"/></id3>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><c path="Int"/></bytesLoaded>
		<new public="1" set="method" line="30"><f a="?stream:?context:?forcePlayAsMusic">
	<c path="neash.net.URLRequest"/>
	<c path="neash.media.SoundLoaderContext"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.media.SoundChannel" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/media/SoundChannel.hx">
		<extends path="neash.events.EventDispatcher"/>
		<nmeDynamicSoundCount public="1" line="18" static="1"><c path="Int"/></nmeDynamicSoundCount>
		<nmeIncompleteList line="20" static="1"><c path="Array"><c path="neash.media.SoundChannel"/></c></nmeIncompleteList>
		<createDynamic public="1" set="method" line="42" static="1"><f a="inSoundHandle:sndTransform:dataProvider">
	<d/>
	<c path="neash.media.SoundTransform"/>
	<c path="neash.events.EventDispatcher"/>
	<c path="neash.media.SoundChannel"/>
</f></createDynamic>
		<nmeCompletePending public="1" set="method" line="83" static="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeCompletePending>
		<nmePollComplete public="1" set="method" line="89" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmePollComplete>
		<nme_sound_channel_is_complete line="149" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_sound_channel_is_complete>
		<nme_sound_channel_get_left line="150" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_sound_channel_get_left>
		<nme_sound_channel_get_right line="151" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_sound_channel_get_right>
		<nme_sound_channel_get_position line="152" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_sound_channel_get_position>
		<nme_sound_channel_get_data_position line="153" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_sound_channel_get_data_position>
		<nme_sound_channel_stop line="154" static="1"><f a="">
	<d/>
	<unknown/>
</f></nme_sound_channel_stop>
		<nme_sound_channel_create line="155" static="1"><f a=":::">
	<d/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="neash.media.SoundTransform"/>
	<unknown/>
</f></nme_sound_channel_create>
		<nme_sound_channel_set_transform line="156" static="1"><f a=":">
	<d/>
	<c path="neash.media.SoundTransform"/>
	<unknown/>
</f></nme_sound_channel_set_transform>
		<nme_sound_channel_needs_data line="157" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_sound_channel_needs_data>
		<nme_sound_channel_add_data line="158" static="1"><f a=":">
	<d/>
	<c path="neash.utils.ByteArray"/>
	<unknown/>
</f></nme_sound_channel_add_data>
		<nmeSetTransform set="method" line="135">
			<f a="inTransform">
				<c path="neash.media.SoundTransform"/>
				<c path="neash.media.SoundTransform"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetTransform>
		<nmeGetTransform set="method" line="124">
			<f a=""><c path="neash.media.SoundTransform"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTransform>
		<nmeGetPosition set="method" line="121">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetPosition>
		<nmeGetRight set="method" line="120">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetRight>
		<nmeGetLeft set="method" line="119">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetLeft>
		<stop public="1" set="method" line="108"><f a=""><e path="Void"/></f></stop>
		<nmeCheckComplete set="method" line="55">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeCheckComplete>
		<nmeDataProvider public="1">
			<c path="neash.events.EventDispatcher"/>
			<haxe_doc>@private</haxe_doc>
		</nmeDataProvider>
		<nmeTransform>
			<c path="neash.media.SoundTransform"/>
			<haxe_doc>@private</haxe_doc>
		</nmeTransform>
		<nmeHandle>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<soundTransform public="1" get="nmeGetTransform" set="nmeSetTransform"><c path="neash.media.SoundTransform"/></soundTransform>
		<position public="1" get="nmeGetPosition" set="null"><c path="Float"/></position>
		<rightPeak public="1" get="nmeGetRight" set="null"><c path="Float"/></rightPeak>
		<leftPeak public="1" get="nmeGetLeft" set="null"><c path="Float"/></leftPeak>
		<new public="1" set="method" line="27"><f a="inSoundHandle:startTime:loops:sndTransform">
	<d/>
	<c path="Float"/>
	<c path="Int"/>
	<c path="neash.media.SoundTransform"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.media.SoundLoaderContext" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/media/SoundLoaderContext.hx"><new public="1" set="method" line="7"><f a=""><e path="Void"/></f></new></class>
	<class path="neash.media.SoundTransform" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/media/SoundTransform.hx">
		<clone public="1" set="method" line="18"><f a=""><c path="neash.media.SoundTransform"/></f></clone>
		<volume public="1"><c path="Float"/></volume>
		<pan public="1"><c path="Float"/></pan>
		<new public="1" set="method" line="11"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.net.URLLoader" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/net/URLLoader.hx">
		<extends path="neash.events.EventDispatcher"/>
		<activeLoaders line="38" static="1">
			<c path="List"><c path="neash.net.URLLoader"/></c>
			<haxe_doc>@private</haxe_doc>
		</activeLoaders>
		<urlInvalid get="inline" set="null" line="39" static="1"><c path="Int"/></urlInvalid>
		<urlInit get="inline" set="null" line="40" static="1"><c path="Int"/></urlInit>
		<urlLoading get="inline" set="null" line="41" static="1"><c path="Int"/></urlLoading>
		<urlComplete get="inline" set="null" line="42" static="1"><c path="Int"/></urlComplete>
		<urlError get="inline" set="null" line="43" static="1"><c path="Int"/></urlError>
		<hasActive public="1" set="method" line="66" static="1"><f a=""><e path="Bool"/></f></hasActive>
		<initialize public="1" set="method" line="70" static="1"><f a="inCACertFilePath">
	<c path="String"/>
	<e path="Void"/>
</f></initialize>
		<nmeLoadPending public="1" set="method" line="118" static="1">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeLoadPending>
		<nmePollData public="1" set="method" line="122" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmePollData>
		<nme_curl_create line="189" static="1"><f a="">
	<c path="neash.net.URLRequest"/>
	<unknown/>
</f></nme_curl_create>
		<nme_curl_process_loaders line="190" static="1"><f a=""><unknown/></f></nme_curl_process_loaders>
		<nme_curl_update_loader line="191" static="1"><f a=":">
	<d/>
	<c path="neash.net.URLLoader"/>
	<unknown/>
</f></nme_curl_update_loader>
		<nme_curl_get_code line="192" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_curl_get_code>
		<nme_curl_get_error_message line="193" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></nme_curl_get_error_message>
		<nme_curl_get_data line="194" static="1"><f a="">
	<d/>
	<c path="neash.utils.ByteArray"/>
</f></nme_curl_get_data>
		<nme_curl_get_cookies line="195" static="1"><f a="">
	<d/>
	<c path="Array"><c path="String"/></c>
</f></nme_curl_get_cookies>
		<nme_curl_initialize line="196" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></nme_curl_initialize>
		<update set="method" line="144">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</update>
		<dispatchHTTPStatus set="method" line="140">
			<f a="code">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</dispatchHTTPStatus>
		<onError set="method" line="135">
			<f a="msg">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</onError>
		<nmeDataComplete set="method" line="106">
			<f a=""><e path="Void"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeDataComplete>
		<load public="1" set="method" line="74"><f a="request">
	<c path="neash.net.URLRequest"/>
	<e path="Void"/>
</f></load>
		<getCookies public="1" set="method" line="62"><f a=""><c path="Array"><c path="String"/></c></f></getCookies>
		<close public="1" set="method" line="60"><f a=""><e path="Void"/></f></close>
		<nmeOnComplete public="1">
			<f a="">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeOnComplete>
		<state>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</state>
		<nmeHandle>
			<d/>
			<haxe_doc>@private</haxe_doc>
		</nmeHandle>
		<dataFormat public="1"><e path="neash.net.URLLoaderDataFormat"/></dataFormat>
		<data public="1"><d/></data>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><c path="Int"/></bytesLoaded>
		<new public="1" set="method" line="49"><f a="?request">
	<c path="neash.net.URLRequest"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author   Hugh Sanderson
* @author   Niel Drummond
* @author   Russell Weir
* @author   Joshua Harlan Lifton
* @todo open event
* @todo Complete Variables type</haxe_doc>
	</class>
	<enum path="neash.net.URLLoaderDataFormat" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/net/URLLoaderDataFormat.hx">
		<VARIABLES/>
		<TEXT/>
		<BINARY/>
	</enum>
	<class path="neash.net.URLRequest" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/net/URLRequest.hx">
		<AUTH_BASIC public="1" get="inline" set="null" line="9" static="1"><c path="Int"/></AUTH_BASIC>
		<AUTH_DIGEST public="1" get="inline" set="null" line="10" static="1"><c path="Int"/></AUTH_DIGEST>
		<AUTH_GSSNEGOTIATE public="1" get="inline" set="null" line="11" static="1"><c path="Int"/></AUTH_GSSNEGOTIATE>
		<AUTH_NTLM public="1" get="inline" set="null" line="12" static="1"><c path="Int"/></AUTH_NTLM>
		<AUTH_DIGEST_IE public="1" get="inline" set="null" line="13" static="1"><c path="Int"/></AUTH_DIGEST_IE>
		<AUTH_DIGEST_ANY public="1" get="inline" set="null" line="14" static="1"><c path="Int"/></AUTH_DIGEST_ANY>
		<nmePrepare public="1" set="method" line="54"><f a=""><e path="Void"/></f></nmePrepare>
		<digestAuth public="1" set="method" line="49"><f a="inUser:inPasswd">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></digestAuth>
		<basicAuth public="1" set="method" line="44"><f a="inUser:inPasswd">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></basicAuth>
		<nmeBytes public="1">
			<c path="neash.utils.ByteArray"/>
			<haxe_doc>* @private</haxe_doc>
		</nmeBytes>
		<credentials public="1"><c path="String"/></credentials>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<method public="1"><c path="String"/></method>
		<verbose public="1"><e path="Bool"/></verbose>
		<cookieString public="1"><c path="String"/></cookieString>
		<authType public="1"><c path="Int"/></authType>
		<requestHeaders public="1"><c path="Array"><c path="neash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method" line="31"><f a="?inURL">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.net.URLRequestHeader" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/net/URLRequestHeader.hx">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="8"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.net.URLRequestMethod" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/net/URLRequestMethod.hx">
		<DELETE public="1" get="inline" set="null" line="6" static="1"><c path="String"/></DELETE>
		<GET public="1" get="inline" set="null" line="7" static="1"><c path="String"/></GET>
		<HEAD public="1" get="inline" set="null" line="8" static="1"><c path="String"/></HEAD>
		<OPTIONS public="1" get="inline" set="null" line="9" static="1"><c path="String"/></OPTIONS>
		<POST public="1" get="inline" set="null" line="10" static="1"><c path="String"/></POST>
		<PUT public="1" get="inline" set="null" line="11" static="1"><c path="String"/></PUT>
	</class>
	<class path="neash.net.URLVariables" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/net/URLVariables.hx">
		<toString public="1" set="method" line="29"><f a=""><c path="String"/></f></toString>
		<decode public="1" set="method" line="12"><f a="inVars">
	<c path="String"/>
	<e path="Void"/>
</f></decode>
		<new public="1" set="method" line="6"><f a="?inEncoded">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="neash.text.AntiAliasType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
	</enum>
	<class path="neash.text.Font" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/Font.hx">
		<load public="1" set="method" line="24" static="1"><f a="inFilename">
	<c path="String"/>
	<t path="neash.text.NativeFontData"/>
</f></load>
		<freetype_import_font line="41" static="1"><f a="::">
	<c path="String"/>
	<unknown/>
	<c path="Int"/>
	<t path="neash.text.NativeFontData"/>
</f></freetype_import_font>
		<fontType public="1" set="null"><e path="neash.text.FontType"/></fontType>
		<fontStyle public="1" set="null"><e path="neash.text.FontStyle"/></fontStyle>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<new public="1" set="method" line="16"><f a="inFilename">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="neash.text.NativeFontData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/Font.hx" module="neash.text.Font"><a>
	<style_name><c path="String"/></style_name>
	<num_glyphs><c path="Int"/></num_glyphs>
	<kerning><c path="Array"><t path="neash.text.NativeKerningData"/></c></kerning>
	<is_italic><e path="Bool"/></is_italic>
	<is_fixed_width><e path="Bool"/></is_fixed_width>
	<is_bold><e path="Bool"/></is_bold>
	<height><c path="Int"/></height>
	<has_kerning><e path="Bool"/></has_kerning>
	<has_glyph_names><e path="Bool"/></has_glyph_names>
	<glyphs><c path="Array"><t path="neash.text.NativeGlyphData"/></c></glyphs>
	<family_name><c path="String"/></family_name>
	<em_size><c path="Int"/></em_size>
	<descend><c path="Int"/></descend>
	<ascend><c path="Int"/></ascend>
</a></typedef>
	<typedef path="neash.text.NativeGlyphData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/Font.hx" module="neash.text.Font"><a>
	<points><c path="Array"><c path="Int"/></c></points>
	<min_y><c path="Int"/></min_y>
	<min_x><c path="Int"/></min_x>
	<max_y><c path="Int"/></max_y>
	<max_x><c path="Int"/></max_x>
	<char_code><c path="Int"/></char_code>
	<advance><c path="Int"/></advance>
</a></typedef>
	<typedef path="neash.text.NativeKerningData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/Font.hx" module="neash.text.Font"><a>
	<y><c path="Int"/></y>
	<x><c path="Int"/></x>
	<right_glyph><c path="Int"/></right_glyph>
	<left_glyph><c path="Int"/></left_glyph>
</a></typedef>
	<enum path="neash.text.FontStyle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="neash.text.FontType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="neash.text.TextField" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/TextField.hx">
		<extends path="neash.display.InteractiveObject"/>
		<nme_text_field_create line="128" static="1"><f a=""><unknown/></f></nme_text_field_create>
		<nme_text_field_get_text line="129" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></nme_text_field_get_text>
		<nme_text_field_set_text line="130" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></nme_text_field_set_text>
		<nme_text_field_get_html_text line="131" static="1"><f a="">
	<d/>
	<c path="String"/>
</f></nme_text_field_get_html_text>
		<nme_text_field_set_html_text line="132" static="1"><f a=":">
	<d/>
	<c path="String"/>
	<unknown/>
</f></nme_text_field_set_html_text>
		<nme_text_field_get_text_color line="133" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_text_color>
		<nme_text_field_set_text_color line="134" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_text_color>
		<nme_text_field_get_selectable line="135" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_text_field_get_selectable>
		<nme_text_field_set_selectable line="136" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_text_field_set_selectable>
		<nme_text_field_get_display_as_password line="137" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_text_field_get_display_as_password>
		<nme_text_field_set_display_as_password line="138" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_text_field_set_display_as_password>
		<nme_text_field_get_def_text_format line="139" static="1"><f a=":">
	<d/>
	<c path="neash.text.TextFormat"/>
	<unknown/>
</f></nme_text_field_get_def_text_format>
		<nme_text_field_set_def_text_format line="140" static="1"><f a=":">
	<d/>
	<c path="neash.text.TextFormat"/>
	<unknown/>
</f></nme_text_field_set_def_text_format>
		<nme_text_field_get_auto_size line="141" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_auto_size>
		<nme_text_field_set_auto_size line="142" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_auto_size>
		<nme_text_field_get_type line="143" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_text_field_get_type>
		<nme_text_field_set_type line="144" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_text_field_set_type>
		<nme_text_field_get_multiline line="145" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_text_field_get_multiline>
		<nme_text_field_set_multiline line="146" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_text_field_set_multiline>
		<nme_text_field_get_word_wrap line="147" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_text_field_get_word_wrap>
		<nme_text_field_set_word_wrap line="148" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_text_field_set_word_wrap>
		<nme_text_field_get_border line="149" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_text_field_get_border>
		<nme_text_field_set_border line="150" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_text_field_set_border>
		<nme_text_field_get_border_color line="151" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_border_color>
		<nme_text_field_set_border_color line="152" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_border_color>
		<nme_text_field_get_background line="153" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></nme_text_field_get_background>
		<nme_text_field_set_background line="154" static="1"><f a=":">
	<d/>
	<e path="Bool"/>
	<unknown/>
</f></nme_text_field_set_background>
		<nme_text_field_get_background_color line="155" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_background_color>
		<nme_text_field_set_background_color line="156" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_background_color>
		<nme_text_field_get_text_width line="157" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_text_field_get_text_width>
		<nme_text_field_get_text_height line="158" static="1"><f a="">
	<d/>
	<c path="Float"/>
</f></nme_text_field_get_text_height>
		<nme_text_field_set_text_format line="159" static="1"><f a=":::">
	<d/>
	<c path="neash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_text_format>
		<nme_text_field_get_max_scroll_v line="160" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_max_scroll_v>
		<nme_text_field_get_max_scroll_h line="161" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_max_scroll_h>
		<nme_text_field_get_bottom_scroll_v line="162" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_bottom_scroll_v>
		<nme_text_field_get_scroll_h line="163" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_scroll_h>
		<nme_text_field_set_scroll_h line="164" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_scroll_h>
		<nme_text_field_get_scroll_v line="165" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_scroll_v>
		<nme_text_field_set_scroll_v line="166" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_scroll_v>
		<nme_text_field_get_num_lines line="167" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_num_lines>
		<nme_text_field_get_max_chars line="168" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></nme_text_field_get_max_chars>
		<nme_text_field_set_max_chars line="169" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></nme_text_field_set_max_chars>
		<nme_text_field_get_line_text line="170" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="String"/>
</f></nme_text_field_get_line_text>
		<nme_text_field_get_line_offset line="171" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
</f></nme_text_field_get_line_offset>
		<nmeSetWordWrap set="method" line="120">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetWordWrap>
		<nmeGetWordWrap set="method" line="119">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetWordWrap>
		<nmeSetType set="method" line="118">
			<f a="inType">
				<e path="neash.text.TextFieldType"/>
				<e path="neash.text.TextFieldType"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetType>
		<nmeGetType set="method" line="117">
			<f a=""><e path="neash.text.TextFieldType"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetType>
		<nmeGetTextHeight set="method" line="116">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTextHeight>
		<nmeGetTextWidth set="method" line="115">
			<f a=""><c path="Float"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTextWidth>
		<nmeSetTextColor set="method" line="114">
			<f a="inCol">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetTextColor>
		<nmeGetTextColor set="method" line="113">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetTextColor>
		<nmeSetText set="method" line="112">
			<f a="inText">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetText>
		<nmeGetText set="method" line="111">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetText>
		<nmeSetSelectable set="method" line="110">
			<f a="inSel">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetSelectable>
		<nmeGetSelectable set="method" line="109">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetSelectable>
		<nmeSetScrollV set="method" line="108">
			<f a="inVal">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetScrollV>
		<nmeGetScrollV set="method" line="107">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetScrollV>
		<nmeSetScrollH set="method" line="106">
			<f a="inVal">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetScrollH>
		<nmeGetScrollH set="method" line="105">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetScrollH>
		<nmeGetNumLines set="method" line="104">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetNumLines>
		<nmeSetMultiline set="method" line="103">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMultiline>
		<nmeGetMultiline set="method" line="102">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMultiline>
		<nmeGetMaxScrollV set="method" line="101">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMaxScrollV>
		<nmeGetMaxScrollH set="method" line="100">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMaxScrollH>
		<nmeSetMaxChars set="method" line="99">
			<f a="inVal">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetMaxChars>
		<nmeGetMaxChars set="method" line="98">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetMaxChars>
		<nmeSetHTMLText set="method" line="97">
			<f a="inText">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetHTMLText>
		<nmeGetHTMLText set="method" line="96">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetHTMLText>
		<nmeSetEmbedFonts set="method" line="95">
			<f a="value">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetEmbedFonts>
		<nmeGetEmbedFonts set="method" line="94">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetEmbedFonts>
		<nmeSetDisplayAsPassword set="method" line="93">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetDisplayAsPassword>
		<nmeGetDisplayAsPassword set="method" line="92">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetDisplayAsPassword>
		<nmeSetDefaultTextFormat set="method" line="91">
			<f a="inFormat">
				<c path="neash.text.TextFormat"/>
				<c path="neash.text.TextFormat"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetDefaultTextFormat>
		<nmeGetDefaultTextFormat set="method" line="90">
			<f a=""><c path="neash.text.TextFormat"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetDefaultTextFormat>
		<nmeGetBottomScrollV set="method" line="89">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBottomScrollV>
		<nmeSetBorderColor set="method" line="88">
			<f a="inVal">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBorderColor>
		<nmeGetBorderColor set="method" line="87">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBorderColor>
		<nmeSetBorder set="method" line="86">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBorder>
		<nmeGetBorder set="method" line="85">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBorder>
		<nmeSetBackgroundColor set="method" line="84">
			<f a="inVal">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBackgroundColor>
		<nmeGetBackgroundColor set="method" line="83">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBackgroundColor>
		<nmeSetBackground set="method" line="82">
			<f a="inVal">
				<e path="Bool"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetBackground>
		<nmeGetBackground set="method" line="81">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBackground>
		<nmeSetAutoSize set="method" line="80">
			<f a="inVal">
				<e path="neash.text.TextFieldAutoSize"/>
				<e path="neash.text.TextFieldAutoSize"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetAutoSize>
		<nmeGetAutoSize set="method" line="79">
			<f a=""><e path="neash.text.TextFieldAutoSize"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetAutoSize>
		<getLineText public="1" set="method" line="69"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method" line="64"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<setTextFormat public="1" set="method" line="59"><f a="format:?beginIndex:?endIndex">
	<c path="neash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method" line="52"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<appendText public="1" set="method" line="46"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<wordWrap public="1" get="nmeGetWordWrap" set="nmeSetWordWrap"><e path="Bool"/></wordWrap>
		<type public="1" get="nmeGetType" set="nmeSetType"><e path="neash.text.TextFieldType"/></type>
		<textWidth public="1" get="nmeGetTextWidth" set="null"><c path="Float"/></textWidth>
		<textHeight public="1" get="nmeGetTextHeight" set="null"><c path="Float"/></textHeight>
		<textColor public="1" get="nmeGetTextColor" set="nmeSetTextColor"><c path="Int"/></textColor>
		<text public="1" get="nmeGetText" set="nmeSetText"><c path="String"/></text>
		<selectable public="1" get="nmeGetSelectable" set="nmeSetSelectable"><e path="Bool"/></selectable>
		<scrollV public="1" get="nmeGetScrollV" set="nmeSetScrollV"><c path="Int"/></scrollV>
		<scrollH public="1" get="nmeGetScrollH" set="nmeSetScrollH"><c path="Int"/></scrollH>
		<numLines public="1" get="nmeGetNumLines" set="null"><c path="Int"/></numLines>
		<multiline public="1" get="nmeGetMultiline" set="nmeSetMultiline"><e path="Bool"/></multiline>
		<maxScrollV public="1" get="nmeGetMaxScrollV" set="null"><c path="Int"/></maxScrollV>
		<maxScrollH public="1" get="nmeGetMaxScrollH" set="null"><c path="Int"/></maxScrollH>
		<maxChars public="1" get="nmeGetMaxChars" set="nmeSetMaxChars"><c path="Int"/></maxChars>
		<htmlText public="1" get="nmeGetHTMLText" set="nmeSetHTMLText"><c path="String"/></htmlText>
		<embedFonts public="1" get="nmeGetEmbedFonts" set="nmeSetEmbedFonts"><e path="Bool"/></embedFonts>
		<displayAsPassword public="1" get="nmeGetDisplayAsPassword" set="nmeSetDisplayAsPassword"><e path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1" get="nmeGetDefaultTextFormat" set="nmeSetDefaultTextFormat"><c path="neash.text.TextFormat"/></defaultTextFormat>
		<bottomScrollV public="1" get="nmeGetBottomScrollV" set="null"><c path="Int"/></bottomScrollV>
		<borderColor public="1" get="nmeGetBorderColor" set="nmeSetBorderColor"><c path="Int"/></borderColor>
		<border public="1" get="nmeGetBorder" set="nmeSetBorder"><e path="Bool"/></border>
		<backgroundColor public="1" get="nmeGetBackgroundColor" set="nmeSetBackgroundColor"><c path="Int"/></backgroundColor>
		<background public="1" get="nmeGetBackground" set="nmeSetBackground"><e path="Bool"/></background>
		<autoSize public="1" get="nmeGetAutoSize" set="nmeSetAutoSize"><e path="neash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="neash.text.AntiAliasType"/></antiAliasType>
		<new public="1" set="method" line="39"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="neash.text.TextFieldAutoSize" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
	</enum>
	<enum path="neash.text.TextFieldType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
	</enum>
	<class path="neash.text.TextFormat" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/text/TextFormat.hx">
		<url public="1"><c path="String"/></url>
		<underline public="1"><d/></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><c path="Int"/></c></tabStops>
		<size public="1"><d/></size>
		<rightMargin public="1"><d/></rightMargin>
		<letterSpacing public="1"><d/></letterSpacing>
		<leftMargin public="1"><d/></leftMargin>
		<leading public="1"><d/></leading>
		<kerning public="1"><d/></kerning>
		<italic public="1"><d/></italic>
		<indent public="1"><d/></indent>
		<font public="1"><t path="Null"><c path="String"/></t></font>
		<display public="1"><t path="Null"><c path="String"/></t></display>
		<color public="1"><d/></color>
		<bullet public="1"><d/></bullet>
		<bold public="1"><d/></bold>
		<blockIndent public="1"><d/></blockIndent>
		<align public="1"><t path="Null"><c path="String"/></t></align>
		<new public="1" set="method" line="28"><f a="?in_font:?in_size:?in_color:?in_bold:?in_italic:?in_underline:?in_url:?in_target:?in_align:?in_leftMargin:?in_rightMargin:?in_indent:?in_leading">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.utils.IDataInput" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/utils/IDataInput.hx" interface="1">
		<nmeSetEndian public="1" set="method">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetEndian>
		<nmeGetEndian public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetEndian>
		<nmeGetBytesAvailable public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBytesAvailable>
		<readUTFBytes public="1" set="method"><f a="inLen">
	<c path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readUnsignedShort public="1" set="method"><f a=""><c path="Int"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><c path="Int"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><c path="Int"/></f></readUnsignedByte>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="outData:?inOffset:?inLen">
	<c path="neash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<endian public="1" get="nmeGetEndian" set="nmeSetEndian"><c path="String"/></endian>
		<bytesAvailable public="1" get="nmeGetBytesAvailable" set="null"><c path="Int"/></bytesAvailable>
	</class>
	<class path="neash.utils.ByteArray" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/utils/ByteArray.hx">
		<extends path="haxe.io.Bytes"/>
		<implements path="neash.utils.IDataInput"/>
		<fromBytes public="1" set="method" line="151" static="1"><f a="inBytes">
	<c path="haxe.io.Bytes"/>
	<c path="neash.utils.ByteArray"/>
</f></fromBytes>
		<readFile public="1" set="method" line="223" static="1"><f a="inString">
	<c path="String"/>
	<c path="neash.utils.ByteArray"/>
</f></readFile>
		<_double_bytes line="495" static="1">
			<f a=":">
				<c path="Float"/>
				<e path="Bool"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_double_bytes>
		<_double_of_bytes line="496" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_double_of_bytes>
		<_float_bytes line="497" static="1">
			<f a=":">
				<c path="Float"/>
				<e path="Bool"/>
				<t path="haxe.io.BytesData"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_float_bytes>
		<_float_of_bytes line="498" static="1">
			<f a=":">
				<t path="haxe.io.BytesData"/>
				<e path="Bool"/>
				<c path="Float"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</_float_of_bytes>
		<nme_byte_array_overwrite_file line="501" static="1"><f a=":">
	<c path="String"/>
	<c path="neash.utils.ByteArray"/>
	<unknown/>
</f></nme_byte_array_overwrite_file>
		<nme_byte_array_read_file line="502" static="1"><f a="">
	<c path="String"/>
	<c path="neash.utils.ByteArray"/>
</f></nme_byte_array_read_file>
		<nmeSetEndian public="1" set="method" line="487">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</nmeSetEndian>
		<nmeGetEndian public="1" set="method" line="486">
			<f a=""><c path="String"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetEndian>
		<nmeGetBytesAvailable public="1" set="method" line="485">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</nmeGetBytesAvailable>
		<writeUTFBytes public="1" set="method" line="469"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method" line="457"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUnsignedInt public="1" set="method" line="451"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeShort public="1" set="method" line="435"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeInt public="1" set="method" line="411"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method" line="400"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeFile public="1" set="method" line="393"><f a="inString">
	<c path="String"/>
	<e path="Void"/>
</f></writeFile>
		<writeDouble public="1" set="method" line="381"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method" line="371"><f a="bytes:?inOffset:?inLength">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeBytes>
		<write_uncheck get="inline" set="null" line="361">
			<f a="inByte">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</write_uncheck>
		<writeByte public="1" get="inline" set="null" line="351"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method" line="346"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method" line="328"><f a="?algorithm">
	<c path="String"/>
	<e path="Void"/>
</f></uncompress>
		<ThrowEOFi set="method" line="321">
			<f a=""><c path="Int"/></f>
			<haxe_doc>@private</haxe_doc>
		</ThrowEOFi>
		<setLength public="1" set="method" line="313"><f a="inLength">
	<c path="Int"/>
	<e path="Void"/>
</f></setLength>
		<readUTFBytes public="1" set="method" line="296"><f a="inLen">
	<c path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method" line="289"><f a=""><c path="String"/></f></readUTF>
		<readUnsignedShort public="1" set="method" line="281"><f a=""><c path="Int"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method" line="271"><f a=""><c path="Int"/></f></readUnsignedInt>
		<readUnsignedByte public="1" get="inline" set="null" line="265"><f a=""><c path="Int"/></f></readUnsignedByte>
		<readShort public="1" set="method" line="256"><f a=""><c path="Int"/></f></readShort>
		<readInt public="1" set="method" line="246"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method" line="230"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method" line="206"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method" line="184"><f a="outData:?inOffset:?inLen">
	<c path="neash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readBytes>
		<readMultiByte public="1" get="inline" set="null" line="176"><f a="inLen:charSet">
	<c path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readByte public="1" get="inline" set="null" line="170"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" get="inline" set="null" line="164"><f a=""><e path="Bool"/></f></readBoolean>
		<ensureElem set="method" line="131">
			<f a="inSize:inUpdateLenght">
				<c path="Int"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>@private</haxe_doc>
		</ensureElem>
		<compress public="1" set="method" line="114"><f a="?algorithm">
	<c path="String"/>
	<e path="Void"/>
</f></compress>
		<clear public="1" set="method" line="108"><f a=""><e path="Void"/></f></clear>
		<checkData public="1" set="method" line="102"><f a="inLength">
	<c path="Int"/>
	<e path="Void"/>
</f></checkData>
		<asString public="1" set="method" line="95"><f a=""><c path="String"/></f></asString>
		<__set public="1" get="inline" set="null" line="84"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></__set>
		<__get public="1" get="inline" set="null" line="54"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></__get>
		<position public="1"><c path="Int"/></position>
		<endian public="1" get="nmeGetEndian" set="nmeSetEndian"><c path="String"/></endian>
		<bytesAvailable public="1" get="nmeGetBytesAvailable" set="null"><c path="Int"/></bytesAvailable>
		<bigEndian public="1"><e path="Bool"/></bigEndian>
		<new public="1" set="method" line="34"><f a="?inSize">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="neash.utils.Endian" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/utils/Endian.hx">
		<BIG_ENDIAN public="1" get="inline" set="null" line="7" static="1"><c path="String"/></BIG_ENDIAN>
		<LITTLE_ENDIAN public="1" get="inline" set="null" line="8" static="1"><c path="String"/></LITTLE_ENDIAN>
	</class>
	<class path="neash.utils.WeakRef" params="T" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/neash/utils/WeakRef.hx">
		<nme_weak_ref_create line="59" static="1"><f a=":">
	<c path="neash.utils.WeakRef"><c path="neash.utils.WeakRef.T"/></c>
	<c path="neash.utils.WeakRef.T"/>
	<c path="Int"/>
</f></nme_weak_ref_create>
		<nme_weak_ref_get line="60" static="1"><f a="">
	<c path="Int"/>
	<c path="neash.utils.WeakRef.T"/>
</f></nme_weak_ref_get>
		<toString public="1" set="method" line="45"><f a=""><c path="String"/></f></toString>
		<get public="1" set="method" line="30"><f a=""><c path="neash.utils.WeakRef.T"/></f></get>
		<weakRef>
			<c path="Int"/>
			<haxe_doc>@private</haxe_doc>
		</weakRef>
		<hardRef>
			<c path="neash.utils.WeakRef.T"/>
			<haxe_doc>@private</haxe_doc>
		</hardRef>
		<new public="1" set="method" line="15"><f a="inObject:?inMakeWeak">
	<c path="neash.utils.WeakRef.T"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="nme.Assets" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/Assets.hx">
		<cachedBitmapData public="1" line="32" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<getBitmapData public="1" set="method" line="42" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<e path="Bool"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache (Default: true)
	 * @return		A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="54" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes ("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="66" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont ("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getSound public="1" set="method" line="78" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="90" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText ("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>
 * 
 * @author Joshua Granick]]></haxe_doc>
	</class>
	<class path="nme.Lib" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/Lib.hx">
		<FULLSCREEN public="1" line="13" static="1"><c path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="14" static="1"><c path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="15" static="1"><c path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="16" static="1"><c path="Int"/></HARDWARE>
		<VSYNC public="1" line="17" static="1"><c path="Int"/></VSYNC>
		<HW_AA public="1" line="18" static="1"><c path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="19" static="1"><c path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="20" static="1"><c path="Int"/></ALLOW_SHADERS>
		<company public="1" get="nmeGetCompany" set="null" static="1"><c path="String"/></company>
		<current public="1" get="nmeGetCurrent" set="null" static="1"><t path="nme.display.MovieClip"/></current>
		<file public="1" get="nmeGetFile" set="null" static="1"><c path="String"/></file>
		<initHeight public="1" get="nmeGetInitHeight" set="null" static="1"><c path="Int"/></initHeight>
		<initWidth public="1" get="nmeGetInitWidth" set="null" static="1"><c path="Int"/></initWidth>
		<packageName public="1" get="nmeGetPackageName" set="null" static="1"><c path="String"/></packageName>
		<stage public="1" get="nmeGetStage" set="null" static="1"><t path="nme.display.Stage"/></stage>
		<version public="1" get="nmeGetVersion" set="null" static="1"><c path="String"/></version>
		<close public="1" set="method" line="36" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Closes the application.
	 * This is method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</close>
		<create public="1" set="method" line="59" static="1">
			<f a="onLoaded:width:height:?frameRate:?color:?flags:?title:?icon">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Creates a new application window. If you are using the NME
	 * command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This is method is ignored in the Flash and HTML5 targets.
	 * @param	onLoaded		A method callback that is called once the window is created.
	 * @param	width		The requested width of the window. Use a width and height of 0 to request the full screen size.
	 * @param	height		The requested height of the window. Use a width and height of 0 to request the full screen size.
	 * @param	frameRate		The requested frame rate for the application.
	 * @param	color		An RGB color to use for the application background.
	 * @param	flags		A series of bit flags which can specify windowing options, like FULLSCREEN or HARDWARE
	 * @param	title		The title to use when creating the application window.
	 * @param	icon		An icon to use for the created application window.</haxe_doc>
		</create>
		<createManagedStage public="1" set="method" line="75" static="1">
			<f a="width:height">
				<c path="Int"/>
				<c path="Int"/>
				<c path="neash.display.ManagedStage"/>
			</f>
			<haxe_doc>* Creates a managed stage, for greater control customization and control
	 * of application events.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	width		The requested width of the managed stage.
	 * @param	height		The requested width of the managed stage.</haxe_doc>
		</createManagedStage>
		<exit public="1" set="method" line="91" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Similar to the <code>close()</code> method, but the current 
	 * <code>Stage</code> object is given an opportunity to handle 
	 * the quit event before the application process is ended.
	 * This method is ignored in the Flash and HTML5 targets.]]></haxe_doc>
		</exit>
		<forceClose public="1" set="method" line="105" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Terminates the application process immediately without
	 * performing a clean shutdown.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</forceClose>
		<getTimer public="1" get="inline" set="null" line="123" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Returns the time in milliseconds, relative to the start of
	 * the application. This is a high performance call in order to 
	 * help regulate time-based operations. Depending upon the
	 * target platform, this value may or may not be an absolute
	 * timestamp. If you need an exact time, you should use the
	 * <code>Date</code> object.
	 * @return		A relative time value in milliseconds.]]></haxe_doc>
		</getTimer>
		<getURL public="1" set="method" line="142" static="1">
			<f a="url:?target">
				<t path="nme.net.URLRequest"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Opens a browser window with the specified URL. 
	 * @param	url		The URL to open.
	 * @param	target		An optional window target value.</haxe_doc>
		</getURL>
		<pause public="1" set="method" line="161" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* For supported platforms, the NME application will be
	 * paused. This can help improve response times if fullscreen
	 * native UI element is being used temporarily.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</pause>
		<postUICallback public="1" set="method" line="179" static="1">
			<f a="handler">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>* For some target platforms, NME operates on a separate thread
	 * than the native application UI. In these cases, you can use this
	 * method to make thread-safe calls to the native UI.
	 * 
	 * If the platform does not require thread-safe callbacks, the 
	 * handler method will be called immediately.
	 * @param	handler		The method handler you wish to call when the UI is available.</haxe_doc>
		</postUICallback>
		<resume public="1" set="method" line="196" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resumes the NME application. For certain platforms,
	 * pausing the application can improve response times when
	 * a fullscreen native UI element is being displayed.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</resume>
		<setPackage public="1" set="method" line="215" static="1">
			<f a="company:file:packageName:version">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Specifies meta-data for the running application. If you are using 
	 * the NME command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	company		The company name for the application.
	 * @param	file		The file name for the application.
	 * @param	packageName		The package name of the application.
	 * @param	version		The version string of the application.</haxe_doc>
		</setPackage>
		<trace public="1" set="method" line="228" static="1">
			<f a="arg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sends a <code>trace</code> call for the current platform.
	 * @param	arg]]></haxe_doc>
		</trace>
		<nmeGetCompany set="method" line="247" static="1"><f a=""><c path="String"/></f></nmeGetCompany>
		<nmeGetCurrent set="method" line="257" static="1"><f a=""><t path="nme.display.MovieClip"/></f></nmeGetCurrent>
		<nmeGetFile set="method" line="271" static="1"><f a=""><c path="String"/></f></nmeGetFile>
		<nmeGetInitHeight set="method" line="281" static="1"><f a=""><c path="Int"/></f></nmeGetInitHeight>
		<nmeGetInitWidth set="method" line="291" static="1"><f a=""><c path="Int"/></f></nmeGetInitWidth>
		<nmeGetPackageName set="method" line="301" static="1"><f a=""><c path="String"/></f></nmeGetPackageName>
		<nmeGetStage set="method" line="311" static="1"><f a=""><t path="nme.display.Stage"/></f></nmeGetStage>
		<nmeGetVersion set="method" line="323" static="1"><f a=""><c path="String"/></f></nmeGetVersion>
	</class>
	<typedef path="nme.Loader" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/Loader.hx"><c path="neash.Loader"/></typedef>
	<typedef path="nme.display.BitmapData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/BitmapData.hx"><c path="neash.display.BitmapData"/></typedef>
	<typedef path="nme.display.CapsStyle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/CapsStyle.hx"><e path="neash.display.CapsStyle"/></typedef>
	<typedef path="nme.display.DisplayObject" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/DisplayObject.hx"><c path="neash.display.DisplayObject"/></typedef>
	<typedef path="nme.display.DisplayObjectContainer" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/DisplayObjectContainer.hx"><c path="neash.display.DisplayObjectContainer"/></typedef>
	<typedef path="nme.display.GradientType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/GradientType.hx"><e path="neash.display.GradientType"/></typedef>
	<typedef path="nme.display.Graphics" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Graphics.hx"><c path="neash.display.Graphics"/></typedef>
	<typedef path="nme.display.InteractiveObject" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/InteractiveObject.hx"><c path="neash.display.InteractiveObject"/></typedef>
	<typedef path="nme.display.InterpolationMethod" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/InterpolationMethod.hx"><e path="neash.display.InterpolationMethod"/></typedef>
	<typedef path="nme.display.JointStyle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/JointStyle.hx"><e path="neash.display.JointStyle"/></typedef>
	<typedef path="nme.display.MovieClip" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/MovieClip.hx"><c path="neash.display.MovieClip"/></typedef>
	<typedef path="nme.display.Shape" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Shape.hx"><c path="neash.display.Shape"/></typedef>
	<typedef path="nme.display.SpreadMethod" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/SpreadMethod.hx"><e path="neash.display.SpreadMethod"/></typedef>
	<typedef path="nme.display.Sprite" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Sprite.hx"><c path="neash.display.Sprite"/></typedef>
	<typedef path="nme.display.Stage" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Stage.hx"><c path="neash.display.Stage"/></typedef>
	<typedef path="nme.display.StageAlign" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/StageAlign.hx"><e path="neash.display.StageAlign"/></typedef>
	<typedef path="nme.display.StageScaleMode" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/StageScaleMode.hx"><e path="neash.display.StageScaleMode"/></typedef>
	<typedef path="nme.errors.Error" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/errors/Error.hx"><c path="neash.errors.Error"/></typedef>
	<typedef path="nme.events.Event" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/Event.hx"><c path="neash.events.Event"/></typedef>
	<typedef path="nme.events.FocusEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/FocusEvent.hx"><c path="neash.events.FocusEvent"/></typedef>
	<typedef path="nme.events.KeyboardEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/KeyboardEvent.hx"><c path="neash.events.KeyboardEvent"/></typedef>
	<typedef path="nme.events.MouseEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/MouseEvent.hx"><c path="neash.events.MouseEvent"/></typedef>
	<typedef path="nme.filters.BitmapFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/filters/BitmapFilter.hx"><c path="neash.filters.BitmapFilter"/></typedef>
	<typedef path="nme.filters.DropShadowFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/filters/DropShadowFilter.hx"><c path="neash.filters.DropShadowFilter"/></typedef>
	<typedef path="nme.filters.GlowFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/filters/GlowFilter.hx"><c path="neash.filters.GlowFilter"/></typedef>
	<typedef path="nme.geom.Matrix" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/geom/Matrix.hx"><c path="neash.geom.Matrix"/></typedef>
	<typedef path="nme.media.Sound" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/media/Sound.hx"><c path="neash.media.Sound"/></typedef>
	<typedef path="nme.media.SoundChannel" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/media/SoundChannel.hx"><c path="neash.media.SoundChannel"/></typedef>
	<typedef path="nme.net.URLLoader" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/net/URLLoader.hx"><c path="neash.net.URLLoader"/></typedef>
	<typedef path="nme.net.URLRequest" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/net/URLRequest.hx"><c path="neash.net.URLRequest"/></typedef>
	<typedef path="nme.text.AntiAliasType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/AntiAliasType.hx"><e path="neash.text.AntiAliasType"/></typedef>
	<typedef path="nme.text.Font" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/Font.hx"><c path="neash.text.Font"/></typedef>
	<typedef path="nme.text.TextField" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/TextField.hx"><c path="neash.text.TextField"/></typedef>
	<typedef path="nme.text.TextFieldType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/TextFieldType.hx"><e path="neash.text.TextFieldType"/></typedef>
	<typedef path="nme.text.TextFormat" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/TextFormat.hx"><c path="neash.text.TextFormat"/></typedef>
	<typedef path="nme.utils.ByteArray" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/utils/ByteArray.hx"><c path="neash.utils.ByteArray"/></typedef>
	<typedef path="nme.utils.Endian" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/utils/Endian.hx"><c path="neash.utils.Endian"/></typedef>
	<class path="org.tbyrne.collections.UniqueList" params="T" file="../../Composure/src/org/tbyrne/collections/UniqueList.hx">
		<clear public="1" set="method" line="50"><f a=""><e path="Void"/></f></clear>
		<remove public="1" set="method" line="42"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></remove>
		<containsItem public="1" set="method" line="39"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></containsItem>
		<add public="1" set="method" line="31"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></add>
		<first public="1" set="method" line="27"><f a=""><t path="Null"><c path="org.tbyrne.collections.UniqueList.T"/></t></f></first>
		<_length><c path="Int"/></_length>
		<list><c path="haxe.FastList"><c path="org.tbyrne.collections.UniqueList.T"/></c></list>
		<get_length set="method" line="18"><f a=""><c path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null"><c path="Int"/></length>
		<iterator public="1" set="method" line="14"><f a=""><t path="Iterator"><c path="org.tbyrne.collections.UniqueList.T"/></t></f></iterator>
		<new public="1" set="method" line="6"><f a="?list">
	<t path="Iterable"><c path="org.tbyrne.collections.UniqueList.T"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.logging.ILogger" params="" file="../../Composure/src/org/tbyrne/logging/ILogger.hx" interface="1">
		<log public="1" set="method"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LogMsg" params="" file="../../Composure/src/org/tbyrne/logging/LogMsg.hx">
		<toString public="1" set="method" line="24">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Used by trace when Logging hasn't been setup.</haxe_doc>
		</toString>
		<title public="1"><c path="String"/></title>
		<types public="1"><c path="Array"><c path="String"/></c></types>
		<message public="1"><c path="String"/></message>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="15"><f a="?message:?types:?title:?id">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LogType" params="" file="../../Composure/src/org/tbyrne/logging/LogMsg.hx" module="org.tbyrne.logging.LogMsg">
		<devInfo public="1" static="1"><c path="String"/></devInfo>
		<devWarning public="1" static="1"><c path="String"/></devWarning>
		<devError public="1" static="1"><c path="String"/></devError>
		<userInfo public="1" static="1"><c path="String"/></userInfo>
		<userWarning public="1" static="1"><c path="String"/></userWarning>
		<userError public="1" static="1"><c path="String"/></userError>
		<performanceWarning public="1" static="1"><c path="String"/></performanceWarning>
		<deprecationWarning public="1" static="1"><c path="String"/></deprecationWarning>
		<externalError public="1" static="1"><c path="String"/></externalError>
	</class>
	<class path="org.tbyrne.logging.LogUtils" params="" file="../../Composure/src/org/tbyrne/logging/LogUtils.hx">
		<formatMsg public="1" set="method" line="12" static="1"><f a="logMsg:addLine:infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<e path="Bool"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LoggerList" params="" file="../../Composure/src/org/tbyrne/logging/LoggerList.hx">
		<nativeTrace public="1" get="get_nativeTrace" set="null" static="1"><d/></nativeTrace>
		<get_nativeTrace set="method" line="17" static="1"><f a=""><d/></f></get_nativeTrace>
		<fallbackLogger public="1" static="1"><c path="org.tbyrne.logging.ILogger"/></fallbackLogger>
		<_inited line="26" static="1"><e path="Bool"/></_inited>
		<init set="method" line="27" static="1"><f a=""><e path="Void"/></f></init>
		<_nativeTrace static="1"><d/></_nativeTrace>
		<_loggers static="1"><c path="Hash"><c path="Array"><c path="org.tbyrne.logging.ILogger"/></c></c></_loggers>
		<defaultTypes public="1" static="1"><c path="Array"><c path="String"/></c></defaultTypes>
		<install public="1" set="method" line="41" static="1"><f a=""><e path="Void"/></f></install>
		<trace public="1" set="method" line="54" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<log public="1" set="method" line="68" static="1"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<addLogger public="1" set="method" line="94" static="1"><f a="logger:types">
	<c path="org.tbyrne.logging.ILogger"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></addLogger>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.loggers.ErrorThrowingLogger" params="" file="../../Composure/src/org/tbyrne/logging/loggers/ErrorThrowingLogger.hx">
		<implements path="org.tbyrne.logging.ILogger"/>
		<formatMsg set="method" line="22"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<log public="1" set="method" line="19"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<new public="1" set="method" line="15"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.loggers.FlashTraceLogger" params="" file="../../Composure/src/org/tbyrne/logging/loggers/FlashTraceLogger.hx">
		<implements path="org.tbyrne.logging.ILogger"/>
		<formatMsg set="method" line="32"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<log public="1" set="method" line="19"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.loggers.HaxeLogger" params="" file="../../Composure/src/org/tbyrne/logging/loggers/HaxeLogger.hx">
		<implements path="org.tbyrne.logging.ILogger"/>
		<formatMsg set="method" line="20"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<log public="1" set="method" line="17"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<new public="1" set="method" line="14"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<typedef path="sys.FileStat" params="" file="C:\Motion-Twin\haxe\std/sys/FileStat.hx">
		<a>
			<uid>
				<c path="Int"/>
				<haxe_doc>the user id for the file</haxe_doc>
			</uid>
			<size>
				<c path="Int"/>
				<haxe_doc>the size of the file</haxe_doc>
			</size>
			<rdev><c path="Int"/></rdev>
			<nlink><c path="Int"/></nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>the last modification time for the file</haxe_doc>
			</mtime>
			<mode><c path="Int"/></mode>
			<ino><c path="Int"/></ino>
			<gid><c path="Int"/></gid>
			<dev><c path="Int"/></dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>the creation time for the file</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>the last access time for the file (when enabled by the file system)</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File informations, as given by [sys.FileSystem.stat]</haxe_doc>
	</typedef>
	<enum path="sys._FileSystem.FileKind" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/FileSystem.hx" private="1" module="sys.FileSystem">
		<kother a="k"><c path="String"/></kother>
		<kfile/>
		<kdir/>
	</enum>
	<class path="sys.FileSystem" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/FileSystem.hx">
		<exists public="1" set="method" line="36" static="1">
			<f a="path">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the given file or directory exists.</haxe_doc>
		</exists>
		<rename public="1" set="method" line="40" static="1">
			<f a="path:newpath">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Rename the corresponding file or directory, allow to move it accross directories as well.</haxe_doc>
		</rename>
		<stat public="1" set="method" line="45" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<haxe_doc>Returns informations for the given file/directory.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" line="55" static="1">
			<f a="relpath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path for the given path which is relative to the current working directory.</haxe_doc>
		</fullPath>
		<kind set="method" line="59" static="1"><f a="path">
	<c path="String"/>
	<e path="sys._FileSystem.FileKind"/>
</f></kind>
		<isDirectory public="1" set="method" line="68" static="1">
			<f a="path">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the given path is a directory. Throw an exception if it does not exists or is not accesible.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" line="72" static="1">
			<f a="path">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Create the given directory. Not recursive : the parent directory must exists.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" line="77" static="1">
			<f a="path">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Delete a given file.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" line="82" static="1">
			<f a="path">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Delete a given directory.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" line="87" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Read all the files/directories stored into the given directory.</haxe_doc>
		</readDirectory>
		<sys_exists line="91" static="1"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></sys_exists>
		<file_delete line="92" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></file_delete>
		<sys_rename line="93" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></sys_rename>
		<sys_stat line="94" static="1"><f a="">
	<c path="String"/>
	<t path="sys.FileStat"/>
</f></sys_stat>
		<sys_file_type line="95" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></sys_file_type>
		<sys_create_dir line="96" static="1"><f a=":">
	<c path="String"/>
	<c path="Int"/>
	<unknown/>
</f></sys_create_dir>
		<sys_remove_dir line="97" static="1"><f a="">
	<c path="String"/>
	<unknown/>
</f></sys_remove_dir>
		<sys_read_dir line="98" static="1"><f a="">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></sys_read_dir>
		<file_full_path line="99" static="1"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></file_full_path>
		<haxe_doc>This class allows you to get informations about the files and directories.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="sys.io.File" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="30" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<saveContent public="1" set="method" line="40" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></saveContent>
		<saveBytes public="1" set="method" line="46" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></saveBytes>
		<read public="1" set="method" line="52" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileInput"/>
</f></read>
		<write public="1" set="method" line="56" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileOutput"/>
</f></write>
		<append public="1" set="method" line="60" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileOutput"/>
</f></append>
		<copy public="1" set="method" line="64" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></copy>
		<file_contents line="72" static="1"><f a="">
	<c path="String"/>
	<t path="haxe.io.BytesData"/>
</f></file_contents>
		<file_open line="73" static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<unknown/>
</f></file_open>
		<haxe_doc>API for reading and writing to files.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_eof line="77" static="1"><f a="">
	<d/>
	<e path="Bool"/>
</f></file_eof>
		<file_read line="79" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_read>
		<file_read_char line="80" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></file_read_char>
		<file_close line="82" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="83" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="84" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></file_tell>
		<eof public="1" set="method" line="73"><f a=""><e path="Bool"/></f></eof>
		<tell public="1" set="method" line="68"><f a=""><c path="Int"/></f></tell>
		<seek public="1" set="method" line="64"><f a="p:pos">
	<c path="Int"/>
	<e path="sys.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<close public="1" set="method" line="59" override="1"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="48" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="37" override="1"><f a=""><c path="Int"/></f></readByte>
		<__f><d/></__f>
		<new set="method" line="33"><f a="f">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.read] to create a [FileInput]</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="C:\Motion-Twin\haxe\std/cpp/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="62" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_close>
		<file_seek line="63" static="1"><f a="::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="64" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></file_tell>
		<file_flush line="66" static="1"><f a="">
	<d/>
	<unknown/>
</f></file_flush>
		<file_write line="67" static="1"><f a=":::">
	<d/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_write>
		<file_write_char line="68" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<unknown/>
</f></file_write_char>
		<tell public="1" set="method" line="58"><f a=""><c path="Int"/></f></tell>
		<seek public="1" set="method" line="54"><f a="p:pos">
	<c path="Int"/>
	<e path="sys.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<close public="1" set="method" line="49" override="1"><f a=""><e path="Void"/></f></close>
		<flush public="1" set="method" line="45" override="1"><f a=""><e path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="41" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="37" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<__f><d/></__f>
		<new set="method" line="33"><f a="f">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="sys.io.FileSeek" params="" file="C:\Motion-Twin\haxe\std/sys/io/FileSeek.hx">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
</haxe>