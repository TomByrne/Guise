<haxe>
	<class path="Array" params="T" file="C:\Motion-Twin\haxe\std/Array.hx" extern="1">
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<class path="Class" params="T" file="C:\Motion-Twin\haxe\std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Date" params="" file="C:\Motion-Twin\haxe\std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the week day of the date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the day of the date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the month of the date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the full year of the date.</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the seconds of the date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the minutes value of the date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the hours value of the date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new date object.</haxe_doc>
		</new>
		<haxe_doc>The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.</haxe_doc>
	</class>
	<class path="Enum" params="T" file="C:\Motion-Twin\haxe\std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="C:\Motion-Twin\haxe\std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="GraphicsComparisonTest" params="" file="../testSrc/GraphicsComparisonTest.hx">
		<main public="1" set="method" line="38" static="1"><f a=""><e path="Void"/></f></main>
		<window><c path="guise.core.GuiseItem"/></window>
		<root><c path="composure.core.ComposeRoot"/></root>
		<new public="1" set="method" line="45"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="Hash" params="T" file="C:\Motion-Twin\haxe\std/flash/_std/Hash.hx">
		<toString public="1" set="method" line="66">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="57">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="53">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntHash" params="T" file="C:\Motion-Twin\haxe\std/flash/_std/IntHash.hx">
		<toString public="1" set="method" line="65">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="52">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" set="method" line="46">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="42">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" set="method" line="38">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" set="method" line="34">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><c path="flash.utils.Dictionary"/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="C:\Motion-Twin\haxe\std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="C:\Motion-Twin\haxe\std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an [Array] from an [Iterable]</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a [List] from an [Iterable]</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to [map], but also pass an index for each item iterated.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if at least one element of the iterable is found by using the specific function.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if all elements of the iterable have the specified property defined by [f].</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>Call the function 'f' on all elements of the [Iterable] 'it'.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Return the list of elements matching the function 'f'</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional 'fold' using an [Iterable]</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>Count the number of elements in an [Iterable] having [pred] returning true.</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an iterable does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a list containing all items of 'a' followed by all items of 'b'</haxe_doc>
		</concat>
		<haxe_doc>The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.</haxe_doc>
	</class>
	<class path="LazyInst" params="" file="../../Composure/src/LazyInst.hx">
		<_metaName line="16" static="1"><c path="String"/></_metaName>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="List" params="T" file="C:\Motion-Twin\haxe\std/List.hx">
		<map public="1" params="X" set="method" line="246">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted
		by the function [f].</haxe_doc>
		</map>
		<filter public="1" set="method" line="230">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].</haxe_doc>
		</filter>
		<join public="1" set="method" line="211">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Join the element of the list by using the separator [sep].</haxe_doc>
		</join>
		<toString public="1" set="method" line="191">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Makes the list empty.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="98">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<last public="1" set="method" line="88">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of the list, or null
		if the list is empty.</haxe_doc>
		</last>
		<first public="1" set="method" line="80">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Push an element at the beginning of the list.</haxe_doc>
		</push>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the end of the list.</haxe_doc>
		</add>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
	</class>
	<class path="Math" params="" file="C:\Motion-Twin\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" set="method" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" set="method" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Reflect" params="" file="C:\Motion-Twin\haxe\std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" set="method" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="37" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" line="51" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="59" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="63" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="86" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" line="90" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" line="96" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="100" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" set="method" line="115" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" line="121" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Std" params="" file="C:\Motion-Twin\haxe\std/flash/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" get="inline" set="null" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="41" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="48" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="52" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="Void" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="Float" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<typedef path="Iterator" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\Motion-Twin\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="C:\Motion-Twin\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\Motion-Twin\haxe\std/StringBuf.hx">
		<toString public="1" get="inline" set="null" line="64">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addSub public="1" get="inline" set="null" line="56">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<addChar public="1" get="inline" set="null" line="49">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<add public="1" get="inline" set="null" line="42">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><c path="String"/></b>
		<new public="1" set="method" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
	</class>
	<class path="StringTools" params="" file="C:\Motion-Twin\haxe\std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="C:\Motion-Twin\haxe\std/flash/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="C:\Motion-Twin\haxe\std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="52" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="66" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="73" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="89" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="93" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="117" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="134" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="155" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="168" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="180" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<describe set="method" line="186" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" set="method" line="203" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="207" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="214" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="219" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="251" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="268" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="272" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="276" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="280" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<typedef path="cmtc.ds.hash.ObjectHash" params="Key:Val" file="../../Composure/src/cmtc/ds/hash/ObjectHash.hx">
		<c path="flash.utils.TypedDictionary">
			<c path="cmtc.ds.hash.ObjectHash.Key"/>
			<c path="cmtc.ds.hash.ObjectHash.Val"/>
		</c>
		<haxe_doc>* ...
 * @author waneck</haxe_doc>
	</typedef>
	<class path="composure.core.ComposeItem" params="" file="../../Composure/src/composure/core/ComposeItem.hx">
		<getRealTrait public="1" set="method" line="21" static="1"><f a="trait">
	<d/>
	<c path="composure.traits.ITrait"/>
</f></getRealTrait>
		<removeParentInjector set="method" line="301"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<addParentInjector set="method" line="297"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<onRootRemove set="method" line="288"><f a=""><e path="Void"/></f></onRootRemove>
		<onRootAdd set="method" line="281"><f a=""><e path="Void"/></f></onRootAdd>
		<onParentRemove set="method" line="271"><f a=""><e path="Void"/></f></onParentRemove>
		<onParentAdd set="method" line="261"><f a=""><e path="Void"/></f></onParentAdd>
		<removeTraitInjector set="method" line="246"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<addTraitInjector set="method" line="231"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<_removeTrait set="method" line="202"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_removeTrait>
		<removeAllTraits public="1" set="method" line="197">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all traits from this item.</haxe_doc>
		</removeAllTraits>
		<removeTraits public="1" set="method" line="189">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a list of traits from this item.
	 * @see					addTrait
	 * @param	trait		The list of traits to remove from this item.</haxe_doc>
		</removeTraits>
		<removeTrait public="1" set="method" line="181">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a trait from this item.
	 * @see					addTrait
	 * @param	trait		The trait to remove from this item.</haxe_doc>
		</removeTrait>
		<_addTrait set="method" line="148"><f a="trait">
	<d/>
	<e path="Void"/>
</f></_addTrait>
		<addTraits public="1" set="method" line="143">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds multiple traits to this item.
	 * @see					addTrait
	 * @param	traits		The traits to add to this item.</haxe_doc>
		</addTraits>
		<addTrait public="1" set="method" line="135">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a trait to this item. Any type of object can be added, but if it implements ITrait
	 * it will have access to more information about the item and it's other traits. If, for structural reasons,
	 * it is inconvenient to implement ITrait, the object can expose a method called 'getProxiedTrait()' which should
	 * return an ITrait object to operate as it's proxy regarding other traits etc.
	 * @param	trait		The trait to add to this item.</haxe_doc>
		</addTrait>
		<callForTraits public="1" params="TraitType" set="method" line="125">
			<f a="func:?TraitType">
				<f a=":">
					<c path="composure.core.ComposeItem"/>
					<c path="callForTraits.TraitType"/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="callForTraits.TraitType"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Calls a function once for each trait that matches a certain type. The ComposeItem and
	 * trait are passed through as arguments. A function should have a signature like:<br/>
	 * <code>
	 * function myTraitFunction(item:ComposeItem, trait:ITrait):Void;
	 * </code>
	 * @param	func		The function to call.
	 * @param	TraitType	The type which the returned traits must implement.
	 * 						If no type is passed in, the function is called for all traits.]]></haxe_doc>
		</callForTraits>
		<getTraits public="1" params="TraitType" set="method" line="109">
			<f a="?TraitType">
				<c path="Class"><c path="getTraits.TraitType"/></c>
				<t path="Iterable"><c path="getTraits.TraitType"/></t>
			</f>
			<haxe_doc>* Gets a list of traits of a certain type.
	 * @param	TraitType		The type which the returned traits must implement.
	 * 							If no type is passed in, all traits are returned.
	 * @return		An array of traits, returns null if no matching traits are found.
	 * 				CAUTION: Do not modify the returned Array, for performance reasons,
	 * 				it is passed out by reference and reused internally.</haxe_doc>
		</getTraits>
		<getTrait public="1" params="TraitType" set="method" line="98">
			<f a="TraitType">
				<c path="Class"><c path="getTrait.TraitType"/></c>
				<c path="getTrait.TraitType"/>
			</f>
			<haxe_doc>* Gets the first trait of a certain type.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getTrait>
		<setRoot set="method" line="84"><f a="root">
	<c path="composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<_traitToPair><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<t path="composure.traits.TraitPair"><d/></t>
</t></_traitToPair>
		<_traitToCast><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.traits.ITrait"/>
</t></_traitToCast>
		<_uniInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_uniInjectors>
		<_ascInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ascInjectors>
		<_parentMarrier><c path="composure.injectors.InjectorMarrier"/></_parentMarrier>
		<_siblingMarrier><c path="composure.injectors.InjectorMarrier"/></_siblingMarrier>
		<_traitCollection><c path="composure.traits.TraitCollection"/></_traitCollection>
		<_root><c path="composure.core.ComposeRoot"/></_root>
		<_parentItem><c path="composure.core.ComposeGroup"/></_parentItem>
		<getRoot set="method" line="59"><f a=""><c path="composure.core.ComposeRoot"/></f></getRoot>
		<root public="1" get="getRoot" set="null">
			<c path="composure.core.ComposeRoot"/>
			<haxe_doc>* The ComposeRoot which is the top-level parent, if this is the root 'root' will be a self-reference.
	 * This value is set automatically and shouldn't be manually changed.</haxe_doc>
		</root>
		<setParentItem set="method" line="42"><f a="value">
	<c path="composure.core.ComposeGroup"/>
	<c path="composure.core.ComposeGroup"/>
</f></setParentItem>
		<getParentItem set="method" line="39"><f a=""><c path="composure.core.ComposeGroup"/></f></getParentItem>
		<parentItem public="1" get="getParentItem" set="setParentItem">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The ComposeGroup to which this item is added, if this is the root 'parentItem' will be a self-reference.
	 * This value is set automatically and shouldn't be manually changed.</haxe_doc>
		</parentItem>
		<new public="1" set="method" line="76">
			<f a="?initTraits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	initTraits		A list of traits to add to this ComposeItem initially.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* ComposeItem forms is the base class of all conceptual items in Composure.
 * It allows traits to be added and removed.<br/>
 * ComposeItem should only be used for performance critical items, it is recommended
 * that most items be represented by the subclass ComposeGroup, which adds the ability
 * to add/remove child items.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.core.ComposeGroup" params="" file="../../Composure/src/composure/core/ComposeGroup.hx">
		<extends path="composure.core.ComposeItem"/>
		<removeDescParentInjector set="method" line="344"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeDescParentInjector>
		<addDescParentInjector set="method" line="337"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addDescParentInjector>
		<checkForNewlyUnignoredInjectors set="method" line="319"><f a=""><e path="Void"/></f></checkForNewlyUnignoredInjectors>
		<checkForNewlyIgnoredInjectors set="method" line="300"><f a=""><e path="Void"/></f></checkForNewlyIgnoredInjectors>
		<removeParentInjector set="method" line="290" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeParentInjector>
		<addParentInjector set="method" line="280" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addParentInjector>
		<_removeAscendingInjector set="method" line="275"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_removeAscendingInjector>
		<removeAscendingInjector public="1" set="method" line="267">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</removeAscendingInjector>
		<_addAscendingInjector set="method" line="258"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></_addAscendingInjector>
		<addAscendingInjector public="1" set="method" line="249">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</addAscendingInjector>
		<onParentRemove set="method" line="234" override="1"><f a=""><e path="Void"/></f></onParentRemove>
		<onParentAdd set="method" line="223" override="1"><f a=""><e path="Void"/></f></onParentAdd>
		<callForDescTraits public="1" params="TraitType" set="method" line="220">
			<f a="func:?TraitType">
				<f a=":">
					<c path="composure.core.ComposeItem"/>
					<d/>
					<e path="Void"/>
				</f>
				<c path="Class"><c path="callForDescTraits.TraitType"/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Calls a function once for each descendant trait that matches a certain type. This ComposeGroup and
	 * the matched trait are passed through as arguments. A function should have a signature like:<br/>
	 * <code>
	 * function myTraitFunction(item:ComposeItem, trait:ITrait):Void;
	 * </code>
	 * @see					callForTraits
	 * @param	func		The function to call.
	 * @param	TraitType	The type which the returned traits must implement.
	 * 						If no type is passed in, the function is called for all traits.]]></haxe_doc>
		</callForDescTraits>
		<getDescTraits public="1" params="TraitType" set="method" line="206">
			<f a="?TraitType">
				<c path="Class"><c path="getDescTraits.TraitType"/></c>
				<t path="Iterable"><c path="getDescTraits.TraitType"/></t>
			</f>
			<haxe_doc>* Gets a list of traits of a certain type from any of this groups descendant items.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getDescTraits>
		<getDescTrait public="1" params="TraitType" set="method" line="198">
			<f a="TraitType">
				<c path="Class"><c path="getDescTrait.TraitType"/></c>
				<c path="getDescTrait.TraitType"/>
			</f>
			<haxe_doc>* Gets the first trait of a certain type from any of this groups descendant items.
	 * @param	TraitType		The type which the returned trait must implement.
	 * @return		A trait object, returns null if no matching trait is found.</haxe_doc>
		</getDescTrait>
		<removeTraitInjector set="method" line="184" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeTraitInjector>
		<addTraitInjector set="method" line="175" override="1"><f a="injector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addTraitInjector>
		<removeAllTraits public="1" set="method" line="171" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeAllTraits>
		<removeTraits public="1" set="method" line="164" override="1">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeTraits>
		<removeTrait public="1" set="method" line="157" override="1">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</removeTrait>
		<addTraits public="1" set="method" line="150" override="1">
			<f a="traits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</addTraits>
		<addTrait public="1" set="method" line="143" override="1">
			<f a="trait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @inheritDoc</haxe_doc>
		</addTrait>
		<removeChildTrait public="1" set="method" line="136">
			<f a="traitPair">
				<t path="composure.traits.TraitPair"><d/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</removeChildTrait>
		<addChildTrait public="1" set="method" line="128">
			<f a="traitPair">
				<t path="composure.traits.TraitPair"><d/></t>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private
	 * This is an interal function of Composure. Do not call this method.</haxe_doc>
		</addChildTrait>
		<removeAllItem public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Removes all children from this ComposeGroup.</haxe_doc>
		</removeAllItem>
		<removeChild public="1" set="method" line="90">
			<f a="item">
				<c path="composure.core.ComposeItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes a child ComposeItem from this ComposeGroup.
	 * @param	item		A ComposeItem object to remove as a child from this group.</haxe_doc>
		</removeChild>
		<addChild public="1" set="method" line="60">
			<f a="item">
				<c path="composure.core.ComposeItem"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds a child ComposeItem to this ComposeGroup.
	 * @param	item		A ComposeItem object to add as a child to this group.</haxe_doc>
		</addChild>
		<setRoot set="method" line="50" override="1"><f a="game">
	<c path="composure.core.ComposeRoot"/>
	<e path="Void"/>
</f></setRoot>
		<_ignoredParentDescInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ignoredParentDescInjectors>
		<_parentDescInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_parentDescInjectors>
		<_descInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_descInjectors>
		<_childAscendingMarrier><c path="composure.injectors.InjectorMarrier"/></_childAscendingMarrier>
		<_ignoredChildAscInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_ignoredChildAscInjectors>
		<_childAscInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_childAscInjectors>
		<_children><c path="org.tbyrne.collections.UniqueList"><c path="composure.core.ComposeItem"/></c></_children>
		<_descendantTraits><c path="composure.traits.TraitCollection"/></_descendantTraits>
		<get_children set="method" line="24"><f a=""><t path="Iterable"><c path="composure.core.ComposeItem"/></t></f></get_children>
		<children public="1" get="get_children" set="null"><t path="Iterable"><c path="composure.core.ComposeItem"/></t></children>
		<new public="1" set="method" line="42">
			<f a="?initTraits">
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	initTraits		A list of traits to add to this ComposeItem initially.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* ComposeGroup is the core item used in Composure. It represents one conceptual object.
 * It shouldn't be directly overriden, instead it should be instantiated and then
 * populated with traits, each adding one atomic piece of behaviour.<br/>
 * ComposeGroup adds to the functionality of ComposeItem by allowing child items. For
 * performance critical items that will never need to house children, ComposeItem can
 * be used instead.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.core.ComposeRoot" params="" file="../../Composure/src/composure/core/ComposeRoot.hx">
		<extends path="composure.core.ComposeGroup"/>
		<removeUniversalInjector public="1" set="method" line="42">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</removeUniversalInjector>
		<addUniversalInjector public="1" set="method" line="35">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</addUniversalInjector>
		<getAllTraits public="1" set="method" line="28"><f a=""><c path="composure.traits.TraitCollection"/></f></getAllTraits>
		<_universalMarrier><c path="composure.injectors.InjectorMarrier"/></_universalMarrier>
		<new public="1" set="method" line="23"><f a="?initTraits">
	<c path="Array"><c path="composure.traits.ITrait"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* ComposeRoot is the root item for the Composure library.
 * When using Composure, one top-level ComposeRoot object should be
 * created. All other objects should then be added to this object or one
 * of it's descendants.<br/>
 * It is recommended that you do not add traits directly to the root object.
 * Adding them to some 'stage' or 'controller' item instead will allow your app
 * to coexist and interrelate with other Composure apps in future.<br/>
 * The only functional change ComposeRoot adds to ComposeGroup is that it's
 * 'root' property is a reference to itself.
 * @author		Tom Byrne]]></haxe_doc>
	</class>
	<class path="composure.injectors.IInjector" params="" file="../../Composure/src/composure/injectors/IInjector.hx" interface="1">
		<isInterestedIn public="1" set="method"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<injectorRemoved public="1" set="method"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorRemoved>
		<injectorAdded public="1" set="method"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorAdded>
		<ownerTrait public="1"><d/></ownerTrait>
		<acceptOwnerTrait public="1" set="null"><e path="Bool"/></acceptOwnerTrait>
		<universal public="1" set="null"><e path="Bool"/></universal>
		<descendants public="1" set="null"><e path="Bool"/></descendants>
		<ascendants public="1" set="null"><e path="Bool"/></ascendants>
		<siblings public="1" set="null"><e path="Bool"/></siblings>
	</class>
	<class path="composure.injectors.AbstractInjector" params="" file="../../Composure/src/composure/injectors/AbstractInjector.hx">
		<implements path="composure.injectors.IInjector"/>
		<isInterestedIn public="1" set="method" line="123"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method" line="119"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method" line="115"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<itemMatchesAny set="method" line="107"><f a="item:traitTypes">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAny>
		<itemMatchesAll set="method" line="99"><f a="item:traitTypes">
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
</f></itemMatchesAll>
		<injectorRemoved public="1" set="method" line="79"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorRemoved>
		<injectorAdded public="1" set="method" line="59"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></injectorAdded>
		<_addedTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_addedTraits>
		<passThroughItem public="1"><e path="Bool"/></passThroughItem>
		<passThroughInjector public="1"><e path="Bool"/></passThroughInjector>
		<ownerTrait public="1"><d/></ownerTrait>
		<_enumValMode><e path="Bool"/></_enumValMode>
		<set_interestedTraitType set="method" line="22"><f a="value">
	<d/>
	<d/>
</f></set_interestedTraitType>
		<interestedTraitType public="1" set="set_interestedTraitType"><d/></interestedTraitType>
		<acceptOwnerTrait public="1"><e path="Bool"/></acceptOwnerTrait>
		<universal public="1"><e path="Bool"/></universal>
		<ascendants public="1"><e path="Bool"/></ascendants>
		<descendants public="1"><e path="Bool"/></descendants>
		<siblings public="1"><e path="Bool"/></siblings>
		<removeHandler public="1"><d/></removeHandler>
		<addHandler public="1"><d/></addHandler>
		<new public="1" set="method" line="43"><f a="interestedTraitType:addHandler:removeHandler:?siblings:?descendants:?ascendants:?universal">
	<d/>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.Injector" params="" file="../../Composure/src/composure/injectors/Injector.hx">
		<extends path="composure.injectors.AbstractInjector"/>
		<isInterestedIn public="1" set="method" line="35" override="1"><f a="item:trait">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<e path="Bool"/>
</f></isInterestedIn>
		<shouldAscend public="1" set="method" line="28" override="1"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldAscend>
		<shouldDescend public="1" set="method" line="21" override="1"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<e path="Bool"/>
</f></shouldDescend>
		<maxMatches public="1"><c path="Int"/></maxMatches>
		<stopAscendingAt public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.Injector"/>
	<e path="Bool"/>
</f></stopAscendingAt>
		<stopDescendingAt public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.Injector"/>
	<e path="Bool"/>
</f></stopDescendingAt>
		<matchTrait public="1"><f a="::">
	<c path="composure.core.ComposeItem"/>
	<d/>
	<c path="composure.injectors.Injector"/>
	<e path="Bool"/>
</f></matchTrait>
		<new public="1" set="method" line="14"><f a="traitType:addHandler:removeHandler:?siblings:?descendants:?ascendants:?universal">
	<d/>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.InjectorMarrier" params="" file="../../Composure/src/composure/injectors/InjectorMarrier.hx">
		<compareTrait set="method" line="122"><f a="traitPair:traitInjector">
	<t path="composure.traits.TraitPair"><d/></t>
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></compareTrait>
		<onTraitRemoved set="method" line="107"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></onTraitRemoved>
		<onTraitAdded set="method" line="101"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></onTraitAdded>
		<removeInjector public="1" set="method" line="73"><f a="traitInjector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></removeInjector>
		<addInjector public="1" set="method" line="55"><f a="traitInjector">
	<c path="composure.injectors.IInjector"/>
	<e path="Void"/>
</f></addInjector>
		<_traitLookup><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c>
</t></_traitLookup>
		<_injectorLookup><t path="cmtc.ds.hash.ObjectHash">
	<c path="composure.injectors.IInjector"/>
	<c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><d/></t></c>
</t></_injectorLookup>
		<_traitInjectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_traitInjectors>
		<_traits><c path="composure.traits.TraitCollection"/></_traits>
		<getTraitInjectors set="method" line="34"><f a=""><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></f></getTraitInjectors>
		<traitInjectors public="1" get="getTraitInjectors" set="null"><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></traitInjectors>
		<set_traits set="method" line="19"><f a="value">
	<c path="composure.traits.TraitCollection"/>
	<c path="composure.traits.TraitCollection"/>
</f></set_traits>
		<get_traits set="method" line="16"><f a=""><c path="composure.traits.TraitCollection"/></f></get_traits>
		<traits public="1" get="get_traits" set="set_traits"><c path="composure.traits.TraitCollection"/></traits>
		<new public="1" set="method" line="47"><f a="traits">
	<c path="composure.traits.TraitCollection"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="composure.injectors.PropInjector" params="" file="../../Composure/src/composure/injectors/PropInjector.hx">
		<extends path="composure.injectors.Injector"/>
		<removeProp set="method" line="38"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeProp>
		<addProp set="method" line="24"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addProp>
		<setTrait><d/></setTrait>
		<isSet><e path="Bool"/></isSet>
		<writeOnly><e path="Bool"/></writeOnly>
		<prop><c path="String"/></prop>
		<subject><d/></subject>
		<new public="1" set="method" line="16"><f a="interestedTraitType:subject:prop:?siblings:?descendants:?ascendants:?universal:?writeOnly">
	<d/>
	<d/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="composure.traitCheckers.TraitTypeChecker" params="" file="../../Composure/src/composure/traitCheckers/TraitTypeChecker.hx">
		<createMulti public="1" set="method" line="14" static="1"><f a="types:?useOrCheck:?invertResponse:?unlessIsTraits:?dontMatchFrom">
	<c path="Array"><c path="Class"><d/></c></c>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
	<f a="::">
		<c path="composure.core.ComposeItem"/>
		<d/>
		<c path="composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></createMulti>
		<create public="1" set="method" line="37" static="1"><f a="type:?invertResponse:?unlessIsTrait:?dontMatchFrom">
	<c path="Class"><d/></c>
	<e path="Bool"/>
	<d/>
	<e path="Bool"/>
	<f a="::">
		<c path="composure.core.ComposeItem"/>
		<d/>
		<c path="composure.injectors.Injector"/>
		<e path="Bool"/>
	</f>
</f></create>
		<contains set="method" line="46" static="1"><f a="traits:trait">
	<c path="Array"><d/></c>
	<d/>
	<e path="Bool"/>
</f></contains>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="composure.traits.ITrait" params="" file="../../Composure/src/composure/traits/ITrait.hx" interface="1">
		<getInjectors public="1" set="method">
			<f a=""><t path="Iterable"><c path="composure.injectors.IInjector"/></t></f>
			<haxe_doc>* This provides a way for this trait to gain access to other traits in the
	 * application.
	 * @return A list of IInjectors, each one describing which traits it is concerned with.</haxe_doc>
		</getInjectors>
		<group public="1" set="null">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The group to which this item is added. This is a method of convenience,
	 * and should return the 'item' property cast as a ComposeGroup.</haxe_doc>
		</group>
		<item public="1" set="set_item">
			<c path="composure.core.ComposeItem"/>
			<haxe_doc>* The item which this trait is added to. Do not set this manually,
	 * the ComposeItem class sets this property automatically when the 
	 * trait is added to it.</haxe_doc>
		</item>
		<haxe_doc>* ITrait can be implemented by traits to give them access to the item
 * to which they are added. It also allows traits to return a list of 
 * injectors, which describe other traits (sibling, ascendant or descendant)
 * which this trait should gain access to.
 * 
 * @author		Tom Byrne</haxe_doc>
	</class>
	<class path="composure.traits.AbstractTrait" params="" file="../../Composure/src/composure/traits/AbstractTrait.hx">
		<implements path="composure.traits.ITrait"/>
		<removeInjector public="1" set="method" line="195">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Removes an injector from this trait.
	 * @see addInjector
	 * @param injector The injector to remove from this trait.</haxe_doc>
		</removeInjector>
		<addInjector public="1" set="method" line="181">
			<f a="injector">
				<c path="composure.injectors.IInjector"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Adds an injector to this trait, each injector is a description of a certain other trait
	 * that this trait would like access to.
	 * @param injector The injector to add to this trait.</haxe_doc>
		</addInjector>
		<removeChildItems set="method" line="170"><f a="children">
	<c path="Array"><c path="composure.core.ComposeItem"/></c>
	<e path="Void"/>
</f></removeChildItems>
		<removeChildItem set="method" line="160"><f a="child">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></removeChildItem>
		<addChildItem set="method" line="149"><f a="child">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></addChildItem>
		<removeSiblingTraits set="method" line="143"><f a="traits">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></removeSiblingTraits>
		<removeSiblingTrait set="method" line="133"><f a="trait">
	<d/>
	<e path="Void"/>
</f></removeSiblingTrait>
		<addSiblingTrait set="method" line="122"><f a="trait">
	<d/>
	<e path="Void"/>
</f></addSiblingTrait>
		<getInjectors public="1" set="method" line="117">
			<f a=""><t path="Iterable"><c path="composure.injectors.IInjector"/></t></f>
			<haxe_doc>* This provides a way for this trait to gain access to other traits in the
	 * application.
	 * @return A list of IInjectors, each one describing which traits it is concerned with.</haxe_doc>
		</getInjectors>
		<onItemAdd set="method" line="108"><f a=""><e path="Void"/></f></onItemAdd>
		<onItemRemove set="method" line="105"><f a=""><e path="Void"/></f></onItemRemove>
		<_ownerTrait><d/></_ownerTrait>
		<_groupOnly>
			<e path="Bool"/>
			<haxe_doc>* Set to true to force Trait to only be added for groups.</haxe_doc>
		</_groupOnly>
		<_childItems><c path="org.tbyrne.collections.UniqueList"><c path="composure.core.ComposeItem"/></c></_childItems>
		<_siblingTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_siblingTraits>
		<_injectors><c path="org.tbyrne.collections.UniqueList"><c path="composure.injectors.IInjector"/></c></_injectors>
		<set_item set="method" line="40"><f a="value">
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></set_item>
		<item public="1" set="set_item">
			<c path="composure.core.ComposeItem"/>
			<haxe_doc>* The item which this trait is added to. Do not set this manually,
	 * the ComposeItem class sets this property automatically when the 
	 * trait is added to it.</haxe_doc>
		</item>
		<group public="1" set="null">
			<c path="composure.core.ComposeGroup"/>
			<haxe_doc>* The group to which this item is added. This is a method of convenience,
	 * and returns the 'item' property cast as a ComposeGroup.</haxe_doc>
		</group>
		<new public="1" set="method" line="97">
			<f a="?ownerTrait">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param ownerTrait When using this Class as a Proxied Trait, pass through the actual trait
	 * object as the first parameter.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The AbstractTrait class can be extended by any trait to gain access
 * to the trait to which it is added. It also allows traits to access
 * other traits in the application either via the injection metadata
 * or via manually adding injectors via the addInjector method.<br/>
 * <br/>
 * If, for whatever reason, it is not possible or convenient to extend 
 * AbstractTrait, it is also possible to instantiate it within your trait
 * (passing <code>this</code> in as the constructor argument) and returning this
 * instance via a <code>getProxiedTrait</code> method. To use injection metadata in
 * this situation you must also add the <code>@build(composure.macro.InjectorMacro.inject())</code>
 * metadata to your class.
 * 
 * @author		Tom Byrne]]></haxe_doc>
		<meta>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<typedef path="composure.traits.TraitPair" params="TraitType" file="../../Composure/src/composure/traits/ITrait.hx" module="composure.traits.ITrait"><a>
	<trait><c path="composure.traits.TraitPair.TraitType"/></trait>
	<item><c path="composure.core.ComposeItem"/></item>
</a></typedef>
	<class path="composure.traits.TraitCollection" params="" file="../../Composure/src/composure/traits/TraitCollection.hx">
		<get_traitRemoved set="method" line="28"><f a=""><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></f></get_traitRemoved>
		<_traitRemoved><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></_traitRemoved>
		<get_traitAdded set="method" line="25"><f a=""><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></f></get_traitAdded>
		<_traitAdded><c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c></_traitAdded>
		<removeTrait public="1" set="method" line="173"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></removeTrait>
		<addTrait public="1" set="method" line="165"><f a="traitPair">
	<t path="composure.traits.TraitPair"><d/></t>
	<e path="Void"/>
</f></addTrait>
		<callForTraits public="1" params="TraitType" set="method" line="103"><f a="func:matchType:thisObj:?params:?collectReturns">
	<d/>
	<c path="Class"><c path="callForTraits.TraitType"/></c>
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></callForTraits>
		<validateCache public="1" params="TraitType" set="method" line="70"><f a="matchType">
	<c path="Class"><c path="validateCache.TraitType"/></c>
	<c path="composure.traits._TraitCollection.TraitTypeCache"><c path="validateCache.TraitType"/></c>
</f></validateCache>
		<getTraits public="1" params="TraitType" set="method" line="61"><f a="?TraitType">
	<c path="Class"><c path="getTraits.TraitType"/></c>
	<t path="Iterable"><c path="getTraits.TraitType"/></t>
</f></getTraits>
		<getTrait public="1" params="TraitType" set="method" line="47"><f a="TraitType">
	<c path="Class"><c path="getTrait.TraitType"/></c>
	<c path="getTrait.TraitType"/>
</f></getTrait>
		<traitPairs public="1" set="null"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><d/></t></c></traitPairs>
		<_traitTypeCache><c path="Hash"><c path="composure.traits._TraitCollection.TraitTypeCache"><d/></c></c></_traitTypeCache>
		<_testSignal><c path="msignal.Signal1"><d/></c></_testSignal>
		<get_testSignal set="method" line="31"><f a=""><c path="msignal.Signal1"><d/></c></f></get_testSignal>
		<testSignal public="1" get="get_testSignal" set="null"><c path="msignal.Signal1"><d/></c></testSignal>
		<traitRemoved public="1" get="get_traitRemoved" set="null">
			<c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c>
			<meta><m n="lazyInst"/></meta>
		</traitRemoved>
		<traitAdded public="1" get="get_traitAdded" set="null">
			<c path="msignal.Signal1"><t path="composure.traits.TraitPair"><d/></t></c>
			<meta><m n="lazyInst"/></meta>
		</traitAdded>
		<new public="1" set="method" line="41"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* The TraitCollection holds a collection of traits and has the
 * ability to compare them to a collection of injectors. This is 
 * used internally in Composure.
 * 
 * @author Tom Byrne</haxe_doc>
		<meta><m n=":build"><e>'???'</e></m></meta>
	</class>
	<class path="composure.traits._TraitCollection.TraitTypeCache" params="TraitType" file="../../Composure/src/composure/traits/TraitCollection.hx" private="1" module="composure.traits.TraitCollection">
		<invalid public="1"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></c></invalid>
		<matched public="1"><c path="org.tbyrne.collections.UniqueList"><t path="composure.traits.TraitPair"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></c></matched>
		<getTraitsList public="1"><c path="org.tbyrne.collections.UniqueList"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></c></getTraitsList>
		<getTraits public="1"><t path="Iterable"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></t></getTraits>
		<getTrait public="1"><c path="composure.traits._TraitCollection.TraitTypeCache.TraitType"/></getTrait>
		<methodCachesSafe public="1"><e path="Bool"/></methodCachesSafe>
		<new public="1" set="method" line="195"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="composure.utilTraits.Furnisher" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<unregisterItem set="method" line="309"><f a="trait:currItem:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></unregisterItem>
		<registerItem set="method" line="242"><f a="trait:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></registerItem>
		<getItem set="method" line="239"><f a="trait">
	<d/>
	<c path="composure.core.ComposeItem"/>
</f></getItem>
		<testRules set="method" line="223"><f a="foundTrait:item:rules">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
	<e path="Bool"/>
</f></testRules>
		<getTrait set="method" line="206"><f a="foundTrait:item:addTrait">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="composure.utilTraits.AddTrait"/>
	<d/>
</f></getTrait>
		<addTrait public="1" set="method" line="190"><f a="addTrait">
	<e path="composure.utilTraits.AddTrait"/>
	<e path="Void"/>
</f></addTrait>
		<onConcernedTraitRemoved set="method" line="169"><f a="trait:currItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onConcernedTraitRemoved>
		<onConcernedTraitAdded set="method" line="144"><f a="trait:origItem">
	<d/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onConcernedTraitAdded>
		<_ignoreTraitChanges><e path="Bool"/></_ignoreTraitChanges>
		<_originalParents><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeGroup"/>
</t></_originalParents>
		<_originalItems><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeItem"/>
</t></_originalItems>
		<_traitToItems><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="composure.core.ComposeItem"/>
</t></_traitToItems>
		<_addedTraits><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="Array"><d/></c>
</t></_addedTraits>
		<_foundTraits><c path="org.tbyrne.collections.UniqueList"><d/></c></_foundTraits>
		<_addTraits><c path="org.tbyrne.collections.UniqueList"><e path="composure.utilTraits.AddTrait"/></c></_addTraits>
		<_injector><c path="composure.injectors.Injector"/></_injector>
		<_addType><e path="composure.utilTraits.AddType"/></_addType>
		<set_searchAscendants set="method" line="105"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchAscendants>
		<searchAscendants public="1" set="set_searchAscendants"><e path="Bool"/></searchAscendants>
		<set_searchDescendants set="method" line="95"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchDescendants>
		<searchDescendants public="1" set="set_searchDescendants"><e path="Bool"/></searchDescendants>
		<set_searchSiblings set="method" line="85"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_searchSiblings>
		<searchSiblings public="1" set="set_searchSiblings"><e path="Bool"/></searchSiblings>
		<set_concernedTraitType set="method" line="70"><f a="value">
	<d/>
	<d/>
</f></set_concernedTraitType>
		<concernedTraitType public="1" set="set_concernedTraitType"><d/></concernedTraitType>
		<new public="1" set="method" line="126"><f a="?concernedTraitType:?addTraits:?addType:?searchSiblings:?searchDescendants:?searchAscendants">
	<d/>
	<c path="Array"><e path="composure.utilTraits.AddTrait"/></c>
	<e path="composure.utilTraits.AddType"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Furnisher class is used to add traits to an item in response
 * to a certain type of trait being added to the item.<br/>
 * <br/>
 * This is very useful when creating interchangable libraries. For example,
 * when wanting to add a platform specific display trait to a items in the
 * presence of another trait:
 * <pre><code>
 * var furnisher:Furnisher = new Furnisher(RectangleInfo, [TType(HtmlRectangleDisplay)]);
 * stage.addTrait(furnisher);
 * </code></pre>
 * In this example, any item which has a RectangleInfo trait added to it (representing
 * a rectangle's position and size) will also get a HtmlRectangleDisplay trait added to
 * it. The HtmlRectangleDisplay object can then access the RectangleInfo's size and 
 * position properties using injection metadata. In this way, the display method for
 * all rectangles could be quickly and easily be swapped out for another display trait.
 * 
 * @author Tom Byrne]]></haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":keep"/>
		</meta>
	</class>
	<enum path="composure.utilTraits.AddTrait" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<TType a="t:?rules">
			<c path="Class"><d/></c>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TType>
		<TInst a="t:?rules">
			<d/>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TInst>
		<TFact a="f:?rules">
			<f a="">
				<d/>
				<d/>
			</f>
			<c path="Array"><e path="composure.utilTraits.AddRule"/></c>
		</TFact>
	</enum>
	<enum path="composure.utilTraits.AddRule" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<UnlessHas a="t"><c path="Class"><d/></c></UnlessHas>
		<IfHas a="t"><c path="Class"><d/></c></IfHas>
	</enum>
	<enum path="composure.utilTraits.AddType" params="" file="../../Composure/src/composure/utilTraits/Furnisher.hx" module="composure.utilTraits.Furnisher">
		<traitSibling a="?adoptMatchedTrait"><e path="Bool"/></traitSibling>
		<traitItem/>
		<traitChild a="?adoptMatchedTrait"><e path="Bool"/></traitChild>
		<selfSibling a="?adoptMatchedTrait"><e path="Bool"/></selfSibling>
		<selfItem a="?adoptMatchedTrait"><e path="Bool"/></selfItem>
		<selfChild a="?adoptMatchedTrait"><e path="Bool"/></selfChild>
		<itemSibling a="item:?adoptMatchedTrait">
			<c path="composure.core.ComposeItem"/>
			<e path="Bool"/>
		</itemSibling>
		<itemChild a="group:?adoptMatchedTrait">
			<c path="composure.core.ComposeGroup"/>
			<e path="Bool"/>
		</itemChild>
		<item a="item:?adoptMatchedTrait">
			<c path="composure.core.ComposeItem"/>
			<e path="Bool"/>
		</item>
		<adoptItem a="newParent:?adoptMatchedTrait">
			<c path="composure.core.ComposeGroup"/>
			<e path="Bool"/>
		</adoptItem>
	</enum>
	<typedef path="feffects.Easing" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx" module="feffects.Tween"><f a=":::">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></typedef>
	<class path="feffects.TweenObject" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx" module="feffects.Tween">
		<tween public="1" set="method" line="65" static="1"><f a="target:properties:duration:?easing:?autoStart:?onFinish:?onFinishParams">
	<d/>
	<d/>
	<c path="Int"/>
	<t path="feffects.Easing"/>
	<e path="Bool"/>
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.TweenObject"/>
</f></tween>
		<_onFinish set="method" line="130"><f a="tp">
	<c path="feffects.TweenProperty"/>
	<e path="Void"/>
</f></_onFinish>
		<onFinish public="1" set="method" line="124"><f a="f:?params">
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.TweenObject"/>
</f></onFinish>
		<stop public="1" set="method" line="119"><f a="?finish">
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<reverse public="1" set="method" line="114"><f a=""><e path="Void"/></f></reverse>
		<seek public="1" set="method" line="108"><f a="n">
	<c path="Int"/>
	<c path="feffects.TweenObject"/>
</f></seek>
		<resume public="1" set="method" line="103"><f a=""><e path="Void"/></f></resume>
		<pause public="1" set="method" line="98"><f a=""><e path="Void"/></f></pause>
		<start public="1" set="method" line="87"><f a=""><c path="List"><c path="feffects.TweenProperty"/></c></f></start>
		<setEasing public="1" set="method" line="81"><f a="easing">
	<t path="feffects.Easing"/>
	<c path="feffects.TweenObject"/>
</f></setEasing>
		<__onFinishParams><c path="Array"><d/></c></__onFinishParams>
		<__onFinish><d/></__onFinish>
		<get_isPlaying set="method" line="55"><f a=""><e path="Bool"/></f></get_isPlaying>
		<isPlaing public="1" get="get_isPlaying" set="null"><e path="Bool"/></isPlaing>
		<easing public="1" set="null"><t path="feffects.Easing"/></easing>
		<duration public="1" set="null"><c path="Int"/></duration>
		<properties public="1" set="null"><d/></properties>
		<target public="1" set="null"><d/></target>
		<tweens public="1" set="null"><c path="List"><c path="feffects.TweenProperty"/></c></tweens>
		<new public="1" set="method" line="69"><f a="target:properties:duration:?easing:?autoStart:?onFinish:?onFinishParams">
	<d/>
	<d/>
	<c path="Int"/>
	<t path="feffects.Easing"/>
	<e path="Bool"/>
	<d/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Class that allows tweening properties of an object.<br/>
* Version 1.3.3
* Compatible haxe 2.11 - flash/js/NME
* Usage :<br/>
* import feffects.easing.Elastic;<br/>
* 
* using feffects.Tween.TweenObject;
* ...<br/>
* var mySprite = new Sprite();
* mySprite.graphics.beginFill( 0 );
* mySprite.graphics.drawCircle( 0, 0, 20 );
* mySprite.graphics.endFill();
* 
* Lib.current.addChild( mySprite );
* 
* function foo() {
* 	trace( "end" );
* }
* 
* mySprite.tween( { x : 100, y : 200 }, 1000 ).onFinish( foo ).start();
* 
* OR
* 
* mySprite.tween( {x : 100, y : 200 }, 1000, foo, true );
* 
* @author : M.Romecki
*]]></haxe_doc>
	</class>
	<class path="haxe.FastList_feffects_Tween" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="feffects.Tween"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="feffects.Tween"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="feffects.Tween"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="feffects.Tween"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="feffects.Tween"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell_feffects_Tween"/></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
	</class>
	<class path="feffects.Tween" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx">
		<_aTweens line="203" static="1"><c path="haxe.FastList_feffects_Tween"/></_aTweens>
		<_aPaused line="204" static="1"><c path="haxe.FastList_feffects_Tween"/></_aPaused>
		<DEFAULT_EASING public="1" line="211" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></DEFAULT_EASING>
		<_isTweening static="1"><e path="Bool"/></_isTweening>
		<AddTween set="method" line="234" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></AddTween>
		<RemoveActiveTween set="method" line="250" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></RemoveActiveTween>
		<RemovePausedTween set="method" line="255" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></RemovePausedTween>
		<checkActiveTweens set="method" line="260" static="1"><f a=""><e path="Void"/></f></checkActiveTweens>
		<getActiveTweens public="1" set="method" line="276" static="1"><f a=""><c path="haxe.FastList_feffects_Tween"/></f></getActiveTweens>
		<getPausedTweens public="1" set="method" line="280" static="1"><f a=""><c path="haxe.FastList_feffects_Tween"/></f></getPausedTweens>
		<setTweenPaused set="method" line="284" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></setTweenPaused>
		<setTweenActive set="method" line="294" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></setTweenActive>
		<cb_tick set="method" line="314" static="1"><f a="?_">
	<unknown/>
	<e path="Void"/>
</f></cb_tick>
		<easingEquation get="inline" set="null" line="499" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easingEquation>
		<getStamp get="inline" set="null" line="487"><f a=""><c path="Int"/></f></getStamp>
		<getCurVal get="inline" set="null" line="483"><f a="curTime">
	<c path="Int"/>
	<c path="Float"/>
</f></getCurVal>
		<doInterval set="method" line="459"><f a=""><e path="Void"/></f></doInterval>
		<setEasing public="1" set="method" line="454">
			<f a="f">
				<t path="feffects.Easing"/>
				<c path="feffects.Tween"/>
			</f>
			<haxe_doc>* Set the [easingFunc] equation to use for tweening</haxe_doc>
		</setEasing>
		<onFinish public="1" set="method" line="445"><f a="f:?params">
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.Tween"/>
</f></onFinish>
		<onUpdate public="1" set="method" line="436"><f a="f:?params">
	<d/>
	<c path="Array"><d/></c>
	<c path="feffects.Tween"/>
</f></onUpdate>
		<finish set="method" line="424"><f a=""><e path="Void"/></f></finish>
		<stop public="1" set="method" line="410"><f a="?doFinish">
	<e path="Bool"/>
	<e path="Void"/>
</f></stop>
		<reverse public="1" set="method" line="399">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Reverse the tweeen from the current position</haxe_doc>
		</reverse>
		<seek public="1" set="method" line="391">
			<f a="ms">
				<c path="Int"/>
				<c path="feffects.Tween"/>
			</f>
			<haxe_doc>* Go to the specified position [ms] (in ms)</haxe_doc>
		</seek>
		<resume public="1" set="method" line="376"><f a=""><e path="Void"/></f></resume>
		<pause public="1" set="method" line="365"><f a=""><e path="Void"/></f></pause>
		<start public="1" set="method" line="348"><f a="?position">
	<c path="Int"/>
	<e path="Void"/>
</f></start>
		<_onFinishParams><c path="Array"><d/></c></_onFinishParams>
		<_onUpdateParams><c path="Array"><d/></c></_onUpdateParams>
		<_onFinish><d/></_onFinish>
		<_onUpdate><d/></_onUpdate>
		<_easingF><t path="feffects.Easing"/></_easingF>
		<_reverseTime><c path="Float"/></_reverseTime>
		<_offsetTime><c path="Float"/></_offsetTime>
		<_pauseTime><c path="Float"/></_pauseTime>
		<_startTime><c path="Float"/></_startTime>
		<_endVal><c path="Float"/></_endVal>
		<_initVal><c path="Float"/></_initVal>
		<isPaused public="1" set="null"><e path="Bool"/></isPaused>
		<isPlaying public="1" set="null"><e path="Bool"/></isPlaying>
		<isReversed public="1" set="null"><e path="Bool"/></isReversed>
		<position public="1" set="null"><c path="Int"/></position>
		<duration public="1" set="null"><c path="Int"/></duration>
		<new public="1" set="method" line="324">
			<f a="init:end:dur:?easing:?autoStart:?onUpdate:?onUpdateParams:?onFinish:?onFinishParams">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<t path="feffects.Easing"/>
				<e path="Bool"/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
				<c path="Array"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a tween from the [init] value, to the [end] value, while [dur] (in ms)<br />
	* There is a default easing equation.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Class that allows tweening numerical values of an object.<br/>
* Version 1.3.3
* Compatible haxe 2.11 - flash/js/NME
* Usage :<br/>
* import feffects.Tween;<br/>
* import feffects.easing.Elastic;<br/>
* ...<br/>
* function foo ( n : Float ){
* 	mySprite.x = n;
* }
* var t = new Tween( 0, 100, 2000 );						// create a new tween<br/>
* t.onUpdate( foo );
* t.start();												// start the tween<br/>
* 
* You can add :
* * 
* t.setEasing( Elastic.easeIn );							// set the easing function used to compute values<br/>
* t.seek( 1000 );											// go to the specified position (in ms)</br>
* t.pause();<br/>
* t.resume();<br/>
* t.reverse();												// reverse the tween from the current position</br>
* t.stop();
* 
* OR combinated sythax :
* 
* new Tween( 0, 100, 2000 ).setEasing( Elastic.easeIn ).seek( 1000 ).onUpdate( foo ).onFinish( foo2 ).start();
* 
* OR fastest one : 
*
* new Tween( 0, 100, 2000, Elastic.easeIn, foo, foo2, true ).seek( 1000 );
* 
* @author : M.Romecki
*]]></haxe_doc>
	</class>
	<class path="feffects.TweenProperty" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/Tween.hx" module="feffects.Tween">
		<extends path="feffects.Tween"/>
		<__onUpdate set="method" line="156"><f a="n">
	<c path="Float"/>
	<e path="Void"/>
</f></__onUpdate>
		<___onUpdateParams><c path="Array"><d/></c></___onUpdateParams>
		<___onUpdate><d/></___onUpdate>
		<property public="1" set="null"><c path="String"/></property>
		<target public="1" set="null"><d/></target>
		<new public="1" set="method" line="146"><f a="target:prop:value:duration:?easing:?autostart:?onUpdate:?onUpdateParams:?onFinish:?onFinishParams">
	<d/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Int"/>
	<t path="feffects.Easing"/>
	<e path="Bool"/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Public" params="" file="C:\Motion-Twin\haxe\std/haxe/Public.hx" interface="1"><haxe_doc>When implementing this interface, all default fields access for the class and
	subclasses becomes [public] instead of [private].</haxe_doc></class>
	<class path="feffects.easing.Quad" params="" file="C:\Motion-Twin\haxe\lib\feffects/1,3,3/feffects/easing/Quad.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" get="inline" set="null" line="4" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" get="inline" set="null" line="8" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" get="inline" set="null" line="12" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="C:\Motion-Twin\haxe\std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="C:\Motion-Twin\haxe\std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="C:\Motion-Twin\haxe\std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="C:\Motion-Twin\haxe\std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<local3DToGlobal public="1" set="method">
			<f a="point3d">
				<c path="flash.geom.Vector3D"/>
				<c path="flash.geom.Point"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</local3DToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<globalToLocal3D public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Vector3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</globalToLocal3D>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<z public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<visible public="1"><e path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</scaleZ>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotationZ public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationZ>
		<rotationY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationY>
		<rotationX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</rotationX>
		<rotation public="1"><c path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><c path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<blendShader public="1" get="null">
			<c path="flash.display.Shader"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</blendShader>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><c path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="C:\Motion-Twin\haxe\std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<requestSoftKeyboard public="1">
			<f a=""><e path="Bool"/></f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestSoftKeyboard>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<softKeyboardInputAreaOfInterest public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardInputAreaOfInterest>
		<needsSoftKeyboard public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</needsSoftKeyboard>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="C:\Motion-Twin\haxe\std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<removeChildren public="1">
			<f a="?beginIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</removeChildren>
		<removeChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="C:\Motion-Twin\haxe\std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopTouchDrag public="1">
			<f a="touchPointID">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</stopTouchDrag>
		<stopDrag public="1" set="method"><f a=""><e path="Void"/></f></stopDrag>
		<startTouchDrag public="1">
			<f a="touchPointID:?lockCenter:?bounds">
				<c path="Int"/>
				<e path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</startTouchDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="C:\Motion-Twin\haxe\std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><e path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><e path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><e path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><e path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><e path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<isPlaying public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</isPlaying>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<enabled public="1"><e path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrameLabel public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</currentFrameLabel>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="C:\Motion-Twin\haxe\std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="54" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="86" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="119" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="147" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="162" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="206" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="82"><f a=""><e path="Void"/></f></init>
		<doInitDelay set="method" line="77"><f a="_">
	<unknown/>
	<e path="Void"/>
</f></doInitDelay>
		<start set="method" line="56"><f a=""><e path="Void"/></f></start>
		<new public="1" set="method" line="48"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="C:\Motion-Twin\haxe\std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="38"><f a=""><e path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="C:\Motion-Twin\haxe\std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" set="method" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.Vector" params="T" file="C:\Motion-Twin\haxe\std/flash/Vector.hx" extern="1">
		<ofArray public="1" params="T" get="inline" set="null" line="26" static="1"><f a="v">
	<c path="Array"><c path="ofArray.T"/></c>
	<c path="flash.Vector"><c path="ofArray.T"/></c>
</f></ofArray>
		<convert public="1" params="T:U" get="inline" set="null" line="30" static="1"><f a="v">
	<c path="flash.Vector"><c path="convert.T"/></c>
	<c path="flash.Vector"><c path="convert.U"/></c>
</f></convert>
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
	<c path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<c path="Int"/>
	</f>
	<e path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<e path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><e path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<c path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><e path="Bool"/></fixed>
		<length public="1"><t path="UInt"/></length>
		<new public="1" set="method"><f a="?length:?fixed">
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="C:\Motion-Twin\haxe\std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><e path="Bool"/></stub>
		<errno public="1"><t path="UInt"/></errno>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="C:\Motion-Twin\haxe\std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><e path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="C:\Motion-Twin\haxe\std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.BitmapData" params="" file="C:\Motion-Twin\haxe\std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</setVector>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><e path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<histogram public="1" set="method">
			<f a="?hRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><c path="flash.Vector"><c path="Float"/></c></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</histogram>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><t path="UInt"/></c>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getVector>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<encode public="1">
			<f a="rect:compressor:?byteArray">
				<c path="flash.geom.Rectangle"/>
				<d/>
				<c path="flash.utils.ByteArray"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</encode>
		<drawWithQuality public="1">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing:?quality">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<e path="Bool"/>
				<e path="flash.display.StageQuality"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</drawWithQuality>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><c path="Int"/></width>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><c path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="C:\Motion-Twin\haxe\std/flash/display/BlendMode.hx">
		<SUBTRACT/>
		<SHADER/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="C:\Motion-Twin\haxe\std/flash/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="C:\Motion-Twin\haxe\std/flash/display/ColorCorrection.hx">
		<ON/>
		<OFF/>
		<DEFAULT/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="C:\Motion-Twin\haxe\std/flash/display/ColorCorrectionSupport.hx">
		<UNSUPPORTED/>
		<DEFAULT_ON/>
		<DEFAULT_OFF/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="C:\Motion-Twin\haxe\std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><c path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="C:\Motion-Twin\haxe\std/flash/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/flash/display/Graphics.hx" extern="1">
		<drawTiles public="1" get="inline" set="null" line="30"><f a="sheet:tileData:?smooth:?flags">
	<c path="nme.display.Tilesheet"/>
	<c path="Array"><c path="Float"/></c>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTiles>
		<moveTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineShaderStyle public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineShaderStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</lineBitmapStyle>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><c path="Float"/></c>
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><c path="Int"/></c>
				<c path="flash.Vector"><c path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</drawGraphicsData>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<cubicCurveTo public="1">
			<f a="controlX1:controlY1:controlX2:controlY2:anchorX:anchorY">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</cubicCurveTo>
		<copyFrom public="1" set="method">
			<f a="sourceGraphics">
				<c path="flash.display.Graphics"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</copyFrom>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginShaderFill public="1" set="method">
			<f a="shader:?matrix">
				<c path="flash.display.Shader"/>
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</beginShaderFill>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="C:\Motion-Twin\haxe\std/flash/display/GraphicsPathWinding.hx">
		<NON_ZERO/>
		<EVEN_ODD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="C:\Motion-Twin\haxe\std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="C:\Motion-Twin\haxe\std/flash/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="C:\Motion-Twin\haxe\std/flash/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="C:\Motion-Twin\haxe\std/flash/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="C:\Motion-Twin\haxe\std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unloadAndStop public="1" set="method">
			<f a="?gc">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unloadAndStop>
		<unload public="1" set="method"><f a=""><e path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="C:\Motion-Twin\haxe\std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><c path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<uncaughtErrorEvents public="1">
			<c path="flash.events.UncaughtErrorEvents"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</uncaughtErrorEvents>
		<swfVersion public="1" set="null"><t path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<isURLInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<height public="1" set="null"><c path="Int"/></height>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="C:\Motion-Twin\haxe\std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.display.Scene" params="" file="C:\Motion-Twin\haxe\std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="C:\Motion-Twin\haxe\std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1" set="method"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="C:\Motion-Twin\haxe\std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="C:\Motion-Twin\haxe\std/flash/display/ShaderPrecision.hx">
		<FULL/>
		<FAST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Shape" params="" file="C:\Motion-Twin\haxe\std/flash/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="C:\Motion-Twin\haxe\std/flash/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="C:\Motion-Twin\haxe\std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><e path="Void"/></f></invalidate>
		<wmodeGPU public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</wmodeGPU>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<stageVideos public="1">
			<c path="flash.Vector"><c path="flash.media.StageVideo"/></c>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</stageVideos>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stage3Ds public="1">
			<c path="flash.Vector"><c path="flash.display.Stage3D"/></c>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</stage3Ds>
		<softKeyboardRect public="1">
			<c path="flash.geom.Rectangle"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</softKeyboardRect>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<mouseLock public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</mouseLock>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<frameRate public="1"><c path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<displayContextInfo public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</displayContextInfo>
		<colorCorrectionSupport public="1" set="null">
			<e path="flash.display.ColorCorrectionSupport"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrectionSupport>
		<colorCorrection public="1">
			<e path="flash.display.ColorCorrection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</colorCorrection>
		<color public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</color>
		<allowsFullScreenInteractive public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</allowsFullScreenInteractive>
		<allowsFullScreen public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</allowsFullScreen>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="C:\Motion-Twin\haxe\std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode">
	<c path="String"/>
	<e path="Void"/>
</f></requestContext3D>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<visible public="1"><e path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="C:\Motion-Twin\haxe\std/flash/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="C:\Motion-Twin\haxe\std/flash/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN_INTERACTIVE/>
		<FULL_SCREEN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="C:\Motion-Twin\haxe\std/flash/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH_8X8_LINEAR/>
		<HIGH_8X8/>
		<HIGH_16X16_LINEAR/>
		<HIGH_16X16/>
		<HIGH/>
		<BEST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="C:\Motion-Twin\haxe\std/flash/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="C:\Motion-Twin\haxe\std/flash/display/TriangleCulling.hx">
		<POSITIVE/>
		<NONE/>
		<NEGATIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<e path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<c path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><e path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<c path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgramConstantsFromByteArray public="1">
			<f a="programType:firstRegister:numRegisters:data:byteArrayOffset">
				<e path="flash.display3D.Context3DProgramType"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</setProgramConstantsFromByteArray>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<e path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<e path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><e path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<e path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<c path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<c path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><e path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3DBlendFactor.hx">
		<ZERO/>
		<SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE/>
		<DESTINATION_COLOR/>
		<DESTINATION_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3DCompareMode.hx">
		<NOT_EQUAL/>
		<NEVER/>
		<LESS_EQUAL/>
		<LESS/>
		<GREATER_EQUAL/>
		<GREATER/>
		<EQUAL/>
		<ALWAYS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3DProgramType.hx">
		<VERTEX/>
		<FRAGMENT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3DStencilAction.hx">
		<ZERO/>
		<SET/>
		<KEEP/>
		<INVERT/>
		<INCREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<DECREMENT_SATURATE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3DTextureFormat.hx">
		<COMPRESSED/>
		<BGRA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3DTriangleFace.hx">
		<NONE/>
		<FRONT_AND_BACK/>
		<FRONT/>
		<BACK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Context3DVertexBufferFormat.hx">
		<FLOAT_4/>
		<FLOAT_3/>
		<FLOAT_2/>
		<FLOAT_1/>
		<BYTES_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><t path="UInt"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><e path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="C:\Motion-Twin\haxe\std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="C:\Motion-Twin\haxe\std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.Event" params="" file="C:\Motion-Twin\haxe\std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLEAR public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CLEAR>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<CONTEXT3D_CREATE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</CONTEXT3D_CREATE>
		<COPY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</COPY>
		<CUT public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CUT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<EXIT_FRAME public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</EXIT_FRAME>
		<FRAME_CONSTRUCTED public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</FRAME_CONSTRUCTED>
		<FRAME_LABEL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</FRAME_LABEL>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<PASTE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</PASTE>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SELECT_ALL public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</SELECT_ALL>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<SUSPEND public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</SUSPEND>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<TEXTURE_READY public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</TEXTURE_READY>
		<TEXT_INTERACTION_MODE_CHANGE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</TEXT_INTERACTION_MODE_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><e path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><e path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="C:\Motion-Twin\haxe\std/flash/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.FocusEvent" params="" file="C:\Motion-Twin\haxe\std/flash/events/FocusEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<FOCUS_IN public="1" static="1"><c path="String"/></FOCUS_IN>
		<FOCUS_OUT public="1" static="1"><c path="String"/></FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" static="1"><c path="String"/></KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" static="1"><c path="String"/></MOUSE_FOCUS_CHANGE>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<isRelatedObjectInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="C:\Motion-Twin\haxe\std/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue:?keyLocationValue:?ctrlKeyValue:?altKeyValue:?shiftKeyValue">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="C:\Motion-Twin\haxe\std/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<CONTEXT_MENU public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</CONTEXT_MENU>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MIDDLE_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_CLICK>
		<MIDDLE_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_DOWN>
		<MIDDLE_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</MIDDLE_MOUSE_UP>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<RELEASE_OUTSIDE public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</RELEASE_OUTSIDE>
		<RIGHT_CLICK public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_CLICK>
		<RIGHT_MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_DOWN>
		<RIGHT_MOUSE_UP public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</RIGHT_MOUSE_UP>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<updateAfterEvent public="1" set="method"><f a=""><e path="Void"/></f></updateAfterEvent>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<movementY public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementY>
		<movementX public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</movementX>
		<localY public="1"><c path="Float"/></localY>
		<localX public="1"><c path="Float"/></localX>
		<isRelatedObjectInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isRelatedObjectInaccessible>
		<delta public="1"><c path="Int"/></delta>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<altKey public="1"><e path="Bool"/></altKey>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="C:\Motion-Twin\haxe\std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="C:\Motion-Twin\haxe\std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.filters.DropShadowFilter" params="" file="C:\Motion-Twin\haxe\std/flash/filters/DropShadowFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<strength public="1"><c path="Float"/></strength>
		<quality public="1"><c path="Int"/></quality>
		<knockout public="1"><e path="Bool"/></knockout>
		<inner public="1"><e path="Bool"/></inner>
		<hideObject public="1"><e path="Bool"/></hideObject>
		<distance public="1"><c path="Float"/></distance>
		<color public="1"><t path="UInt"/></color>
		<blurY public="1"><c path="Float"/></blurY>
		<blurX public="1"><c path="Float"/></blurX>
		<angle public="1"><c path="Float"/></angle>
		<alpha public="1"><c path="Float"/></alpha>
		<new public="1" set="method"><f a="?distance:?angle:?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout:?hideObject">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.filters.GlowFilter" params="" file="C:\Motion-Twin\haxe\std/flash/filters/GlowFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<strength public="1"><c path="Float"/></strength>
		<quality public="1"><c path="Int"/></quality>
		<knockout public="1"><e path="Bool"/></knockout>
		<inner public="1"><e path="Bool"/></inner>
		<color public="1"><t path="UInt"/></color>
		<blurY public="1"><c path="Float"/></blurY>
		<blurX public="1"><c path="Float"/></blurX>
		<alpha public="1"><c path="Float"/></alpha>
		<new public="1" set="method"><f a="?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout">
	<t path="UInt"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="C:\Motion-Twin\haxe\std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<redOffset public="1"><c path="Float"/></redOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<color public="1"><t path="UInt"/></color>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="C:\Motion-Twin\haxe\std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="aa:ba:ca:da:txa:tya">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scale public="1" set="method"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><e path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyFrom public="1">
			<f a="sourceMatrix">
				<c path="flash.geom.Matrix"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><c path="Float"/></ty>
		<tx public="1"><c path="Float"/></tx>
		<d public="1"><c path="Float"/></d>
		<c public="1"><c path="Float"/></c>
		<b public="1"><c path="Float"/></b>
		<a public="1"><c path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="C:\Motion-Twin\haxe\std/flash/geom/Matrix3D.hx" extern="1">
		<interpolate public="1" set="method" static="1"><f a="thisMat:toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<c path="flash.geom.Matrix3D"/>
</f></interpolate>
		<transpose public="1" set="method"><f a=""><e path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><c path="Float"/></c>
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<e path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><e path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<c path="Float"/>
	<e path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><e path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<copyToMatrix3D public="1">
			<f a="dest">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyToMatrix3D>
		<copyRowTo public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowTo>
		<copyRowFrom public="1">
			<f a="row:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRowFrom>
		<copyRawDataTo public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataTo>
		<copyRawDataFrom public="1">
			<f a="vector:?index:?transpose">
				<c path="flash.Vector"><c path="Float"/></c>
				<t path="UInt"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyRawDataFrom>
		<copyFrom public="1">
			<f a="sourceMatrix3D">
				<c path="flash.geom.Matrix3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<copyColumnTo public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnTo>
		<copyColumnFrom public="1">
			<f a="column:vector3D">
				<t path="UInt"/>
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyColumnFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<c path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<e path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><c path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><c path="Float"/></determinant>
		<new public="1" set="method"><f a="?v">
	<c path="flash.Vector"><c path="Float"/></c>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="C:\Motion-Twin\haxe\std/flash/geom/Orientation3D.hx">
		<QUATERNION/>
		<EULER_ANGLES/>
		<AXIS_ANGLE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="C:\Motion-Twin\haxe\std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><c path="Float"/></focalLength>
		<fieldOfView public="1"><c path="Float"/></fieldOfView>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="C:\Motion-Twin\haxe\std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourcePoint">
				<c path="flash.geom.Point"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="C:\Motion-Twin\haxe\std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setTo public="1">
			<f a="xa:ya:widtha:heighta">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<setEmpty public="1" set="method"><f a=""><e path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><e path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<copyFrom public="1">
			<f a="sourceRect">
				<c path="flash.geom.Rectangle"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><c path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><c path="Float"/></right>
		<left public="1"><c path="Float"/></left>
		<height public="1"><c path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><c path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="C:\Motion-Twin\haxe\std/flash/geom/Transform.hx" extern="1">
		<getRelativeMatrix3D public="1" set="method">
			<f a="relativeTo">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Matrix3D"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</getRelativeMatrix3D>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<perspectiveProjection public="1">
			<c path="flash.geom.PerspectiveProjection"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</perspectiveProjection>
		<matrix3D public="1">
			<c path="flash.geom.Matrix3D"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</matrix3D>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="C:\Motion-Twin\haxe\std/flash/geom/Vector3D.hx" extern="1">
		<X_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></X_AXIS>
		<Y_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Y_AXIS>
		<Z_AXIS public="1" static="1"><c path="flash.geom.Vector3D"/></Z_AXIS>
		<angleBetween public="1" set="method" static="1"><f a="a:b">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></angleBetween>
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></distance>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<setTo public="1">
			<f a="xa:ya:za">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</setTo>
		<scaleBy public="1" set="method"><f a="s">
	<c path="Float"/>
	<e path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><e path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><c path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><e path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<e path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<copyFrom public="1">
			<f a="sourceVector3D">
				<c path="flash.geom.Vector3D"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</copyFrom>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><c path="Float"/></z>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<w public="1"><c path="Float"/></w>
		<lengthSquared public="1" set="null"><c path="Float"/></lengthSquared>
		<length public="1" set="null"><c path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y:?z:?w">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.Camera" params="" file="C:\Motion-Twin\haxe\std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<_scanHardware public="1" static="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</_scanHardware>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setCursor>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<position public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</position>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<motionTimeout public="1" set="null"><c path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><c path="Int"/></motionLevel>
		<loopback public="1" set="null"><e path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<index public="1" set="null"><c path="Int"/></index>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="C:\Motion-Twin\haxe\std/flash/media/ID3Info.hx" extern="1">
		<year public="1"><c path="String"/></year>
		<track public="1"><c path="String"/></track>
		<songName public="1"><c path="String"/></songName>
		<genre public="1"><c path="String"/></genre>
		<comment public="1"><c path="String"/></comment>
		<artist public="1"><c path="String"/></artist>
		<album public="1"><c path="String"/></album>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Microphone" params="" file="C:\Motion-Twin\haxe\std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getEnhancedMicrophone public="1" static="1">
			<f a="?index">
				<c path="Int"/>
				<c path="flash.media.Microphone"/>
			</f>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</getEnhancedMicrophone>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<c path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<e path="Bool"/>
	<e path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<c path="Float"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<e path="Bool"/>
	<e path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><e path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><c path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><c path="Float"/></silenceLevel>
		<rate public="1"><c path="Int"/></rate>
		<noiseSuppressionLevel public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</noiseSuppressionLevel>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><e path="Bool"/></muted>
		<index public="1" set="null"><c path="Int"/></index>
		<gain public="1"><c path="Float"/></gain>
		<framesPerPacket public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</framesPerPacket>
		<enhancedOptions public="1">
			<c path="flash.media.MicrophoneEnhancedOptions"/>
			<meta><m n=":require"><e>flash10_2</e></m></meta>
		</enhancedOptions>
		<encodeQuality public="1">
			<c path="Int"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</encodeQuality>
		<enableVAD public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</enableVAD>
		<codec public="1">
			<e path="flash.media.SoundCodec"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</codec>
		<activityLevel public="1" set="null"><c path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="C:\Motion-Twin\haxe\std/flash/media/MicrophoneEnhancedMode.hx">
		<SPEAKER_MUTE/>
		<OFF/>
		<HEADSET/>
		<HALF_DUPLEX/>
		<FULL_DUPLEX/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="C:\Motion-Twin\haxe\std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><e path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><c path="Int"/></isVoiceDetected>
		<echoPath public="1"><c path="Int"/></echoPath>
		<autoGain public="1"><e path="Bool"/></autoGain>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.media.Sound" params="" file="C:\Motion-Twin\haxe\std/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<play public="1" set="method"><f a="?startTime:?loops:?sndTransform">
	<c path="Float"/>
	<c path="Int"/>
	<c path="flash.media.SoundTransform"/>
	<c path="flash.media.SoundChannel"/>
</f></play>
		<loadPCMFromByteArray public="1">
			<f a="bytes:samples:?format:?stereo:?sampleRate">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<c path="String"/>
				<e path="Bool"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadPCMFromByteArray>
		<loadCompressedDataFromByteArray public="1">
			<f a="bytes:bytesLength">
				<c path="flash.utils.ByteArray"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</loadCompressedDataFromByteArray>
		<load public="1" set="method"><f a="stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></load>
		<extract public="1" set="method">
			<f a="target:length:?startPosition">
				<c path="flash.utils.ByteArray"/>
				<c path="Float"/>
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</extract>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<url public="1" set="null"><c path="String"/></url>
		<length public="1" set="null"><c path="Float"/></length>
		<isURLInaccessible public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isURLInaccessible>
		<isBuffering public="1" set="null"><e path="Bool"/></isBuffering>
		<id3 public="1" set="null"><c path="flash.media.ID3Info"/></id3>
		<bytesTotal public="1" set="null"><c path="Int"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?stream:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.media.SoundLoaderContext"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundChannel" params="" file="C:\Motion-Twin\haxe\std/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method"><f a=""><e path="Void"/></f></stop>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<rightPeak public="1" set="null"><c path="Float"/></rightPeak>
		<position public="1" set="null"><c path="Float"/></position>
		<leftPeak public="1" set="null"><c path="Float"/></leftPeak>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="C:\Motion-Twin\haxe\std/flash/media/SoundCodec.hx">
		<SPEEX/>
		<PCMU/>
		<PCMA/>
		<NELLYMOSER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundLoaderContext" params="" file="C:\Motion-Twin\haxe\std/flash/media/SoundLoaderContext.hx" extern="1">
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<new public="1" set="method"><f a="?bufferTime:?checkPolicyFile">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.media.SoundTransform" params="" file="C:\Motion-Twin\haxe\std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><c path="Float"/></volume>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<pan public="1"><c path="Float"/></pan>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="C:\Motion-Twin\haxe\std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<e path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><c path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><c path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><c path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1"><f a=""><e path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="C:\Motion-Twin\haxe\std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<c path="Int"/>
	<e path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><c path="Int"/></width>
		<quality public="1" set="null"><c path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><c path="Int"/></keyFrameInterval>
		<height public="1" set="null"><c path="Int"/></height>
		<fps public="1" set="null"><c path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><c path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="C:\Motion-Twin\haxe\std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<e path="Bool"/>
	<d/>
	<e path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><e path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<unconnectedPeerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</unconnectedPeerStreams>
		<proxyType public="1"><c path="String"/></proxyType>
		<protocol public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</protocol>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<nearID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearID>
		<maxPeerConnections public="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPeerConnections>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><e path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="C:\Motion-Twin\haxe\std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<CONNECT_TO_FMS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</CONNECT_TO_FMS>
		<DIRECT_CONNECTIONS public="1" static="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</DIRECT_CONNECTIONS>
		<togglePause public="1" set="method"><f a=""><e path="Void"/></f></togglePause>
		<step public="1">
			<f a="frames">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</step>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<c path="Float"/>
	<e path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><e path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<c path="Float"/>
	<e path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<e path="Bool"/>
	<e path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></publish>
		<play2 public="1" set="method">
			<f a="param">
				<c path="flash.net.NetStreamPlayOptions"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</play2>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><e path="Void"/></f></pause>
		<onPeerConnect public="1" set="method">
			<f a="subscriber">
				<c path="flash.net.NetStream"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</onPeerConnect>
		<dispose public="1">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash11_2</e></m></meta>
		</dispose>
		<close public="1" set="method"><f a=""><e path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<c path="Int"/>
	<e path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<e path="Void"/>
</f></attachAudio>
		<attach public="1">
			<f a="connection">
				<c path="flash.net.NetConnection"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</attach>
		<appendBytesAction public="1">
			<f a="netStreamAppendBytesAction">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytesAction>
		<appendBytes public="1">
			<f a="bytes">
				<c path="flash.utils.ByteArray"/>
				<e path="Void"/>
			</f>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</appendBytes>
		<videoStreamSettings public="1">
			<c path="flash.media.VideoStreamSettings"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</videoStreamSettings>
		<videoSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoSampleAccess>
		<videoReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoReliable>
		<videoCodec public="1" set="null"><t path="UInt"/></videoCodec>
		<useJitterBuffer public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</useJitterBuffer>
		<useHardwareDecoder public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</useHardwareDecoder>
		<time public="1" set="null"><c path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<peerStreams public="1" set="null">
			<c path="Array"><d/></c>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</peerStreams>
		<objectEncoding public="1" set="null"><t path="UInt"/></objectEncoding>
		<nearNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</nearNonce>
		<multicastWindowDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastWindowDuration>
		<multicastRelayMarginDuration public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastRelayMarginDuration>
		<multicastPushNeighborLimit public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastPushNeighborLimit>
		<multicastInfo public="1">
			<c path="flash.net.NetStreamMulticastInfo"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastInfo>
		<multicastFetchPeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastFetchPeriod>
		<multicastAvailabilityUpdatePeriod public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilityUpdatePeriod>
		<multicastAvailabilitySendToAll public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</multicastAvailabilitySendToAll>
		<maxPauseBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</maxPauseBufferTime>
		<liveDelay public="1" set="null"><c path="Float"/></liveDelay>
		<info public="1" set="null">
			<c path="flash.net.NetStreamInfo"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</info>
		<inBufferSeek public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</inBufferSeek>
		<farNonce public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farNonce>
		<farID public="1" set="null">
			<c path="String"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</farID>
		<decodedFrames public="1" set="null"><t path="UInt"/></decodedFrames>
		<dataReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</dataReliable>
		<currentFPS public="1" set="null"><c path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bufferTimeMax public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</bufferTimeMax>
		<bufferTime public="1"><c path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><c path="Float"/></bufferLength>
		<backBufferTime public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferTime>
		<backBufferLength public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</backBufferLength>
		<audioSampleAccess public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioSampleAccess>
		<audioReliable public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</audioReliable>
		<audioCodec public="1" set="null"><t path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="C:\Motion-Twin\haxe\std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoLossRate public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</videoLossRate>
		<videoBytesPerSecond public="1" set="null"><c path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><c path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><c path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><c path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><c path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><c path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><e path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><c path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><c path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><c path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><c path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><c path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><c path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><c path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><c path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><c path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><c path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><c path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><c path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><c path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="C:\Motion-Twin\haxe\std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><c path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><c path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><c path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><c path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><c path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><c path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><c path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><c path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><c path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><c path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><c path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><c path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><c path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><c path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><c path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><c path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><c path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><c path="Float"/></bytesPushedFromPeers>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="C:\Motion-Twin\haxe\std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><c path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<offset public="1">
			<c path="Float"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</offset>
		<len public="1"><c path="Float"/></len>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="C:\Motion-Twin\haxe\std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<e path="Void"/>
</f></new></class>
	<class path="flash.net.URLRequest" params="" file="C:\Motion-Twin\haxe\std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="C:\Motion-Twin\haxe\std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="C:\Motion-Twin\haxe\std/flash/system/ApplicationDomain.hx" extern="1">
		<MIN_DOMAIN_MEMORY_LENGTH public="1" set="null" static="1">
			<t path="UInt"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</MIN_DOMAIN_MEMORY_LENGTH>
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<getQualifiedDefinitionNames public="1">
			<f a=""><c path="flash.Vector"><c path="String"/></c></f>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</getQualifiedDefinitionNames>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<domainMemory public="1">
			<c path="flash.utils.ByteArray"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</domainMemory>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="C:\Motion-Twin\haxe\std/flash/system/ImageDecodingPolicy.hx">
		<ON_LOAD/>
		<ON_DEMAND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="C:\Motion-Twin\haxe\std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<requestedContentParent public="1">
			<c path="flash.display.DisplayObjectContainer"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</requestedContentParent>
		<parameters public="1">
			<d/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</parameters>
		<imageDecodingPolicy public="1">
			<e path="flash.system.ImageDecodingPolicy"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</imageDecodingPolicy>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<allowLoadBytesCodeExecution public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowLoadBytesCodeExecution>
		<allowCodeImport public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</allowCodeImport>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="C:\Motion-Twin\haxe\std/flash/system/SecurityDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain>
		<domainID public="1">
			<c path="String"/>
			<meta><m n=":require"><e>flash11_3</e></m></meta>
		</domainID>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="C:\Motion-Twin\haxe\std/flash/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.Font" params="" file="C:\Motion-Twin\haxe\std/flash/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1"><f a="?enumerateDeviceFonts">
	<e path="Bool"/>
	<c path="Array"><c path="flash.text.Font"/></c>
</f></enumerateFonts>
		<registerFont public="1" set="method" static="1"><f a="font">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></registerFont>
		<hasGlyphs public="1" set="method"><f a="str">
	<c path="String"/>
	<e path="Bool"/>
</f></hasGlyphs>
		<fontType public="1" set="null"><e path="flash.text.FontType"/></fontType>
		<fontStyle public="1" set="null"><e path="flash.text.FontStyle"/></fontStyle>
		<fontName public="1" set="null"><c path="String"/></fontName>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.FontStyle" params="" file="C:\Motion-Twin\haxe\std/flash/text/FontStyle.hx">
		<REGULAR/>
		<ITALIC/>
		<BOLD_ITALIC/>
		<BOLD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.FontType" params="" file="C:\Motion-Twin\haxe\std/flash/text/FontType.hx">
		<EMBEDDED_CFF/>
		<EMBEDDED/>
		<DEVICE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="C:\Motion-Twin\haxe\std/flash/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="C:\Motion-Twin\haxe\std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<isFontCompatible public="1" set="method" static="1">
			<f a="fontName:fontStyle">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</isFontCompatible>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<e path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><c path="Float"/></thickness>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<textInteractionMode public="1">
			<e path="flash.text.TextInteractionMode"/>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</textInteractionMode>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textColor public="1"><t path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><c path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><e path="Bool"/></selectable>
		<scrollV public="1"><c path="Int"/></scrollV>
		<scrollH public="1"><c path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<multiline public="1"><e path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxChars public="1"><c path="Int"/></maxChars>
		<length public="1" set="null"><c path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<border public="1"><e path="Bool"/></border>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<background public="1"><e path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><e path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><c path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><c path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><c path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><c path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><c path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><e path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><e path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><c path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><t path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><e path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><e path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><c path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<c path="Float"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextFormatAlign.hx">
		<START/>
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<END/>
		<CENTER/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextInteractionMode.hx">
		<SELECTION/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><c path="Float"/></x>
		<width public="1"><c path="Float"/></width>
		<leading public="1"><c path="Float"/></leading>
		<height public="1"><c path="Float"/></height>
		<descent public="1"><c path="Float"/></descent>
		<ascent public="1"><c path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="C:\Motion-Twin\haxe\std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="C:\Motion-Twin\haxe\std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<isSupported public="1" static="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10_1</e></m></meta>
		</isSupported>
		<hideBuiltInItems public="1" set="method"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<link public="1">
			<c path="flash.net.URLRequest"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</link>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clipboardMenu public="1">
			<e path="Bool"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardMenu>
		<clipboardItems public="1">
			<c path="flash.ui.ContextMenuClipboardItems"/>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clipboardItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="C:\Motion-Twin\haxe\std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><e path="Bool"/></zoom>
		<save public="1"><e path="Bool"/></save>
		<rewind public="1"><e path="Bool"/></rewind>
		<quality public="1"><e path="Bool"/></quality>
		<print public="1"><e path="Bool"/></print>
		<play public="1"><e path="Bool"/></play>
		<loop public="1"><e path="Bool"/></loop>
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="C:\Motion-Twin\haxe\std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><e path="Bool"/></selectAll>
		<paste public="1"><e path="Bool"/></paste>
		<cut public="1"><e path="Bool"/></cut>
		<copy public="1"><e path="Bool"/></copy>
		<clear public="1"><e path="Bool"/></clear>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="C:\Motion-Twin\haxe\std/flash/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
		<D_PAD/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.utils.IDataInput" params="" file="C:\Motion-Twin\haxe\std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="C:\Motion-Twin\haxe\std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.utils.ByteArray" params="" file="C:\Motion-Twin\haxe\std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<implements path="flash.utils.IDataOutput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a=""><e path="Void"/></f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><c path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><c path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><c path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><c path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><e path="Bool"/></f></readBoolean>
		<inflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</inflate>
		<deflate public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</deflate>
		<compress public="1" set="method"><f a=""><e path="Void"/></f></compress>
		<clear public="1" set="method">
			<f a=""><e path="Void"/></f>
			<meta><m n=":require"><e>flash10</e></m></meta>
		</clear>
		<position public="1"><t path="UInt"/></position>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<length public="1"><t path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.utils.Dictionary" params="" file="C:\Motion-Twin\haxe\std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.utils.Endian" params="" file="C:\Motion-Twin\haxe\std/flash/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.utils.Namespace" params="" file="C:\Motion-Twin\haxe\std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.TypedDictionary" params="K:T" file="C:\Motion-Twin\haxe\std/flash/utils/TypedDictionary.hx">
		<extends path="flash.utils.Dictionary"/>
		<iterator public="1" set="method" line="52"><f a=""><t path="Iterator"><c path="flash.utils.TypedDictionary.K"/></t></f></iterator>
		<keys public="1" get="inline" set="null" line="48"><f a=""><c path="Array"><c path="flash.utils.TypedDictionary.K"/></c></f></keys>
		<delete public="1" get="inline" set="null" line="44"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<e path="Void"/>
</f></delete>
		<exists public="1" get="inline" set="null" line="40"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<e path="Bool"/>
</f></exists>
		<set public="1" get="inline" set="null" line="36"><f a="k:v">
	<c path="flash.utils.TypedDictionary.K"/>
	<c path="flash.utils.TypedDictionary.T"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="32"><f a="k">
	<c path="flash.utils.TypedDictionary.K"/>
	<t path="Null"><c path="flash.utils.TypedDictionary.T"/></t>
</f></get>
		<new public="1" set="method" line="30"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>This is a typed version of the Flash9 Dictionary class.</haxe_doc>
	</class>
	<class path="flash.xml.XML" params="" file="C:\Motion-Twin\haxe\std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<d/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><d/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="C:\Motion-Twin\haxe\std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toJSON public="1">
			<f a="k">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":require"><e>flash11</e></m></meta>
		</toJSON>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><d/></f></name>
		<localName public="1" set="method"><f a=""><d/></f></localName>
		<length public="1" set="method"><f a=""><c path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><e path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><c path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="guise.Guise" params="" file="../src/guise/Guise.hx">
		<_parent><c path="composure.core.ComposeGroup"/></_parent>
		<stage public="1" set="null"><c path="guise.core.GuiseItem"/></stage>
		<window public="1" set="null"><c path="guise.core.GuiseItem"/></window>
		<get_root public="1" set="method" line="15"><f a=""><c path="composure.core.ComposeRoot"/></f></get_root>
		<root public="1" get="get_root" set="null"><c path="composure.core.ComposeRoot"/></root>
		<new public="1" set="method" line="24"><f a="?parent">
	<c path="composure.core.ComposeGroup"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.ControlLayers" params="" file="../src/guise/controls/ControlLayers.hx">
		<BACKING public="1" line="9" static="1"><c path="String"/></BACKING>
		<LABEL_TEXT public="1" line="11" static="1"><c path="String"/></LABEL_TEXT>
		<INPUT_TEXT public="1" line="13" static="1"><c path="String"/></INPUT_TEXT>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.ControlLogic" params="" file="../src/guise/controls/ControlLogic.hx">
		<install public="1" set="method" line="20" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.IClick" params="" file="../src/guise/controls/data/IClick.hx" interface="1">
		<clicked public="1" get="get_clicked" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c></clicked>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.IInputPrompt" params="" file="../src/guise/controls/data/IInputPrompt.hx" interface="1">
		<setPrompt public="1" set="method"><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></setPrompt>
		<prompt public="1" set="null"><c path="String"/></prompt>
		<promptChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.IInputPrompt"/></c></promptChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.InputPrompt" params="" file="../src/guise/controls/data/IInputPrompt.hx" module="guise.controls.data.IInputPrompt">
		<implements path="guise.controls.data.IInputPrompt"/>
		<setPrompt public="1" set="method" line="32"><f a="prompt">
	<c path="String"/>
	<e path="Void"/>
</f></setPrompt>
		<prompt public="1" set="null"><c path="String"/></prompt>
		<promptChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.IInputPrompt"/></c></promptChanged>
		<new public="1" set="method" line="26"><f a="?prompt">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.data.ISelected" params="" file="../src/guise/controls/data/ISelected.hx" interface="1">
		<set public="1" set="method"><f a="selected">
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<selected public="1" set="null"><e path="Bool"/></selected>
		<selectedChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ISelected"/></c></selectedChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.Selected" params="" file="../src/guise/controls/data/ISelected.hx" module="guise.controls.data.ISelected">
		<implements path="guise.controls.data.ISelected"/>
		<set public="1" set="method" line="32"><f a="selected">
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<selected public="1" set="null"><e path="Bool"/></selected>
		<selectedChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ISelected"/></c></selectedChanged>
		<new public="1" set="method" line="26"><f a="?selected">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.data.ITextLabel" params="" file="../src/guise/controls/data/ITextLabel.hx" interface="1">
		<set public="1" set="method"><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<text public="1" set="null"><c path="String"/></text>
		<textChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ITextLabel"/></c></textChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.controls.data.TextLabel" params="" file="../src/guise/controls/data/ITextLabel.hx" module="guise.controls.data.ITextLabel">
		<implements path="guise.controls.data.ITextLabel"/>
		<set public="1" set="method" line="32"><f a="text">
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<text public="1" set="null"><c path="String"/></text>
		<textChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.controls.data.ITextLabel"/></c></textChanged>
		<new public="1" set="method" line="26"><f a="?text">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.logic.input.ButtonClickTrait" params="" file="../src/guise/controls/logic/input/ButtonClickTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<implements path="guise.controls.data.IClick"/>
		<get_clicked set="method" line="24"><f a=""><c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c></f></get_clicked>
		<_clicked><c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c></_clicked>
		<dispatchBundle set="method" line="105"><f a="bundle">
	<c path="guise.controls.logic.input.ClickTypeBundle"/>
	<e path="Void"/>
</f></dispatchBundle>
		<onDoubleClicked set="method" line="89"><f a="info">
	<c path="guise.platform.types.ClickInfo"/>
	<e path="Void"/>
</f></onDoubleClicked>
		<onClicked set="method" line="70"><f a="info">
	<c path="guise.platform.types.ClickInfo"/>
	<e path="Void"/>
</f></onClicked>
		<findBundle set="method" line="61"><f a="clickType">
	<e path="guise.controls.logic.input.ClickType"/>
	<c path="guise.controls.logic.input.ClickTypeBundle"/>
</f></findBundle>
		<unbindFromClick public="1" set="method" line="55"><f a="handler:clickType">
	<f a="">
		<c path="guise.controls.logic.input.ButtonClickTrait"/>
		<e path="Void"/>
	</f>
	<e path="guise.controls.logic.input.ClickType"/>
	<e path="Void"/>
</f></unbindFromClick>
		<bindToClick public="1" set="method" line="47"><f a="handler:clickType">
	<f a="">
		<c path="guise.controls.logic.input.ButtonClickTrait"/>
		<e path="Void"/>
	</f>
	<e path="guise.controls.logic.input.ClickType"/>
	<e path="Void"/>
</f></bindToClick>
		<onMouseClickRemove set="method" line="41"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickRemove>
		<onMouseClickAdd set="method" line="36"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickAdd>
		<clickTypeBundles><c path="Array"><c path="guise.controls.logic.input.ClickTypeBundle"/></c></clickTypeBundles>
		<_mouseClickable><c path="guise.platform.types.IMouseClickable"/></_mouseClickable>
		<clicked public="1" get="get_clicked" set="null">
			<c path="msignal.Signal1"><c path="guise.controls.data.IClick"/></c>
			<meta><m n="lazyInst"/></meta>
		</clicked>
		<set_active public="1" set="method" line="18"><f a="value">
	<c path="guise.traits.core.IActive"/>
	<c path="guise.traits.core.IActive"/>
</f></set_active>
		<active public="1" set="set_active">
			<c path="guise.traits.core.IActive"/>
			<meta><m n="inject"/></meta>
		</active>
		<new public="1" set="method" line="30"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guise.controls.logic.input.ClickType" params="" file="../src/guise/controls/logic/input/ButtonClickTrait.hx" module="guise.controls.logic.input.ButtonClickTrait">
		<RightClick/>
		<LeftClick/>
		<DoubleLeftClick/>
		<Advanced a="left:double:alt:ctrl:shift">
			<e path="Bool"/>
			<e path="Bool"/>
			<t path="Null"><e path="Bool"/></t>
			<t path="Null"><e path="Bool"/></t>
			<t path="Null"><e path="Bool"/></t>
		</Advanced>
	</enum>
	<class path="guise.controls.logic.input.ClickTypeBundle" params="" file="../src/guise/controls/logic/input/ButtonClickTrait.hx" module="guise.controls.logic.input.ButtonClickTrait">
		<signaler public="1"><c path="msignal.Signal1"><c path="guise.controls.logic.input.ButtonClickTrait"/></c></signaler>
		<clickType public="1"><e path="guise.controls.logic.input.ClickType"/></clickType>
		<new public="1" set="method" line="119"><f a="owner:clickType">
	<c path="guise.controls.logic.input.ButtonClickTrait"/>
	<e path="guise.controls.logic.input.ClickType"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.controls.logic.input.ClickToggleSelect" params="" file="../src/guise/controls/logic/input/ClickToggleSelect.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onClicked set="method" line="34"><f a="info">
	<c path="guise.platform.types.ClickInfo"/>
	<e path="Void"/>
</f></onClicked>
		<onMouseClickRemove set="method" line="29"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickRemove>
		<onMouseClickAdd set="method" line="25"><f a="access">
	<c path="guise.platform.types.IMouseClickable"/>
	<e path="Void"/>
</f></onMouseClickAdd>
		<_mouseClickable><c path="guise.platform.types.IMouseClickable"/></_mouseClickable>
		<selected public="1">
			<c path="guise.controls.data.ISelected"/>
			<meta><m n="inject"/></meta>
		</selected>
		<new public="1" set="method" line="20"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.input.MouseOverTrait" params="" file="../src/guise/controls/logic/input/MouseOverTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<assessMouseOver set="method" line="64"><f a=""><e path="Void"/></f></assessMouseOver>
		<onRolledOut set="method" line="59"><f a="?info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOut>
		<onRolledOver set="method" line="55"><f a="?info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOver>
		<onMouseIntRemove set="method" line="49"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntRemove>
		<onMouseIntAdd set="method" line="43"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntAdd>
		<_mouseInteractions><c path="guise.platform.types.IMouseInteractions"/></_mouseInteractions>
		<_mouseOver><e path="Bool"/></_mouseOver>
		<get_mouseOverChanged set="method" line="26"><f a=""><c path="msignal.Signal1"><c path="guise.controls.logic.input.MouseOverTrait"/></c></f></get_mouseOverChanged>
		<mouseOverChanged public="1" get="get_mouseOverChanged" set="null"><c path="msignal.Signal1"><c path="guise.controls.logic.input.MouseOverTrait"/></c></mouseOverChanged>
		<_mouseOverChanged><c path="msignal.Signal1"><c path="guise.controls.logic.input.MouseOverTrait"/></c></_mouseOverChanged>
		<mouseOver public="1" set="null"><e path="Bool"/></mouseOver>
		<set_active public="1" set="method" line="18"><f a="value">
	<c path="guise.traits.core.IActive"/>
	<c path="guise.traits.core.IActive"/>
</f></set_active>
		<active public="1" set="set_active">
			<c path="guise.traits.core.IActive"/>
			<meta><m n="inject"/></meta>
		</active>
		<new public="1" set="method" line="37"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.input.TextInputPrompt" params="" file="../src/guise/controls/logic/input/TextInputPrompt.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onFocusedChanged set="method" line="88"><f a="from">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusedChanged>
		<onPromptChanged set="method" line="82"><f a="from">
	<c path="guise.controls.data.IInputPrompt"/>
	<e path="Void"/>
</f></onPromptChanged>
		<onTextChanged set="method" line="73"><f a="from">
	<c path="guise.platform.types.ITextInputAccess"/>
	<e path="Void"/>
</f></onTextChanged>
		<onFocusRemove set="method" line="69"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusRemove>
		<onFocusAdd set="method" line="64"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusAdd>
		<onInputRemove set="method" line="60"><f a="access">
	<c path="guise.platform.types.ITextInputAccess"/>
	<e path="Void"/>
</f></onInputRemove>
		<onInputAdd set="method" line="54"><f a="access">
	<c path="guise.platform.types.ITextInputAccess"/>
	<e path="Void"/>
</f></onInputAdd>
		<_focused><e path="Bool"/></_focused>
		<_ignoreChanges><e path="Bool"/></_ignoreChanges>
		<_showingPrompt><e path="Bool"/></_showingPrompt>
		<_focus><c path="guise.platform.IFocusableAccess"/></_focus>
		<_input><c path="guise.platform.types.ITextInputAccess"/></_input>
		<set_inputPrompt set="method" line="29"><f a="inputPrompt">
	<c path="guise.controls.data.IInputPrompt"/>
	<c path="guise.controls.data.IInputPrompt"/>
</f></set_inputPrompt>
		<inputPrompt public="1" set="set_inputPrompt">
			<c path="guise.controls.data.IInputPrompt"/>
			<meta><m n="inject"/></meta>
		</inputPrompt>
		<set_textLabel set="method" line="19"><f a="value">
	<c path="guise.controls.data.ITextLabel"/>
	<c path="guise.controls.data.ITextLabel"/>
</f></set_textLabel>
		<textLabel public="1" set="set_textLabel">
			<c path="guise.controls.data.ITextLabel"/>
			<meta><m n="inject"/></meta>
		</textLabel>
		<new public="1" set="method" line="47"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.states.ButtonStateMapper" params="" file="../src/guise/controls/logic/states/ButtonStateMapper.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onRolledOut set="method" line="63"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOut>
		<onRolledOver set="method" line="59"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onRolledOver>
		<onReleased set="method" line="55"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onReleased>
		<onPressed set="method" line="51"><f a="info">
	<c path="guise.platform.types.MouseInfo"/>
	<e path="Void"/>
</f></onPressed>
		<onMouseIntRemove set="method" line="42"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntRemove>
		<onMouseIntAdd set="method" line="35"><f a="access">
	<c path="guise.platform.types.IMouseInteractions"/>
	<e path="Void"/>
</f></onMouseIntAdd>
		<_mouseInteractions><c path="guise.platform.types.IMouseInteractions"/></_mouseInteractions>
		<overState><c path="guise.traits.states.State"><e path="guise.traits.states.ButtonOverState"/></c></overState>
		<downState><c path="guise.traits.states.State"><e path="guise.traits.states.ButtonDownState"/></c></downState>
		<new public="1" set="method" line="21"><f a="?layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.states.FocusStateMapper" params="" file="../src/guise/controls/logic/states/FocusStateMapper.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onFocusedChanged set="method" line="39"><f a="from">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusedChanged>
		<onFocusRemove set="method" line="35"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusRemove>
		<onFocusAdd set="method" line="30"><f a="access">
	<c path="guise.platform.IFocusableAccess"/>
	<e path="Void"/>
</f></onFocusAdd>
		<_focusable><c path="guise.platform.IFocusableAccess"/></_focusable>
		<focusedState><c path="guise.traits.states.State"><e path="guise.traits.states.FocusState"/></c></focusedState>
		<new public="1" set="method" line="20"><f a="layerName">
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.controls.logic.states.SelectableStateMapper" params="" file="../src/guise/controls/logic/states/SelectableStateMapper.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onSelectedChanged set="method" line="47"><f a="from">
	<c path="guise.controls.data.ISelected"/>
	<e path="Void"/>
</f></onSelectedChanged>
		<selectedState><c path="guise.traits.states.State"><e path="guise.traits.states.SelectedState"/></c></selectedState>
		<selectableState><c path="guise.traits.states.State"><e path="guise.traits.states.SelectableState"/></c></selectableState>
		<set_selected set="method" line="16"><f a="value">
	<c path="guise.controls.data.ISelected"/>
	<c path="guise.controls.data.ISelected"/>
</f></set_selected>
		<selected public="1" set="set_selected">
			<c path="guise.controls.data.ISelected"/>
			<meta><m n="inject"/></meta>
		</selected>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.AbsPosAwareTrait" params="" file="../src/guise/core/AbsPosAwareTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<posChanged set="method" line="51"><f a=""><e path="Void"/></f></posChanged>
		<onPosChanged set="method" line="48"><f a="position">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></onPosChanged>
		<assessPosition set="method" line="29"><f a=""><e path="Void"/></f></assessPosition>
		<set_posInjected set="method" line="24"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<c path="guise.traits.core.IPosition"/>
</f></set_posInjected>
		<posInjected public="1" set="set_posInjected">
			<c path="guise.traits.core.IPosition"/>
			<meta><m n="inject"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</posInjected>
		<set_posExplicit set="method" line="14"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<c path="guise.traits.core.IPosition"/>
</f></set_posExplicit>
		<posExplicit public="1" set="set_posExplicit"><c path="guise.traits.core.IPosition"/></posExplicit>
		<position public="1" set="null"><c path="guise.traits.core.IPosition"/></position>
		<new public="1" set="method" line="43"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.AbsPosSizeAwareTrait" params="" file="../src/guise/core/AbsPosSizeAwareTrait.hx">
		<extends path="guise.core.AbsPosAwareTrait"/>
		<sizeChangedInvalid set="method" line="46"><f a=""><e path="Void"/></f></sizeChangedInvalid>
		<sizeChangedValid set="method" line="43"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></sizeChangedValid>
		<sizeChanged set="method" line="33"><f a=""><e path="Void"/></f></sizeChanged>
		<_sizeAware><c path="guise.core.AbsSizeAwareTrait"/></_sizeAware>
		<set_sizeExplicit set="method" line="21"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<c path="guise.traits.core.ISize"/>
</f></set_sizeExplicit>
		<get_sizeExplicit set="method" line="18"><f a=""><c path="guise.traits.core.ISize"/></f></get_sizeExplicit>
		<sizeExplicit public="1" get="get_sizeExplicit" set="set_sizeExplicit"><c path="guise.traits.core.ISize"/></sizeExplicit>
		<get_size set="method" line="13"><f a=""><c path="guise.traits.core.ISize"/></f></get_size>
		<size public="1" get="get_size" set="null"><c path="guise.traits.core.ISize"/></size>
		<new public="1" set="method" line="27"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.AbsSizeAwareTrait" params="" file="../src/guise/core/AbsSizeAwareTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<sizeChangedInvalid set="dynamic" line="68"><f a=""><e path="Void"/></f></sizeChangedInvalid>
		<sizeChangedValid set="dynamic" line="65"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></sizeChangedValid>
		<sizeChanged set="dynamic" line="55"><f a=""><e path="Void"/></f></sizeChanged>
		<onSizeChanged set="method" line="51"><f a="size">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></onSizeChanged>
		<assessSize set="method" line="29"><f a=""><e path="Void"/></f></assessSize>
		<set_sizeInjected set="method" line="24"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<c path="guise.traits.core.ISize"/>
</f></set_sizeInjected>
		<sizeInjected public="1" set="set_sizeInjected">
			<c path="guise.traits.core.ISize"/>
			<meta><m n="inject"/></meta>
			<haxe_doc>* @private</haxe_doc>
		</sizeInjected>
		<set_sizeExplicit set="method" line="14"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<c path="guise.traits.core.ISize"/>
</f></set_sizeExplicit>
		<sizeExplicit public="1" set="set_sizeExplicit"><c path="guise.traits.core.ISize"/></sizeExplicit>
		<size public="1" set="null"><c path="guise.traits.core.ISize"/></size>
		<new public="1" set="method" line="43"><f a="?sizeChanged:?sizeChangedValid:?sizeChangedInvalid">
	<f a=""><e path="Void"/></f>
	<f a=":">
		<c path="Float"/>
		<c path="Float"/>
		<e path="Void"/>
	</f>
	<f a=""><e path="Void"/></f>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.core.GuiseItem" params="" file="../src/guise/core/GuiseItem.hx">
		<extends path="composure.core.ComposeGroup"/>
		<createActive set="method" line="41"><f a=""><e path="Void"/></f></createActive>
		<createSize set="method" line="37"><f a="?w:?h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createSize>
		<createPosition set="method" line="33"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createPosition>
		<active public="1" set="null"><c path="guise.traits.core.IActive"/></active>
		<size public="1" set="null"><c path="guise.traits.core.ISize"/></size>
		<position public="1" set="null"><c path="guise.traits.core.IPosition"/></position>
		<new public="1" set="method" line="26"><f a="?x:?y:?w:?h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* This class provides a simple setup for many of the UI elements.
 * I should be considered a default setup, but never the superclass of all UI elements.
 * Alternative configurations can and will exist which replace or reconfigure these core traits.
 * 
 * 
 * @author Tom Byrne</haxe_doc>
	</class>
	<typedef path="guise.geom.Matrix" params="" file="../src/guise/geom/Matrix.hx"><t path="nme.geom.Matrix"/></typedef>
	<class path="guise.layer.LayerOrderer" params="" file="../src/guise/layer/LayerOrderer.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<checkDepths set="method" line="53"><f a=""><e path="Void"/></f></checkDepths>
		<onLayeringRemove public="1" set="method" line="48"><f a="access">
	<c path="guise.platform.types.ILayerOrderAccess"/>
	<e path="Void"/>
</f></onLayeringRemove>
		<onLayeringChanged set="method" line="45"><f a="from">
	<c path="guise.platform.types.ILayerOrderAccess"/>
	<e path="Void"/>
</f></onLayeringChanged>
		<onLayeringAdd public="1" set="method" line="38"><f a="access">
	<c path="guise.platform.types.ILayerOrderAccess"/>
	<e path="Void"/>
</f></onLayeringAdd>
		<_layerOrderAccess><c path="guise.platform.types.ILayerOrderAccess"/></_layerOrderAccess>
		<set_sorting set="method" line="19"><f a="value">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></set_sorting>
		<sorting public="1" set="set_sorting"><c path="Array"><c path="String"/></c></sorting>
		<new public="1" set="method" line="29"><f a="?sorting:?childMode">
	<c path="Array"><c path="String"/></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.layout.AbstractLayout" params="InfoType" file="../src/guise/layout/AbstractLayout.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<getPositionables set="method" line="46"><f a="item">
	<c path="composure.core.ComposeItem"/>
	<t path="Iterable"><c path="guise.layout.IPositionable"/></t>
</f></getPositionables>
		<getItem set="method" line="43"><f a="trait">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
</f></getItem>
		<layoutChild set="method" line="40"><f a="trait">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<e path="Void"/>
</f></layoutChild>
		<removeLayoutChild public="1" set="method" line="35"><f a="trait:item">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></removeLayoutChild>
		<addLayoutChild public="1" set="method" line="30"><f a="trait:item">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></addLayoutChild>
		<_childToItem><t path="cmtc.ds.hash.ObjectHash">
	<c path="guise.layout.AbstractLayout.InfoType"/>
	<c path="composure.core.ComposeItem"/>
</t></_childToItem>
		<_children><c path="Array"><c path="guise.layout.AbstractLayout.InfoType"/></c></_children>
		<new set="method" line="18"><f a="t">
	<c path="Class"><c path="guise.layout.AbstractLayout.InfoType"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.layout.LayoutInfo" params="InfoType" file="../src/guise/layout/AbstractLayout.hx" module="guise.layout.AbstractLayout">
		<get_layoutInfoChanged set="method" line="55"><f a=""><c path="msignal.Signal1"><c path="guise.layout.LayoutInfo.InfoType"/></c></f></get_layoutInfoChanged>
		<_layoutInfoChanged><c path="msignal.Signal1"><c path="guise.layout.LayoutInfo.InfoType"/></c></_layoutInfoChanged>
		<layoutChanged set="method" line="57"><f a=""><e path="Void"/></f></layoutChanged>
		<layoutInfoChanged public="1" get="get_layoutInfoChanged" set="null">
			<c path="msignal.Signal1"><c path="guise.layout.LayoutInfo.InfoType"/></c>
			<meta><m n="lazyInst"/></meta>
		</layoutInfoChanged>
		<meta><m n=":build"><e>'???'</e></m></meta>
	</class>
	<class path="guise.layout.IPositionable" params="" file="../src/guise/layout/IPositionable.hx" interface="1">
		<setPosition public="1" set="method"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.layout.Position" params="" file="../src/guise/layout/Position.hx">
		<extends path="guise.layout.LayoutInfo"><c path="guise.layout.Position"/></extends>
		<setSize public="1" set="method" line="38"><f a="w:h">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setSize>
		<setPosition public="1" set="method" line="33"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<set public="1" set="method" line="26"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<h public="1"><c path="Float"/></h>
		<w public="1"><c path="Float"/></w>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<new public="1" set="method" line="18"><f a="?x:?y:?w:?h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.layout.PositionManager" params="" file="../src/guise/layout/PositionManager.hx">
		<extends path="guise.layout.AbstractLayout"><c path="guise.layout.Position"/></extends>
		<layoutChild set="method" line="16" override="1"><f a="trait">
	<c path="guise.layout.Position"/>
	<e path="Void"/>
</f></layoutChild>
		<new public="1" set="method" line="11"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.IPlatformAccess" params="" file="../src/guise/platform/IPlatformAccess.hx" interface="1">
		<returnAccess public="1" set="method"><f a="access">
	<c path="guise.platform.IAccessType"/>
	<e path="Void"/>
</f></returnAccess>
		<requestAccess public="1" params="AccessType" set="method"><f a="context:accessType:?layerName">
	<c path="composure.core.ComposeItem"/>
	<c path="Class"><c path="requestAccess.AccessType"/></c>
	<c path="String"/>
	<c path="requestAccess.AccessType"/>
</f></requestAccess>
		<accessTypeSupported public="1" set="method"><f a="layerAccess:accessType">
	<e path="Bool"/>
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<e path="Bool"/>
</f></accessTypeSupported>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.AbsPlatformAccess" params="ContInfoType:LayerInfoType" file="../src/guise/platform/AbsPlatformAccess.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<implements path="guise.platform.IPlatformAccess"/>
		<assessBundle set="method" line="136"><f a="bundle:context">
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</c>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></assessBundle>
		<returnAccess public="1" set="method" line="105"><f a="access">
	<c path="guise.platform.IAccessType"/>
	<e path="Void"/>
</f></returnAccess>
		<getContBundle set="method" line="93"><f a="context">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</c>
</f></getContBundle>
		<requestAccess public="1" params="AccessType" set="method" line="74"><f a="context:accessType:?layerName">
	<c path="composure.core.ComposeItem"/>
	<c path="Class"><c path="requestAccess.AccessType"/></c>
	<c path="String"/>
	<c path="requestAccess.AccessType"/>
</f></requestAccess>
		<accessTypeSupported public="1" set="method" line="70"><f a="layerAccess:accessType">
	<e path="Bool"/>
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<e path="Bool"/>
</f></accessTypeSupported>
		<registerLayerAccess params="AccessClass" set="method" line="64"><f a="klass:types:createHandler:destroyHandler">
	<c path="Class"><c path="registerLayerAccess.AccessClass"/></c>
	<c path="Array"><c path="Class"><c path="guise.platform.IAccessType"/></c></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="registerLayerAccess.AccessClass"/>
	</f>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="registerLayerAccess.AccessClass"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></registerLayerAccess>
		<registerAccess params="AccessClass" set="method" line="58"><f a="klass:types:createHandler:destroyHandler">
	<c path="Class"><c path="registerAccess.AccessClass"/></c>
	<c path="Array"><c path="Class"><c path="guise.platform.IAccessType"/></c></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="registerAccess.AccessClass"/>
	</f>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="registerAccess.AccessClass"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></registerAccess>
		<addContainerFurnisher params="TagType" set="method" line="54"><f a="tagType:onCreate:?onDestroy">
	<d/>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="addContainerFurnisher.TagType"/>
		<c path="Array"><d/></c>
	</f>
	<f a="::">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="addContainerFurnisher.TagType"/>
		<c path="Array"><d/></c>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></addContainerFurnisher>
		<_typeToDestroyLayer><t path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</t></_typeToDestroyLayer>
		<_typeToCreateLayer><t path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</t></_typeToCreateLayer>
		<_typeToDestroy><t path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</t></_typeToDestroy>
		<_typeToCreate><t path="cmtc.ds.hash.ObjectHash">
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</t></_typeToCreate>
		<_destroyLayerInfo><f a="">
	<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	<e path="Void"/>
</f></_destroyLayerInfo>
		<_createLayerInfo><f a=":">
	<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
	<c path="String"/>
	<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
</f></_createLayerInfo>
		<_destroyContInfo><f a="">
	<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
	<e path="Void"/>
</f></_destroyContInfo>
		<_createContInfo><f a="">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
</f></_createContInfo>
		<_accessToDetails><t path="cmtc.ds.hash.ObjectHash">
	<c path="guise.platform.IAccessType"/>
	<t path="guise.platform.RequestDetails"/>
</t></_accessToDetails>
		<_contextToBundle><t path="cmtc.ds.hash.ObjectHash">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</c>
</t></_contextToBundle>
		<new public="1" set="method" line="33"><f a="createContInfo:destroyContInfo:createLayerInfo:destroyLayerInfo">
	<f a="">
		<c path="composure.core.ComposeItem"/>
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
	</f>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<e path="Void"/>
	</f>
	<f a=":">
		<c path="guise.platform.AbsPlatformAccess.ContInfoType"/>
		<c path="String"/>
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
	</f>
	<f a="">
		<c path="guise.platform.AbsPlatformAccess.LayerInfoType"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<typedef path="guise.platform.RequestDetails" params="" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess"><a>
	<layerName><c path="String"/></layerName>
	<context><c path="composure.core.ComposeItem"/></context>
</a></typedef>
	<class path="guise.platform.AbsBundle" params="InfoType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<isEmpty public="1" set="method" line="286"><f a=""><e path="Bool"/></f></isEmpty>
		<returnAccess public="1" params="AccessType" set="method" line="274"><f a="access">
	<c path="returnAccess.AccessType"/>
	<e path="Void"/>
</f></returnAccess>
		<requestAccess public="1" params="AccessType" set="method" line="258"><f a="accessType">
	<c path="Class"><c path="requestAccess.AccessType"/></c>
	<c path="requestAccess.AccessType"/>
</f></requestAccess>
		<getAccess public="1" params="AccessType" set="method" line="254"><f a="accessType">
	<c path="Class"><c path="getAccess.AccessType"/></c>
	<c path="getAccess.AccessType"/>
</f></getAccess>
		<_info><c path="guise.platform.AbsBundle.InfoType"/></_info>
		<accessToDestroy public="1"><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a=":">
		<c path="guise.platform.AbsBundle.InfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</t></accessToDestroy>
		<accessToCreate public="1"><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a="">
		<c path="guise.platform.AbsBundle.InfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</t></accessToCreate>
		<_accessToType><t path="cmtc.ds.hash.ObjectHash">
	<c path="guise.platform.IAccessType"/>
	<c path="Class"><c path="guise.platform.IAccessType"/></c>
</t></_accessToType>
		<_createToAccess><t path="cmtc.ds.hash.ObjectHash">
	<f a="">
		<c path="guise.platform.AbsBundle.InfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
	<c path="guise.platform.IAccessType"/>
</t></_createToAccess>
		<_accessToCount><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<c path="Int"/>
</t></_accessToCount>
		<_totalCount><c path="Int"/></_totalCount>
		<new public="1" set="method" line="247"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="guise.platform.ContBundle" params="ContInfoType:LayerInfoType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<extends path="guise.platform.AbsBundle"><c path="guise.platform.ContBundle.ContInfoType"/></extends>
		<cleanup public="1" set="method" line="210"><f a=""><e path="Void"/></f></cleanup>
		<isEmpty public="1" set="method" line="207" override="1"><f a=""><e path="Bool"/></f></isEmpty>
		<returnLayerAccess public="1" params="AccessType" set="method" line="195"><f a="layerName:access">
	<c path="String"/>
	<c path="returnLayerAccess.AccessType"/>
	<e path="Void"/>
</f></returnLayerAccess>
		<requestLayerAccess public="1" params="AccessType" set="method" line="184"><f a="layerName:accessType">
	<c path="String"/>
	<c path="Class"><c path="requestLayerAccess.AccessType"/></c>
	<c path="requestLayerAccess.AccessType"/>
</f></requestLayerAccess>
		<removeDependency public="1" set="method" line="180"><f a=""><e path="Void"/></f></removeDependency>
		<addDependency public="1" set="method" line="177"><f a=""><e path="Void"/></f></addDependency>
		<accessToDestroyLayer public="1"><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a=":">
		<c path="guise.platform.ContBundle.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
		<e path="Void"/>
	</f>
</t></accessToDestroyLayer>
		<accessToCreateLayer public="1"><t path="cmtc.ds.hash.ObjectHash">
	<d/>
	<f a="">
		<c path="guise.platform.ContBundle.LayerInfoType"/>
		<c path="guise.platform.IAccessType"/>
	</f>
</t></accessToCreateLayer>
		<_dependencyCount><c path="Int"/></_dependencyCount>
		<_layerCount><c path="Int"/></_layerCount>
		<_destroyLayerInfo><f a="">
	<c path="guise.platform.ContBundle.LayerInfoType"/>
	<e path="Void"/>
</f></_destroyLayerInfo>
		<_createLayerInfo><f a=":">
	<c path="guise.platform.ContBundle.ContInfoType"/>
	<c path="String"/>
	<c path="guise.platform.ContBundle.LayerInfoType"/>
</f></_createLayerInfo>
		<layers><c path="Hash"><c path="guise.platform.LayerBundle">
	<c path="guise.platform.ContBundle.ContInfoType"/>
	<c path="guise.platform.ContBundle.LayerInfoType"/>
</c></c></layers>
		<contInfo public="1" set="null"><c path="guise.platform.ContBundle.ContInfoType"/></contInfo>
		<new public="1" set="method" line="165"><f a="contInfo:createLayerInfo:destroyLayerInfo">
	<c path="guise.platform.ContBundle.ContInfoType"/>
	<f a=":">
		<c path="guise.platform.ContBundle.ContInfoType"/>
		<c path="String"/>
		<c path="guise.platform.ContBundle.LayerInfoType"/>
	</f>
	<f a="">
		<c path="guise.platform.ContBundle.LayerInfoType"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.LayerBundle" params="ContInfoType:LayerInfoType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<extends path="guise.platform.AbsBundle"><c path="guise.platform.LayerBundle.LayerInfoType"/></extends>
		<cleanup public="1" set="method" line="229"><f a=""><e path="Void"/></f></cleanup>
		<name public="1"><c path="String"/></name>
		<layerInfo public="1" set="null"><c path="guise.platform.LayerBundle.LayerInfoType"/></layerInfo>
		<new public="1" set="method" line="222"><f a="layerInfo">
	<c path="guise.platform.LayerBundle.LayerInfoType"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.FurnisherBundle" params="ContInfoType:LayerInfoType:TagType" file="../src/guise/platform/AbsPlatformAccess.hx" module="guise.platform.AbsPlatformAccess">
		<onRemove set="method" line="328"><f a="tag:context">
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onRemove>
		<onAdd set="method" line="319"><f a="tag:context">
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></onAdd>
		<_tagToTraits><t path="cmtc.ds.hash.ObjectHash">
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
</t></_tagToTraits>
		<_assessBundle><f a=":">
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.FurnisherBundle.ContInfoType"/>
		<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
	</c>
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></_assessBundle>
		<_getContBundle><f a="">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.ContBundle">
		<c path="guise.platform.FurnisherBundle.ContInfoType"/>
		<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
	</c>
</f></_getContBundle>
		<_onDestroy><t path="Null"><f a="::">
	<c path="guise.platform.FurnisherBundle.ContInfoType"/>
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></t></_onDestroy>
		<_onCreate><f a=":">
	<c path="guise.platform.FurnisherBundle.ContInfoType"/>
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
</f></_onCreate>
		<_tagType><d/></_tagType>
		<_injector><c path="composure.injectors.Injector"/></_injector>
		<getInjector public="1" set="method" line="295"><f a=""><c path="composure.injectors.Injector"/></f></getInjector>
		<new public="1" set="method" line="307"><f a="tagType:onCreate:onDestroy:getContBundle:assessBundle">
	<d/>
	<f a=":">
		<c path="guise.platform.FurnisherBundle.ContInfoType"/>
		<c path="guise.platform.FurnisherBundle.TagType"/>
		<c path="Array"><d/></c>
	</f>
	<t path="Null"><f a="::">
	<c path="guise.platform.FurnisherBundle.ContInfoType"/>
	<c path="guise.platform.FurnisherBundle.TagType"/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></t>
	<f a="">
		<c path="composure.core.ComposeItem"/>
		<c path="guise.platform.ContBundle">
			<c path="guise.platform.FurnisherBundle.ContInfoType"/>
			<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
		</c>
	</f>
	<f a=":">
		<c path="guise.platform.ContBundle">
			<c path="guise.platform.FurnisherBundle.ContInfoType"/>
			<c path="guise.platform.FurnisherBundle.LayerInfoType"/>
		</c>
		<c path="composure.core.ComposeItem"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.IAccessType" params="" file="../src/guise/platform/IPlatformAccess.hx" module="guise.platform.IPlatformAccess" interface="1"/>
	<class path="guise.platform.IFocusableAccess" params="" file="../src/guise/platform/IPlatformAccess.hx" module="guise.platform.IPlatformAccess" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<focusedChanged public="1" get="get_focusedChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.IFocusableAccess"/></c></focusedChanged>
		<focused public="1" set="null"><e path="Bool"/></focused>
	</class>
	<class path="guise.platform.PlatformAccessor" params="AccessType" file="../src/guise/platform/PlatformAccessor.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<onAccessRemove set="dynamic" line="92"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onAccessRemove>
		<onAccessAdd set="dynamic" line="89"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onAccessAdd>
		<returnAccess set="method" line="81"><f a=""><e path="Void"/></f></returnAccess>
		<requestAccess set="method" line="73"><f a=""><e path="Void"/></f></requestAccess>
		<onInjectRemove set="method" line="67"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onInjectRemove>
		<onInjectAdd set="method" line="61"><f a="access">
	<c path="guise.platform.PlatformAccessor.AccessType"/>
	<e path="Void"/>
</f></onInjectAdd>
		<onItemRemove set="method" line="55" override="1"><f a=""><e path="Void"/></f></onItemRemove>
		<onItemAdd set="method" line="49" override="1"><f a=""><e path="Void"/></f></onItemAdd>
		<_accessType><c path="Class"><c path="guise.platform.PlatformAccessor.AccessType"/></c></_accessType>
		<_injected><c path="guise.platform.PlatformAccessor.AccessType"/></_injected>
		<_access><c path="guise.platform.PlatformAccessor.AccessType"/></_access>
		<_accessTaken><e path="Bool"/></_accessTaken>
		<set_layerName set="method" line="24"><f a="value">
	<c path="String"/>
	<c path="String"/>
</f></set_layerName>
		<layerName public="1" set="set_layerName"><c path="String"/></layerName>
		<set_platformAccess set="method" line="16"><f a="value">
	<c path="guise.platform.IPlatformAccess"/>
	<c path="guise.platform.IPlatformAccess"/>
</f></set_platformAccess>
		<platformAccess public="1" set="set_platformAccess">
			<c path="guise.platform.IPlatformAccess"/>
			<meta><m n="inject"><e>{asc:true}</e></m></meta>
		</platformAccess>
		<new public="1" set="method" line="36"><f a="accessType:?layerName:?onAccessAdd:?onAccessRemove:?inject">
	<c path="Class"><c path="guise.platform.PlatformAccessor.AccessType"/></c>
	<c path="String"/>
	<f a="">
		<c path="guise.platform.PlatformAccessor.AccessType"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="guise.platform.PlatformAccessor.AccessType"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.types.IFrameTicker" params="" file="../src/guise/platform/types/CoreAccessTypes.hx" module="guise.platform.types.CoreAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setIntendedFPS public="1" set="method"><f a="fps">
	<c path="Int"/>
	<e path="Void"/>
</f></setIntendedFPS>
		<actualFPS public="1" set="null"><c path="Float"/></actualFPS>
		<frameTick public="1" set="null"><c path="msignal.Signal0"/></frameTick>
	</class>
	<class path="guise.platform.cross.core.FrameTicker" params="" file="../src/guise/platform/cross/core/FrameTicker.hx">
		<implements path="guise.platform.types.IFrameTicker"/>
		<tick public="1" set="method" line="35"><f a=""><e path="Void"/></f></tick>
		<setIntendedFPS public="1" set="method" line="26"><f a="fps">
	<c path="Int"/>
	<e path="Void"/>
</f></setIntendedFPS>
		<_frames><c path="Array"><c path="Float"/></c></_frames>
		<_timer><c path="haxe.Timer"/></_timer>
		<actualFPS public="1" set="null"><c path="Float"/></actualFPS>
		<frameTick public="1" set="null"><c path="msignal.Signal0"/></frameTick>
		<new public="1" set="method" line="18"><f a="?intendedFPS">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.native.NativePlatformAccess" params="" file="../src/guise/platform/native/NativePlatformAccess.hx">
		<install public="1" set="method" line="14" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.nme.NmePlatformAccess" params="" file="../src/guise/platform/nme/NmePlatformAccess.hx">
		<extends path="guise.platform.AbsPlatformAccess">
			<c path="guise.platform.nme.ContInfo"/>
			<c path="guise.platform.nme.LayerInfo"/>
		</extends>
		<install public="1" set="method" line="40" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<_frameTicker static="1"><c path="guise.platform.nme.core.FrameTicker"/></_frameTicker>
		<_keyboardAccess static="1"><c path="guise.platform.nme.input.KeyboardAccess"/></_keyboardAccess>
		<returnMouseClickLayerAccess set="method" line="178"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
	<e path="Void"/>
</f></returnMouseClickLayerAccess>
		<getMouseClickLayerAccess set="method" line="174"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
</f></getMouseClickLayerAccess>
		<returnMouseClickAccess set="method" line="171"><f a="layer:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
	<e path="Void"/>
</f></returnMouseClickAccess>
		<getMouseClickAccess set="method" line="168"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseClickable"/>
</f></getMouseClickAccess>
		<returnMouseIntLayerAccess set="method" line="165"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
	<e path="Void"/>
</f></returnMouseIntLayerAccess>
		<getMouseIntLayerAccess set="method" line="161"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
</f></getMouseIntLayerAccess>
		<returnMouseIntAccess set="method" line="158"><f a="layer:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
	<e path="Void"/>
</f></returnMouseIntAccess>
		<getMouseIntAccess set="method" line="155"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.MouseInteractions"/>
</f></getMouseIntAccess>
		<returnGraphicsAccess set="method" line="152"><f a="cont:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.GraphicsAccess"/>
	<e path="Void"/>
</f></returnGraphicsAccess>
		<getGraphicsAccess set="method" line="146"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.GraphicsAccess"/>
</f></getGraphicsAccess>
		<returnFilterableAccess set="method" line="142"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.FilterableAccess"/>
	<e path="Void"/>
</f></returnFilterableAccess>
		<getFilterableAccess set="method" line="137"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.FilterableAccess"/>
</f></getFilterableAccess>
		<returnSizableAccess set="method" line="133"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.SizableDisplayAccess"/>
	<e path="Void"/>
</f></returnSizableAccess>
		<getSizableAccess set="method" line="126"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.display.SizableDisplayAccess"/>
</f></getSizableAccess>
		<returnFocusableAccess set="method" line="123"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.FocusableAccess"/>
	<e path="Void"/>
</f></returnFocusableAccess>
		<getFocusableAccess set="method" line="119"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.FocusableAccess"/>
</f></getFocusableAccess>
		<returnTextAccess set="method" line="113"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.TextAccess"/>
	<e path="Void"/>
</f></returnTextAccess>
		<getTextAccess set="method" line="109"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.TextAccess"/>
</f></getTextAccess>
		<returnLayeringAccess set="method" line="106"><f a="cont:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.display.LayerOrderAccess"/>
	<e path="Void"/>
</f></returnLayeringAccess>
		<getLayeringAccess set="method" line="103"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.display.LayerOrderAccess"/>
</f></getLayeringAccess>
		<returnKeyLayerAccess set="method" line="99"><f a="layer:access">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
	<e path="Void"/>
</f></returnKeyLayerAccess>
		<getKeyLayerAccess set="method" line="95"><f a="layer">
	<c path="guise.platform.nme.LayerInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
</f></getKeyLayerAccess>
		<returnKeyAccess set="method" line="92"><f a="layer:access">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
	<e path="Void"/>
</f></returnKeyAccess>
		<getKeyAccess set="method" line="87"><f a="cont">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.input.KeyboardAccess"/>
</f></getKeyAccess>
		<returnFrameTicker set="method" line="85"><f a="info:access">
	<d/>
	<c path="guise.platform.nme.core.FrameTicker"/>
	<e path="Void"/>
</f></returnFrameTicker>
		<getFrameTicker set="method" line="81"><f a="info">
	<d/>
	<c path="guise.platform.nme.core.FrameTicker"/>
</f></getFrameTicker>
		<set_stageTrait set="method" line="75"><f a="value">
	<c path="guise.platform.nme.display.StageTrait"/>
	<c path="guise.platform.nme.display.StageTrait"/>
</f></set_stageTrait>
		<stageTrait public="1" set="set_stageTrait">
			<c path="guise.platform.nme.display.StageTrait"/>
			<meta><m n="inject"><e>{asc:true}</e></m></meta>
		</stageTrait>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.nme.ContInfo" params="" file="../src/guise/platform/nme/NmePlatformAccess.hx" module="guise.platform.nme.NmePlatformAccess">
		<create public="1" set="method" line="184" static="1"><f a="context">
	<c path="composure.core.ComposeItem"/>
	<c path="guise.platform.nme.ContInfo"/>
</f></create>
		<destroy public="1" set="method" line="187" static="1"><f a="contInfo">
	<c path="guise.platform.nme.ContInfo"/>
	<e path="Void"/>
</f></destroy>
		<_contSkin><c path="guise.platform.nme.display.ContainerSkin"/></_contSkin>
		<set_context set="method" line="195"><f a="value">
	<c path="composure.core.ComposeItem"/>
	<c path="composure.core.ComposeItem"/>
</f></set_context>
		<context public="1" set="set_context"><c path="composure.core.ComposeItem"/></context>
		<container public="1" set="null"><t path="nme.display.Sprite"/></container>
		<new public="1" set="method" line="204"><f a="context">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.nme.LayerInfo" params="" file="../src/guise/platform/nme/NmePlatformAccess.hx" module="guise.platform.nme.NmePlatformAccess">
		<create public="1" set="method" line="215" static="1"><f a="contInfo:layerName">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="String"/>
	<c path="guise.platform.nme.LayerInfo"/>
</f></create>
		<destroy public="1" set="method" line="218" static="1"><f a="layerInfo">
	<c path="guise.platform.nme.LayerInfo"/>
	<e path="Void"/>
</f></destroy>
		<assessDisplayObject public="1" set="method" line="271"><f a=""><e path="Void"/></f></assessDisplayObject>
		<createContainer public="1" set="method" line="263"><f a=""><e path="Void"/></f></createContainer>
		<createTextField public="1" set="method" line="252"><f a=""><e path="Void"/></f></createTextField>
		<filterable public="1"><c path="guise.platform.nme.display.FilterableAccess"/></filterable>
		<sizable public="1"><c path="guise.platform.nme.display.SizableDisplayAccess"/></sizable>
		<layerName public="1"><c path="String"/></layerName>
		<container public="1"><t path="nme.display.Sprite"/></container>
		<textField public="1"><t path="nme.text.TextField"/></textField>
		<displayObject public="1"><t path="nme.display.DisplayObject"/></displayObject>
		<set_contInfo set="method" line="225"><f a="value">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="guise.platform.nme.ContInfo"/>
</f></set_contInfo>
		<contInfo public="1" set="set_contInfo"><c path="guise.platform.nme.ContInfo"/></contInfo>
		<new public="1" set="method" line="245"><f a="contInfo:layerName">
	<c path="guise.platform.nme.ContInfo"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.platform.nme.core.FrameTicker" params="" file="../src/guise/platform/nme/core/FrameTicker.hx">
		<extends path="guise.platform.cross.core.FrameTicker"/>
		<onEnterFrame public="1" set="method" line="25"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onEnterFrame>
		<setIntendedFPS public="1" set="method" line="21" override="1"><f a="fps">
	<c path="Int"/>
	<e path="Void"/>
</f></setIntendedFPS>
		<new public="1" set="method" line="15"><f a="?intendedFPS">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.nme.display.DisplaySkin" params="" file="../src/guise/platform/nme/display/DisplaySkin.hx">
		<extends path="guise.core.AbsPosAwareTrait"/>
		<implements path="guise.layout.IPositionable"/>
		<setPosition public="1" set="method" line="78"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<posChanged set="method" line="72" override="1"><f a=""><e path="Void"/></f></posChanged>
		<setDisplayObject set="method" line="58"><f a="value">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></setDisplayObject>
		<assumeDisplayObject set="method" line="54"><f a=""><e path="Void"/></f></assumeDisplayObject>
		<onParentRemoved set="method" line="46"><f a="parent">
	<c path="guise.platform.nme.display.ContainerSkin"/>
	<e path="Void"/>
</f></onParentRemoved>
		<onParentAdded set="method" line="38"><f a="parent">
	<c path="guise.platform.nme.display.ContainerSkin"/>
	<e path="Void"/>
</f></onParentAdded>
		<_parent><c path="guise.platform.nme.display.ContainerSkin"/></_parent>
		<displayObject public="1" set="null"><t path="nme.display.DisplayObject"/></displayObject>
		<new public="1" set="method" line="23"><f a="?displayObject">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.nme.display.ContainerSkin" params="" file="../src/guise/platform/nme/display/ContainerSkin.hx">
		<extends path="guise.platform.nme.display.DisplaySkin"/>
		<setContainer set="method" line="25"><f a="container">
	<t path="nme.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></setContainer>
		<assumeDisplayObject set="method" line="22" override="1"><f a=""><e path="Void"/></f></assumeDisplayObject>
		<sprite public="1" set="null"><t path="nme.display.Sprite"/></sprite>
		<container public="1" set="null"><t path="nme.display.DisplayObjectContainer"/></container>
		<new public="1" set="method" line="18"><f a="?container">
	<t path="nme.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.types.IFilterableAccess" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setFilters public="1" set="method"><f a="?filters">
	<c path="Array"><e path="guise.platform.types.FilterType"/></c>
	<e path="Void"/>
</f></setFilters>
	</class>
	<class path="guise.platform.nme.display.FilterableAccess" params="" file="../src/guise/platform/nme/display/FilterableAccess.hx">
		<implements path="guise.platform.types.IFilterableAccess"/>
		<transAngle get="inline" set="null" line="59"><f a="rads:inner">
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Float"/>
</f></transAngle>
		<setFilters public="1" set="method" line="35"><f a="?filters">
	<c path="Array"><e path="guise.platform.types.FilterType"/></c>
	<e path="Void"/>
</f></setFilters>
		<_lastFilters><c path="Array"><t path="nme.filters.BitmapFilter"/></c></_lastFilters>
		<set_displayObject set="method" line="17"><f a="value">
	<t path="nme.display.DisplayObject"/>
	<t path="nme.display.DisplayObject"/>
</f></set_displayObject>
		<displayObject public="1" set="set_displayObject"><t path="nme.display.DisplayObject"/></displayObject>
		<new public="1" set="method" line="31"><f a="?displayObject">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IGraphics" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<moveTo public="1" set="method"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?pixelHinting:?caps:?joints">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="guise.platform.types.CapsStyle"/>
	<e path="guise.platform.types.JointStyle"/>
	<e path="Void"/>
</f></lineStyle>
		<beginStroke public="1" set="method"><f a="?color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginStroke>
		<beginGradientStroke public="1" set="method"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientStroke>
		<endFill public="1" set="method"><f a=""><e path="Void"/></f></endFill>
		<drawRoundRect public="1" set="method"><f a="x:y:w:h:r">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawEllipse public="1" set="method"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<curveTo public="1" set="method"><f a="inCX:inCY:inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<clear public="1" set="method"><f a=""><e path="Void"/></f></clear>
		<beginGradientFill public="1" set="method"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
	</class>
	<class path="guise.platform.types.IBitmapGraphics" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes" interface="1">
		<implements path="guise.platform.types.IGraphics"/>
		<beginBitmapStroke public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapStroke>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
	</class>
	<class path="guise.platform.nme.display.GraphicsAccess" params="" file="../src/guise/platform/nme/display/GraphicsAccess.hx">
		<implements path="guise.platform.types.IBitmapGraphics"/>
		<sortGradPoints set="method" line="233"><f a="gp1:gp2">
	<a>
		<fract><c path="Float"/></fract>
		<c><c path="Int"/></c>
		<a><c path="Float"/></a>
	</a>
	<a>
		<fract><c path="Float"/></fract>
		<c><c path="Int"/></c>
		<a><c path="Float"/></a>
	</a>
	<c path="Int"/>
</f></sortGradPoints>
		<moveTo public="1" set="method" line="228"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method" line="222"><f a="inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method" line="198"><f a="?thickness:?pixelHinting:?caps:?joints">
	<c path="Float"/>
	<e path="Bool"/>
	<e path="guise.platform.types.CapsStyle"/>
	<e path="guise.platform.types.JointStyle"/>
	<e path="Void"/>
</f></lineStyle>
		<beginStroke public="1" set="method" line="191"><f a="?color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginStroke>
		<_miterLimit><c path="Float"/></_miterLimit>
		<_joints><t path="nme.display.JointStyle"/></_joints>
		<_caps><t path="nme.display.CapsStyle"/></_caps>
		<_pixelHinting><e path="Bool"/></_pixelHinting>
		<_thickness><c path="Float"/></_thickness>
		<_alpha><c path="Float"/></_alpha>
		<_color><c path="Int"/></_color>
		<beginGradientStroke public="1" set="method" line="131"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientStroke>
		<beginBitmapStroke public="1" set="method" line="123"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapStroke>
		<endFill public="1" set="method" line="118"><f a=""><e path="Void"/></f></endFill>
		<drawRoundRect public="1" set="method" line="113"><f a="x:y:w:h:r">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method" line="107"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawEllipse public="1" set="method" line="101"><f a="inX:inY:inWidth:inHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<curveTo public="1" set="method" line="95"><f a="inCX:inCY:inX:inY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<clear public="1" set="method" line="89"><f a=""><e path="Void"/></f></clear>
		<beginGradientFill public="1" set="method" line="37"><f a="type:gp:?matrix:?spreadMethod:?interpolationMethod">
	<e path="guise.platform.types.GradientType"/>
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<t path="guise.geom.Matrix"/>
	<e path="guise.platform.types.SpreadMethod"/>
	<e path="guise.platform.types.InterpolationMethod"/>
	<e path="Void"/>
</f></beginGradientFill>
		<beginBitmapFill public="1" set="method" line="33"><f a="bitmap:?matrix:?repeat:?smooth">
	<t path="nme.display.BitmapData"/>
	<t path="guise.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1" set="method" line="28"><f a="color:?alpha">
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<graphics public="1"><t path="nme.display.Graphics"/></graphics>
		<new public="1" set="method" line="22"><f a="?graphics">
	<t path="nme.display.Graphics"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.ILayerOrderAccess" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<swapDepths public="1" set="method"><f a="layer1:layer2">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></swapDepths>
		<layers public="1" set="null"><c path="Array"><c path="String"/></c></layers>
		<layeringChanged public="1" get="get_layeringChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ILayerOrderAccess"/></c></layeringChanged>
	</class>
	<class path="guise.platform.nme.display.LayerOrderAccess" params="" file="../src/guise/platform/nme/display/LayerOrderAccess.hx">
		<implements path="guise.platform.types.ILayerOrderAccess"/>
		<checkLayers set="method" line="47"><f a=""><e path="Void"/></f></checkLayers>
		<swapDepths public="1" set="method" line="43"><f a="layer1:layer2">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></swapDepths>
		<layers public="1" set="null"><c path="Array"><c path="String"/></c></layers>
		<onChildAdded set="method" line="35"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onChildAdded>
		<setcontainer set="method" line="20"><f a="value">
	<t path="nme.display.DisplayObjectContainer"/>
	<t path="nme.display.DisplayObjectContainer"/>
</f></setcontainer>
		<container public="1" set="setcontainer"><t path="nme.display.DisplayObjectContainer"/></container>
		<get_layeringChanged set="method" line="14"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ILayerOrderAccess"/></c></f></get_layeringChanged>
		<layeringChanged public="1" get="get_layeringChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ILayerOrderAccess"/></c></layeringChanged>
		<new public="1" set="method" line="32"><f a="container">
	<t path="nme.display.DisplayObjectContainer"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.ISizableDisplayAccess" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setSize public="1" set="method"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></setSize>
		<setPos public="1" set="method"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></setPos>
		<getMeasHeight public="1" set="method"><f a=""><c path="Float"/></f></getMeasHeight>
		<getMeasWidth public="1" set="method"><f a=""><c path="Float"/></f></getMeasWidth>
		<measChanged public="1" get="get_measChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ISizableDisplayAccess"/></c></measChanged>
	</class>
	<class path="guise.platform.nme.display.SizableDisplayAccess" params="" file="../src/guise/platform/nme/display/SizableDisplayAccess.hx">
		<implements path="guise.platform.types.ISizableDisplayAccess"/>
		<TEXT_FIELD_GUTTER line="16" static="1"><c path="Float"/></TEXT_FIELD_GUTTER>
		<validateMeas set="method" line="136"><f a=""><e path="Void"/></f></validateMeas>
		<invalidateMeas set="method" line="131"><f a=""><e path="Void"/></f></invalidateMeas>
		<sizeDisplay set="method" line="127"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></sizeDisplay>
		<sizeTextField set="method" line="123"><f a="textField">
	<t path="nme.text.TextField"/>
	<e path="Void"/>
</f></sizeTextField>
		<onSizeChanged set="method" line="115"><f a="from">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></onSizeChanged>
		<setSize public="1" set="method" line="105"><f a="value">
	<c path="guise.traits.core.ISize"/>
	<e path="Void"/>
</f></setSize>
		<positionDisplay set="method" line="99"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></positionDisplay>
		<positionTextField set="method" line="95"><f a="textField">
	<t path="nme.text.TextField"/>
	<e path="Void"/>
</f></positionTextField>
		<onPosChanged set="method" line="87"><f a="from">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></onPosChanged>
		<setPos public="1" set="method" line="77"><f a="value">
	<c path="guise.traits.core.IPosition"/>
	<e path="Void"/>
</f></setPos>
		<getMeasHeight public="1" set="method" line="72"><f a=""><c path="Float"/></f></getMeasHeight>
		<getMeasWidth public="1" set="method" line="68"><f a=""><c path="Float"/></f></getMeasWidth>
		<onTextChanged set="method" line="64"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onTextChanged>
		<removeDisplay public="1" set="method" line="54"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></removeDisplay>
		<addDisplay public="1" set="method" line="39"><f a="display">
	<t path="nme.display.DisplayObject"/>
	<e path="Void"/>
</f></addDisplay>
		<_measInvalid><e path="Bool"/></_measInvalid>
		<_measHeight><c path="Float"/></_measHeight>
		<_measWidth><c path="Float"/></_measWidth>
		<_textFields><c path="Array"><t path="nme.text.TextField"/></c></_textFields>
		<_displays><c path="Array"><t path="nme.display.DisplayObject"/></c></_displays>
		<_size><c path="guise.traits.core.ISize"/></_size>
		<_position><c path="guise.traits.core.IPosition"/></_position>
		<get_measChanged set="method" line="19"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ISizableDisplayAccess"/></c></f></get_measChanged>
		<measChanged public="1" get="get_measChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ISizableDisplayAccess"/></c></measChanged>
		<new public="1" set="method" line="33"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.nme.display.StageTrait" params="" file="../src/guise/platform/nme/display/StageTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<_stage><t path="nme.display.Stage"/></_stage>
		<get_stage set="method" line="20"><f a=""><t path="nme.display.Stage"/></f></get_stage>
		<stage public="1" get="get_stage" set="null"><t path="nme.display.Stage"/></stage>
		<new public="1" set="method" line="26"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.platform.nme.input.FocusableAccess" params="" file="../src/guise/platform/nme/input/FocusableAccess.hx">
		<implements path="guise.platform.IFocusableAccess"/>
		<get_focusedChanged set="method" line="44"><f a=""><c path="msignal.Signal1"><c path="guise.platform.IFocusableAccess"/></c></f></get_focusedChanged>
		<focusedChanged public="1" get="get_focusedChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.IFocusableAccess"/></c></focusedChanged>
		<focused public="1" set="null"><e path="Bool"/></focused>
		<onFocusOut set="method" line="36"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusOut>
		<onFocusIn set="method" line="32"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusIn>
		<set_interactiveObject set="method" line="15"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="28"><f a="?interactiveObject">
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IKeyboardAccess" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<isDown public="1" set="method"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<e path="Bool"/>
</f></isDown>
		<keyUp public="1" set="method"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyUp>
		<keyDown public="1" set="method"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyDown>
	</class>
	<class path="guise.platform.nme.input.KeyboardAccess" params="" file="../src/guise/platform/nme/input/KeyboardAccess.hx">
		<implements path="guise.platform.types.IKeyboardAccess"/>
		<getModStr set="method" line="126"><f a="mods">
	<c path="Array"><e path="guise.platform.types.ModKeys"/></c>
	<c path="String"/>
</f></getModStr>
		<getKey set="method" line="118"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="String"/>
</f></getKey>
		<isDown public="1" set="method" line="109"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<e path="Bool"/>
</f></isDown>
		<getSignal public="1" set="method" line="98"><f a="keyInfo:from">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></getSignal>
		<keyDown public="1" set="method" line="95"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyDown>
		<keyUp public="1" set="method" line="92"><f a="keyInfo">
	<e path="guise.platform.types.KeyInfo"/>
	<c path="msignal.Signal2">
		<c path="guise.platform.types.IKeyboardAccess"/>
		<e path="guise.platform.types.KeyInfo"/>
	</c>
</f></keyUp>
		<dispatchFrom public="1" set="method" line="85"><f a="key:signals">
	<c path="String"/>
	<c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c>
	<e path="Void"/>
</f></dispatchFrom>
		<dispatchSignals set="method" line="55"><f a="keyCode:charCode:ctrl:alt:shift:signals:isDown">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c>
	<e path="Bool"/>
	<e path="Void"/>
</f></dispatchSignals>
		<onKeyDown set="method" line="50"><f a="e">
	<t path="nme.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<onKeyUp set="method" line="46"><f a="e">
	<t path="nme.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyUp>
		<_isDown><c path="Hash"><e path="Bool"/></c></_isDown>
		<_keyInfos><c path="Hash"><e path="guise.platform.types.KeyInfo"/></c></_keyInfos>
		<_downSignals><c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c></_downSignals>
		<_upSignals><c path="Hash"><c path="msignal.Signal2">
	<c path="guise.platform.types.IKeyboardAccess"/>
	<e path="guise.platform.types.KeyInfo"/>
</c></c></_upSignals>
		<set_interactiveObject set="method" line="15"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="35"><f a="?interactiveObject">
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IMouseClickable" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<doubleClicked public="1" get="get_doubleClicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></doubleClicked>
		<clicked public="1" get="get_clicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></clicked>
	</class>
	<class path="guise.platform.nme.input.MouseClickable" params="" file="../src/guise/platform/nme/input/MouseClickable.hx">
		<implements path="guise.platform.types.IMouseClickable"/>
		<get_doubleClicked set="method" line="72"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></f></get_doubleClicked>
		<doubleClicked public="1" get="get_doubleClicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></doubleClicked>
		<_doubleClicked><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></_doubleClicked>
		<get_clicked set="method" line="62"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></f></get_clicked>
		<clicked public="1" get="get_clicked" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></clicked>
		<_clicked><c path="msignal.Signal1"><c path="guise.platform.types.ClickInfo"/></c></_clicked>
		<onDoubleClicked set="method" line="53"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onDoubleClicked>
		<onClicked set="method" line="47"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onClicked>
		<setClickInfo set="method" line="37"><f a="left:altHeld:ctrlHeld:shiftHeld">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setClickInfo>
		<clickInfo><c path="guise.platform.types.ClickInfo"/></clickInfo>
		<set_interactiveObject set="method" line="17"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="32"><f a="?interactiveObject">
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.IMouseInteractions" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<moved public="1" get="get_moved" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></moved>
		<rolledOut public="1" get="get_rolledOut" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOut>
		<rolledOver public="1" get="get_rolledOver" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOver>
		<released public="1" get="get_released" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></released>
		<pressed public="1" get="get_pressed" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></pressed>
	</class>
	<class path="guise.platform.nme.input.MouseInteractions" params="" file="../src/guise/platform/nme/input/MouseInteractions.hx">
		<implements path="guise.platform.types.IMouseInteractions"/>
		<get_moved set="method" line="142"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_moved>
		<moved public="1" get="get_moved" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></moved>
		<_moved><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_moved>
		<get_rolledOut set="method" line="132"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_rolledOut>
		<rolledOut public="1" get="get_rolledOut" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOut>
		<_rolledOut><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_rolledOut>
		<get_rolledOver set="method" line="119"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_rolledOver>
		<rolledOver public="1" get="get_rolledOver" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></rolledOver>
		<_rolledOver><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_rolledOver>
		<get_released set="method" line="109"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_released>
		<released public="1" get="get_released" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></released>
		<_released><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_released>
		<get_pressed set="method" line="99"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></f></get_pressed>
		<pressed public="1" get="get_pressed" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></pressed>
		<_pressed><c path="msignal.Signal1"><c path="guise.platform.types.MouseInfo"/></c></_pressed>
		<setMouseInfo set="method" line="84"><f a=""><e path="Void"/></f></setMouseInfo>
		<onMoved set="method" line="78"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onMoved>
		<onRolledOut set="method" line="71"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onRolledOut>
		<onRolledOver set="method" line="64"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onRolledOver>
		<onReleased set="method" line="57"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onReleased>
		<onPressed set="method" line="48"><f a="event">
	<t path="nme.events.MouseEvent"/>
	<e path="Void"/>
</f></onPressed>
		<_isOver><e path="Bool"/></_isOver>
		<mouseInfo><c path="guise.platform.types.MouseInfo"/></mouseInfo>
		<coordinateSpace public="1"><t path="nme.display.InteractiveObject"/></coordinateSpace>
		<set_interactiveObject set="method" line="17"><f a="value">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
</f></set_interactiveObject>
		<interactiveObject public="1" set="set_interactiveObject"><t path="nme.display.InteractiveObject"/></interactiveObject>
		<new public="1" set="method" line="42"><f a="?interactiveObject:?coordinateSpace">
	<t path="nme.display.InteractiveObject"/>
	<t path="nme.display.InteractiveObject"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.platform.types.ITextOutputAccess" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<setText public="1" set="method"><f a="run:isHtml">
	<c path="guise.platform.types.TextRun"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setText>
		<setAntiAliasing public="1" set="method"><f a="type">
	<e path="guise.platform.types.AntiAliasType"/>
	<e path="Void"/>
</f></setAntiAliasing>
		<selectable public="1" set="set_selectable"><e path="Bool"/></selectable>
		<getTextHeight public="1" set="method"><f a=""><c path="Float"/></f></getTextHeight>
		<getTextWidth public="1" set="method"><f a=""><c path="Float"/></f></getTextWidth>
	</class>
	<class path="guise.platform.types.ITextInputAccess" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes" interface="1">
		<implements path="guise.platform.IAccessType"/>
		<inputEnabled public="1" set="set_inputEnabled"><e path="Bool"/></inputEnabled>
		<textChanged public="1" get="get_textChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></textChanged>
		<getText public="1" set="method"><f a=""><c path="String"/></f></getText>
	</class>
	<class path="guise.platform.nme.input.TextAccess" params="" file="../src/guise/platform/nme/input/TextAccess.hx">
		<implements path="guise.platform.types.ITextOutputAccess"/>
		<implements path="guise.platform.types.ITextInputAccess"/>
		<wrapInAlign set="method" line="190"><f a="align:text">
	<e path="guise.platform.types.Align"/>
	<c path="String"/>
	<c path="String"/>
</f></wrapInAlign>
		<wrapInFormat set="method" line="157"><f a="style:inner">
	<e path="guise.platform.types.TextStyle"/>
	<c path="String"/>
	<c path="String"/>
</f></wrapInFormat>
		<createHtml set="method" line="143"><f a="runs:isHtml">
	<c path="Array"><e path="guise.platform.types.TextRunData"/></c>
	<e path="Bool"/>
	<c path="String"/>
</f></createHtml>
		<setText public="1" set="method" line="103"><f a="run:isHtml">
	<c path="guise.platform.types.TextRun"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setText>
		<getText public="1" set="method" line="100"><f a=""><c path="String"/></f></getText>
		<get_focusedChanged set="method" line="93"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></f></get_focusedChanged>
		<focusedChanged public="1" get="get_focusedChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></focusedChanged>
		<focused public="1" set="null"><e path="Bool"/></focused>
		<get_textChanged set="method" line="85"><f a=""><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></f></get_textChanged>
		<textChanged public="1" get="get_textChanged" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.ITextInputAccess"/></c></textChanged>
		<onFocusOut set="method" line="79"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusOut>
		<onFocusIn set="method" line="75"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onFocusIn>
		<onChange set="method" line="71"><f a="e">
	<t path="nme.events.Event"/>
	<e path="Void"/>
</f></onChange>
		<set_selectable set="method" line="65"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_selectable>
		<selectable public="1" set="set_selectable"><e path="Bool"/></selectable>
		<set_inputEnabled set="method" line="58"><f a="value">
	<e path="Bool"/>
	<e path="Bool"/>
</f></set_inputEnabled>
		<inputEnabled public="1" set="set_inputEnabled"><e path="Bool"/></inputEnabled>
		<setAntiAliasing public="1" set="method" line="33"><f a="type">
	<e path="guise.platform.types.AntiAliasType"/>
	<e path="Void"/>
</f></setAntiAliasing>
		<getTextHeight public="1" set="method" line="30"><f a=""><c path="Float"/></f></getTextHeight>
		<getTextWidth public="1" set="method" line="27"><f a=""><c path="Float"/></f></getTextWidth>
		<_ignoreChanges><e path="Bool"/></_ignoreChanges>
		<_textField><t path="nme.text.TextField"/></_textField>
		<new public="1" set="method" line="20"><f a="textField">
	<t path="nme.text.TextField"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<typedef path="guise.platform.nme.input.NmeAA" params="" file="../src/guise/platform/nme/input/TextAccess.hx" module="guise.platform.nme.input.TextAccess"><t path="nme.text.AntiAliasType"/></typedef>
	<typedef path="guise.platform.nme.input.NmeTextFormat" params="" file="../src/guise/platform/nme/input/TextAccess.hx" module="guise.platform.nme.input.TextAccess"><t path="nme.text.TextFormat"/></typedef>
	<class path="guise.platform.types.CoreAccessTypes" params="" file="../src/guise/platform/types/CoreAccessTypes.hx"><haxe_doc>* @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.DisplayAccessTypes" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.IScreenInfo" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes" interface="1">
		<availHeight public="1" set="null"><c path="Int"/></availHeight>
		<availWidth public="1" set="null"><c path="Int"/></availWidth>
		<availSizeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.platform.types.IScreenInfo"/></c></availSizeChanged>
	</class>
	<enum path="guise.platform.types.FilterType" params="" file="../src/guise/platform/types/DisplayAccessTypes.hx" module="guise.platform.types.DisplayAccessTypes">
		<Glow a="size:color:alpha:?inner">
			<c path="Float"/>
			<c path="Int"/>
			<c path="Float"/>
			<e path="Bool"/>
		</Glow>
		<DropShadow a="distance:angle:size:color:alpha:?inner">
			<c path="Float"/>
			<c path="Float"/>
			<c path="Float"/>
			<c path="Int"/>
			<c path="Float"/>
			<e path="Bool"/>
		</DropShadow>
	</enum>
	<class path="guise.platform.types.DrawingAccessTypes" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx"><haxe_doc>* @author Tom Byrne</haxe_doc></class>
	<enum path="guise.platform.types.GradientType" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<Radial a="?focalPointRatio"><c path="Float"/></Radial>
		<Linear/>
	</enum>
	<enum path="guise.platform.types.SpreadMethod" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<Repeat/>
		<Reflect/>
		<Pad/>
	</enum>
	<enum path="guise.platform.types.InterpolationMethod" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<Rgb/>
		<LinearRgb/>
	</enum>
	<enum path="guise.platform.types.JointStyle" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<JoRound/>
		<JoMiter a="limit"><c path="Float"/></JoMiter>
		<JoBevel/>
	</enum>
	<enum path="guise.platform.types.CapsStyle" params="" file="../src/guise/platform/types/DrawingAccessTypes.hx" module="guise.platform.types.DrawingAccessTypes">
		<CsSquare/>
		<CsRound/>
		<CsNone/>
	</enum>
	<class path="guise.platform.types.InteractionAccessTypes" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx"><haxe_doc>* @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.MouseInfo" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<mouseY public="1"><c path="Float"/></mouseY>
		<mouseX public="1"><c path="Float"/></mouseX>
		<new public="1" set="method" line="26"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="guise.platform.types.ClickInfo" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<shiftHeld public="1"><e path="Bool"/></shiftHeld>
		<ctrlHeld public="1"><e path="Bool"/></ctrlHeld>
		<altHeld public="1"><e path="Bool"/></altHeld>
		<left public="1"><e path="Bool"/></left>
		<new public="1" set="method" line="43"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="guise.platform.types.KeyInfo" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<Key a="keyCode:?modKeys">
			<c path="Int"/>
			<c path="Array"><e path="guise.platform.types.ModKeys"/></c>
		</Key>
		<Char a="charCode:?modKeys">
			<c path="Int"/>
			<c path="Array"><e path="guise.platform.types.ModKeys"/></c>
		</Char>
	</enum>
	<enum path="guise.platform.types.ModKeys" params="" file="../src/guise/platform/types/InteractionAccessTypes.hx" module="guise.platform.types.InteractionAccessTypes">
		<Shift/>
		<Ctrl/>
		<Alt/>
	</enum>
	<class path="guise.platform.types.TextAccessTypes" params="" file="../src/guise/platform/types/TextAccessTypes.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<class path="guise.platform.types.TextRun" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<addData public="1" set="method" line="40"><f a="data">
	<e path="guise.platform.types.TextRunData"/>
	<e path="Void"/>
</f></addData>
		<runs public="1"><c path="Array"><e path="guise.platform.types.TextRunData"/></c></runs>
		<style public="1"><e path="guise.platform.types.TextStyle"/></style>
		<new public="1" set="method" line="36"><f a="style:runs">
	<e path="guise.platform.types.TextStyle"/>
	<c path="Array"><e path="guise.platform.types.TextRunData"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="guise.platform.types.TextRunData" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<Text a="text"><c path="String"/></Text>
		<Run a="runs"><c path="guise.platform.types.TextRun"/></Run>
	</enum>
	<enum path="guise.platform.types.AntiAliasType" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<AaSmooth/>
		<AaPixel/>
		<Aa a="sharpness:thickness">
			<c path="Float"/>
			<c path="Float"/>
		</Aa>
	</enum>
	<enum path="guise.platform.types.TextStyle" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes"><Trs a="font:size:color:?mods:?align">
	<t path="Null"><e path="guise.platform.types.Typeface"/></t>
	<t path="Null"><c path="Float"/></t>
	<t path="Null"><c path="Int"/></t>
	<c path="Array"><e path="guise.platform.types.TextModifier"/></c>
	<e path="guise.platform.types.Align"/>
</Trs></enum>
	<enum path="guise.platform.types.TextModifier" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<TmUnderline a="?underline"><e path="Bool"/></TmUnderline>
		<TmStrikeThru a="?strikethrough"><e path="Bool"/></TmStrikeThru>
		<TmItalic a="?italic"><e path="Bool"/></TmItalic>
		<TmBold a="?bold"><e path="Bool"/></TmBold>
	</enum>
	<enum path="guise.platform.types.Typeface" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<TfTypewriter/>
		<TfSerif/>
		<TfSans/>
		<Tf a="name"><c path="String"/></Tf>
	</enum>
	<enum path="guise.platform.types.Align" params="" file="../src/guise/platform/types/TextAccessTypes.hx" module="guise.platform.types.TextAccessTypes">
		<Right/>
		<Left/>
		<Justify/>
		<Center/>
	</enum>
	<class path="guise.traits.core.IActive" params="" file="../src/guise/traits/core/IActive.hx" interface="1">
		<set public="1" set="method"><f a="active:explicit">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<explicit public="1" set="null"><e path="Bool"/></explicit>
		<active public="1" set="null"><e path="Bool"/></active>
		<activeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IActive"/></c></activeChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.core.CascadingActive" params="" file="../src/guise/traits/core/CascadingActive.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<implements path="guise.traits.core.IActive"/>
		<onChildRemoved set="method" line="63"><f a="child">
	<c path="guise.traits.core.IActive"/>
	<e path="Void"/>
</f></onChildRemoved>
		<onChildAdded set="method" line="53"><f a="child">
	<c path="guise.traits.core.IActive"/>
	<e path="Void"/>
</f></onChildAdded>
		<set public="1" set="method" line="38"><f a="active:explicit">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></set>
		<_children><c path="haxe.FastList_guise_traits_core_IActive"/></_children>
		<cascade public="1"><e path="Bool"/></cascade>
		<explicit public="1" set="null"><e path="Bool"/></explicit>
		<active public="1" set="null"><e path="Bool"/></active>
		<activeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IActive"/></c></activeChanged>
		<new public="1" set="method" line="26"><f a="?active:?explicit:?cascade">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guise.traits.core.IPosition" params="" file="../src/guise/traits/core/IPosition.hx" interface="1">
		<set public="1" set="method"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<y public="1" set="null"><c path="Float"/></y>
		<x public="1" set="null"><c path="Float"/></x>
		<posChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IPosition"/></c></posChanged>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.core.ISize" params="" file="../src/guise/traits/core/ISize.hx" interface="1">
		<set public="1" set="method"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<height public="1" set="null"><c path="Float"/></height>
		<width public="1" set="null"><c path="Float"/></width>
		<sizeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.ISize"/></c></sizeChanged>
	</class>
	<class path="guise.traits.core.Position" params="" file="../src/guise/traits/core/Position.hx">
		<implements path="guise.traits.core.IPosition"/>
		<set public="1" set="method" line="22"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<y public="1" set="null"><c path="Float"/></y>
		<x public="1" set="null"><c path="Float"/></x>
		<posChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.IPosition"/></c></posChanged>
		<new public="1" set="method" line="16"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.core.Size" params="" file="../src/guise/traits/core/Size.hx">
		<implements path="guise.traits.core.ISize"/>
		<set public="1" set="method" line="21"><f a="width:height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></set>
		<height public="1" set="null"><c path="Float"/></height>
		<width public="1" set="null"><c path="Float"/></width>
		<sizeChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.core.ISize"/></c></sizeChanged>
		<new public="1" set="method" line="15"><f a="?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guise.traits.states.ControlStates" params="" file="../src/guise/traits/states/ControlStates.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<enum path="guise.traits.states.ControlActiveState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<INACTIVE/>
		<ACTIVE/>
	</enum>
	<enum path="guise.traits.states.ButtonOverState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<OVER/>
		<OUT/>
	</enum>
	<enum path="guise.traits.states.ButtonDownState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UP/>
		<DOWN/>
	</enum>
	<enum path="guise.traits.states.SelectedState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UNSELECTED/>
		<SELECTED/>
	</enum>
	<enum path="guise.traits.states.SelectableState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UNSELECTABLE/>
		<SELECTABLE/>
	</enum>
	<enum path="guise.traits.states.FocusState" params="" file="../src/guise/traits/states/ControlStates.hx" module="guise.traits.states.ControlStates">
		<UNFOCUSED/>
		<FOCUSED/>
	</enum>
	<class path="guise.traits.states.IState" params="StateEnum" file="../src/guise/traits/states/IState.hx" interface="1">
		<set public="1" set="method"><f a="current">
	<c path="guise.traits.states.IState.StateEnum"/>
	<e path="Void"/>
</f></set>
		<options public="1" set="null"><c path="Array"><c path="guise.traits.states.IState.StateEnum"/></c></options>
		<current public="1" set="null"><c path="guise.traits.states.IState.StateEnum"/></current>
		<stateChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.states.IState"><c path="guise.traits.states.IState.StateEnum"/></c></c></stateChanged>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.states.State" params="StateEnum" file="../src/guise/traits/states/State.hx">
		<implements path="guise.traits.states.IState"><c path="guise.traits.states.State.StateEnum"/></implements>
		<set public="1" set="method" line="22"><f a="current">
	<c path="guise.traits.states.State.StateEnum"/>
	<e path="Void"/>
</f></set>
		<options public="1" set="null"><c path="Array"><c path="guise.traits.states.State.StateEnum"/></c></options>
		<current public="1" set="null"><c path="guise.traits.states.State.StateEnum"/></current>
		<stateChanged public="1" set="null"><c path="msignal.Signal1"><c path="guise.traits.states.IState"><c path="guise.traits.states.State.StateEnum"/></c></c></stateChanged>
		<new public="1" set="method" line="16"><f a="?current">
	<c path="guise.traits.states.State.StateEnum"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.traits.states.StateStyledTrait" params="StyleType" file="../src/guise/traits/states/StateStyledTrait.hx">
		<extends path="composure.traits.AbstractTrait"/>
		<_drawStyle set="method" line="192"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="188"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<drawStyle set="dynamic" line="184"><f a=""><e path="Void"/></f></drawStyle>
		<isReadyToDraw set="dynamic" line="180">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Overriding dynamic functions disallows calling the 
	 * super version of the function. By using the _methods
	 * you can super call like normal.</haxe_doc>
		</isReadyToDraw>
		<getStateKey set="method" line="170"><f a="state">
	<c path="EnumValue"/>
	<c path="String"/>
</f></getStateKey>
		<attemptDrawStyle set="method" line="164"><f a=""><e path="Void"/></f></attemptDrawStyle>
		<invalidate public="1" set="method" line="160"><f a=""><e path="Void"/></f></invalidate>
		<sortStyles set="method" line="151"><f a="style1:style2">
	<a>
		<style><c path="guise.traits.states.StateStyledTrait.StyleType"/></style>
		<states><c path="Array"><c path="String"/></c></states>
		<priority><c path="Int"/></priority>
	</a>
	<a>
		<style><c path="guise.traits.states.StateStyledTrait.StyleType"/></style>
		<states><c path="Array"><c path="String"/></c></states>
		<priority><c path="Int"/></priority>
	</a>
	<c path="Int"/>
</f></sortStyles>
		<findDestStyle set="method" line="121"><f a=""><c path="guise.traits.states.StateStyledTrait.StyleType"/></f></findDestStyle>
		<finishTrans set="method" line="115"><f a="finish">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<e path="Void"/>
</f></finishTrans>
		<updateTrans set="method" line="111"><f a="current">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<e path="Void"/>
</f></updateTrans>
		<assessStyle set="method" line="84"><f a=""><e path="Void"/></f></assessStyle>
		<removeStyle public="1" set="method" line="76"><f a="style">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<e path="Void"/>
</f></removeStyle>
		<addStyle public="1" set="method" line="65"><f a="states:style:?priority">
	<c path="Array"><c path="EnumValue"/></c>
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addStyle>
		<onStateChanged set="method" line="61"><f a="state">
	<c path="guise.traits.states.IState"><c path="EnumValue"/></c>
	<e path="Void"/>
</f></onStateChanged>
		<removeState public="1" set="method" line="56">
			<f a="state">
				<c path="guise.traits.states.IState"><c path="EnumValue"/></c>
				<e path="Void"/>
			</f>
			<meta><m n="injectRemove"/></meta>
		</removeState>
		<addState public="1" set="method" line="48">
			<f a="state">
				<c path="guise.traits.states.IState"><c path="EnumValue"/></c>
				<e path="Void"/>
			</f>
			<meta><m n="injectAdd"/></meta>
		</addState>
		<transSubject><d/></transSubject>
		<states><c path="Array"><c path="guise.traits.states.IState"><c path="EnumValue"/></c></c></states>
		<styles><c path="Array"><a>
	<style><c path="guise.traits.states.StateStyledTrait.StyleType"/></style>
	<states><c path="Array"><c path="String"/></c></states>
	<priority><c path="Int"/></priority>
</a></c></styles>
		<destStyle public="1" set="null"><c path="guise.traits.states.StateStyledTrait.StyleType"/></destStyle>
		<previousStyle public="1" set="null"><c path="guise.traits.states.StateStyledTrait.StyleType"/></previousStyle>
		<currentStyle public="1" set="null"><c path="guise.traits.states.StateStyledTrait.StyleType"/></currentStyle>
		<currentTrans><c path="guiseSkins.trans.ITransTracker"/></currentTrans>
		<set_normalStyle set="method" line="21"><f a="value">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
</f></set_normalStyle>
		<normalStyle public="1" set="set_normalStyle"><c path="guise.traits.states.StateStyledTrait.StyleType"/></normalStyle>
		<styleTransitioner public="1"><c path="guiseSkins.trans.ITransitioner"/></styleTransitioner>
		<injStyleTransitioner public="1">
			<c path="guiseSkins.trans.ITransitioner"/>
			<meta><m n="inject"><e>{asc:true}</e></m></meta>
		</injStyleTransitioner>
		<new public="1" set="method" line="38"><f a="?normalStyle:?isReadyToDraw:?drawStyle:?transSubject">
	<c path="guise.traits.states.StateStyledTrait.StyleType"/>
	<f a=""><e path="Bool"/></f>
	<f a=""><e path="Void"/></f>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guise.traits.tags.ControlTags" params="" file="../src/guise/traits/tags/ControlTags.hx">
		<TextLabelTag/>
		<TextInputTag/>
		<TextButtonTag/>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</enum>
	<enum path="guise.traits.tags.CoreTags" params="" file="../src/guise/traits/tags/CoreTags.hx">
		<WindowTag/>
		<StageTag/>
		<CursorTag/>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</enum>
	<class path="guise.utils.Clone" params="" file="../src/guise/utils/Clone.hx">
		<clone public="1" params="T" set="method" line="10" static="1"><f a="object">
	<c path="clone.T"/>
	<c path="clone.T"/>
</f></clone>
		<cloneInline public="1" params="T" get="inline" set="null" line="13" static="1"><f a="item">
	<c path="cloneInline.T"/>
	<c path="cloneInline.T"/>
</f></cloneInline>
		<cloneEnum public="1" params="T" set="method" line="29" static="1"><f a="enumVal:?paramMask">
	<c path="cloneEnum.T"/>
	<c path="Array"><d/></c>
	<c path="cloneEnum.T"/>
</f></cloneEnum>
		<cloneObject public="1" params="T" get="inline" set="null" line="48" static="1"><f a="item">
	<c path="cloneObject.T"/>
	<c path="cloneObject.T"/>
</f></cloneObject>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<enum path="guise.utils.MaskValues" params="" file="../src/guise/utils/Clone.hx" module="guise.utils.Clone"><CLONE/></enum>
	<class path="guise.utils.Closures" params="" file="../src/guise/utils/Closures.hx">
		<eq public="1" set="method" line="10" static="1"><f a="val1:val2">
	<d/>
	<d/>
	<e path="Bool"/>
</f></eq>
		<ineq public="1" set="method" line="11" static="1"><f a="val1:val2">
	<d/>
	<d/>
	<e path="Bool"/>
</f></ineq>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guise.utils.TitleCase" params="" file="../src/guise/utils/TitleCase.hx">
		<toTitleCase public="1" set="method" line="11" static="1"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></toTitleCase>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.AbsStyledLayer" params="StyleType" file="../src/guiseSkins/styled/AbsStyledLayer.hx">
		<extends path="guise.traits.states.StateStyledTrait"><c path="guiseSkins.styled.AbsStyledLayer.StyleType"/></extends>
		<implements path="guise.layout.IPositionable"/>
		<setPosition public="1" set="method" line="31"><f a="x:y:w:h">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></setPosition>
		<h public="1"><c path="Float"/></h>
		<w public="1"><c path="Float"/></w>
		<y public="1"><c path="Float"/></y>
		<x public="1"><c path="Float"/></x>
		<_requireSize><e path="Bool"/></_requireSize>
		<_requirePos><e path="Bool"/></_requirePos>
		<_isReadyToDraw set="method" line="20" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<new public="1" set="method" line="15"><f a="?normalStyle">
	<c path="guiseSkins.styled.AbsStyledLayer.StyleType"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guiseSkins.styled.BoxLayer" params="" file="../src/guiseSkins/styled/BoxLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><e path="guiseSkins.styled.BoxStyle"/></extends>
		<SQUARE_CORNER static="1"><e path="guiseSkins.styled.CornerStyle"/></SQUARE_CORNER>
		<CAPSULE_CORNER static="1"><e path="guiseSkins.styled.CornerStyle"/></CAPSULE_CORNER>
		<drawArc set="method" line="204"><f a="graphics:x:y:radius:angle:startAngle:isInitial:?accuracy">
	<c path="guise.platform.types.IGraphics"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></drawArc>
		<drawCorner set="method" line="178"><f a="cs:flipH:flipV:angle:isInitial:width:height:cX:cY">
	<e path="guiseSkins.styled.CornerStyle"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCorner>
		<createBoxMatrix set="method" line="172"><f a="rotation:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<t path="guise.geom.Matrix"/>
</f></createBoxMatrix>
		<collectFills set="method" line="158"><f a="fill:fills">
	<e path="guiseSkins.styled.FillStyle"/>
	<c path="Array"><e path="guiseSkins.styled.FillStyle"/></c>
	<e path="Void"/>
</f></collectFills>
		<_drawStyle set="method" line="36" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="33" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<onGraphicsRemove set="method" line="29"><f a="access">
	<c path="guise.platform.types.IGraphics"/>
	<e path="Void"/>
</f></onGraphicsRemove>
		<onGraphicsAdd set="method" line="25"><f a="access">
	<c path="guise.platform.types.IGraphics"/>
	<e path="Void"/>
</f></onGraphicsAdd>
		<_graphics><c path="guise.platform.types.IGraphics"/></_graphics>
		<new public="1" set="method" line="18"><f a="?layerName:?normalStyle">
	<c path="String"/>
	<e path="guiseSkins.styled.BoxStyle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guiseSkins.styled.BoxStyle" params="" file="../src/guiseSkins/styled/BoxLayer.hx" module="guiseSkins.styled.BoxLayer">
		<BsRectComplex a="f:s:c:?extraW:?extraH">
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guiseSkins.styled.StrokeStyle"/>
			<e path="guiseSkins.styled.Corners"/>
			<c path="Float"/>
			<c path="Float"/>
		</BsRectComplex>
		<BsRect a="f:s:?extraW:?extraH">
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guiseSkins.styled.StrokeStyle"/>
			<c path="Float"/>
			<c path="Float"/>
		</BsRect>
		<BsCapsule a="f:s:?extraW:?extraH">
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guiseSkins.styled.StrokeStyle"/>
			<c path="Float"/>
			<c path="Float"/>
		</BsCapsule>
	</enum>
	<enum path="guiseSkins.styled.Corners" params="" file="../src/guiseSkins/styled/BoxLayer.hx" module="guiseSkins.styled.BoxLayer">
		<CSame a="cs"><e path="guiseSkins.styled.CornerStyle"/></CSame>
		<CDiff a="tl:tr:br:bl">
			<e path="guiseSkins.styled.CornerStyle"/>
			<e path="guiseSkins.styled.CornerStyle"/>
			<e path="guiseSkins.styled.CornerStyle"/>
			<e path="guiseSkins.styled.CornerStyle"/>
		</CDiff>
	</enum>
	<enum path="guiseSkins.styled.CornerStyle" params="" file="../src/guiseSkins/styled/BoxLayer.hx" module="guiseSkins.styled.BoxLayer">
		<CsSquare/>
		<CsCirc a="r"><c path="Float"/></CsCirc>
	</enum>
	<class path="guiseSkins.trans.ITransitioner" params="" file="../src/guiseSkins/trans/ITransitioner.hx" interface="1">
		<doTrans public="1" set="method"><f a="from:to:subject:?prop:?update:?finish">
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<c path="guiseSkins.trans.ITransTracker"/>
</f></doTrans>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.StyleTransitioner" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx">
		<implements path="guiseSkins.trans.ITransitioner"/>
		<ease public="1" set="method" line="283" static="1"><f a="paramsTypes">
	<c path="Array"><e path="guiseSkins.trans.SwitchParamType"/></c>
	<t path="guiseSkins.trans.EnumValSwitchFact"/>
</f></ease>
		<goVia public="1" set="method" line="288" static="1"><f a="paramsTypes">
	<c path="Array"><e path="guiseSkins.trans.SwitchParamType"/></c>
	<t path="guiseSkins.trans.EnumValSwitchFact"/>
</f></goVia>
		<createSwitchInfo set="method" line="302" static="1"><f a="paramsTypes:direction:style1:style1Match:style2:style2Match">
	<c path="Array"><e path="guiseSkins.trans.SwitchParamType"/></c>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<t path="guiseSkins.trans.SwitchSpanInfo"/>
</f></createSwitchInfo>
		<transFinished set="method" line="355"><f a="from">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<e path="Void"/>
</f></transFinished>
		<findEaserFact set="method" line="342"><f a="enumVal:paramIndex">
	<d/>
	<c path="Int"/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
</f></findEaserFact>
		<doSwitch2 set="method" line="273"><f a="bundle:span:via:viaParams:destParams:easerFuncs">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<d/>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><t path="guiseSkins.trans.EaserFactFunc"/></c>
	<e path="Void"/>
</f></doSwitch2>
		<doSwitch set="method" line="236"><f a="bundle:span:switchInfoList:style1Match:style2Match:direction:parent:prop">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
	<d/>
	<d/>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
</f></doSwitch>
		<addEnumEaser set="method" line="230"><f a="span:parent:prop:enumVal:params">
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<d/>
	<c path="String"/>
	<d/>
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></addEnumEaser>
		<enumConstMatch set="method" line="227"><f a="enum1:enum2">
	<c path="EnumValue"/>
	<c path="EnumValue"/>
	<e path="Bool"/>
</f></enumConstMatch>
		<checkSpan set="method" line="85"><f a="bundle:span:parent:prop:from:dest:?easerFact">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<c path="guiseSkins.trans._StyleTransitioner.TransSpan"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
	<d/>
</f></checkSpan>
		<findTransStyle set="method" line="82"><f a="from:to:subject:prop">
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="guiseSkins.trans.TransStyle"/>
</f></findTransStyle>
		<doTrans public="1" set="method" line="39"><f a="from:to:subject:?prop:?update:?finish">
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
</f></doTrans>
		<addPropEaser public="1" set="method" line="32"><f a="styleType:paramIndex:propEaserFact">
	<d/>
	<c path="Int"/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
	<e path="Void"/>
</f></addPropEaser>
		<addStyleSwitch public="1" set="method" line="25"><f a="styleSwitch">
	<e path="guiseSkins.trans.StyleSwitch"/>
	<e path="Void"/>
</f></addStyleSwitch>
		<propEasers><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.PropEaserInfo"/></c></propEasers>
		<styleSwitches><c path="Array"><e path="guiseSkins.trans.StyleSwitch"/></c></styleSwitches>
		<normalTransStyle public="1"><c path="guiseSkins.trans.TransStyle"/></normalTransStyle>
		<new public="1" set="method" line="20"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.DefaultStyleTrans" params="" file="../src/guiseSkins/styled/DefaultStyleTrans.hx">
		<extends path="guiseSkins.trans.StyleTransitioner"/>
		<checkCapsultToRoundedRect set="method" line="185"><f a="style1:params1:style2:params2">
	<e path="guiseSkins.styled.BoxStyle"/>
	<c path="Array"><d/></c>
	<e path="guiseSkins.styled.BoxStyle"/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></checkCapsultToRoundedRect>
		<easeCapsuleToRoundedRect set="method" line="148"><f a="subject:direction:style1:style1Match:style2:style2Match">
	<d/>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></easeCapsuleToRoundedRect>
		<setGradPointOpacity set="method" line="134"><f a="gp:to:onlyIfNull">
	<c path="Array"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><t path="Null"><c path="Float"/></t></a>
</a></c>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setGradPointOpacity>
		<setFillOpacity set="method" line="114"><f a="fill:to:onlyIfNull">
	<e path="guiseSkins.styled.FillStyle"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setFillOpacity>
		<easeFillToFill set="method" line="106"><f a="subject:direction:enum1:style1Match:enum2:style2Match">
	<d/>
	<e path="Bool"/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></easeFillToFill>
		<checkFillToFill set="method" line="83"><f a="style1:params1:style2:params2">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></checkFillToFill>
		<easeFillToDiffFill set="method" line="50"><f a="subject:direction:enum1:style1Match:enum2:style2Match">
	<d/>
	<e path="Bool"/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></easeFillToDiffFill>
		<checkFillToDiffFill set="method" line="35"><f a="style1:params1:style2:params2">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></checkFillToDiffFill>
		<new public="1" set="method" line="22"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.IPropEaser" params="" file="../src/guiseSkins/trans/IPropEaser.hx" interface="1">
		<update public="1" set="method"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method"><f a=""><e path="Void"/></f></release>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.GradientEaser" params="" file="../src/guiseSkins/styled/DefaultStyleTrans.hx" module="guiseSkins.styled.DefaultStyleTrans">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.styled.GradientEaser"/></c></_pool>
		<getNew public="1" set="method" line="213" static="1"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<c path="guiseSkins.styled.GradientEaser"/>
</f></getNew>
		<update public="1" set="method" line="251"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="246"><f a=""><e path="Void"/></f></release>
		<colDiff public="1"><c path="Array"><a>
	<r><c path="Int"/></r>
	<g><c path="Int"/></g>
	<fract><c path="Float"/></fract>
	<b><c path="Int"/></b>
	<a><c path="Float"/></a>
</a></c></colDiff>
		<colStart public="1"><c path="Array"><a>
	<r><c path="Int"/></r>
	<g><c path="Int"/></g>
	<fract><c path="Float"/></fract>
	<b><c path="Int"/></b>
	<a><c path="Float"/></a>
</a></c></colStart>
		<curr public="1"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></curr>
		<inited public="1"><e path="Bool"/></inited>
		<end public="1"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></end>
		<start public="1"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></start>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="239"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guiseSkins.styled.FilterLayer" params="" file="../src/guiseSkins/styled/FilterLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><c path="Array"><e path="guise.platform.types.FilterType"/></c></extends>
		<_drawStyle set="method" line="27" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<onFilterableRemove set="method" line="23"><f a="access">
	<c path="guise.platform.types.IFilterableAccess"/>
	<e path="Void"/>
</f></onFilterableRemove>
		<onFilterableAdd set="method" line="19"><f a="access">
	<c path="guise.platform.types.IFilterableAccess"/>
	<e path="Void"/>
</f></onFilterableAdd>
		<_filterable><c path="guise.platform.types.IFilterableAccess"/></_filterable>
		<new public="1" set="method" line="13"><f a="?layerName:?normalStyle">
	<c path="String"/>
	<c path="Array"><e path="guise.platform.types.FilterType"/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<class path="guiseSkins.styled.FramingLayer" params="" file="../src/guiseSkins/styled/FramingLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><e path="guiseSkins.styled.FramingStyle"/></extends>
		<_drawStyle set="method" line="49" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="45" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<onMeasChanged set="method" line="42"><f a="from">
	<c path="guise.platform.types.ISizableDisplayAccess"/>
	<e path="Void"/>
</f></onMeasChanged>
		<onSizableRemove set="method" line="37"><f a="access">
	<c path="guise.platform.types.ISizableDisplayAccess"/>
	<e path="Void"/>
</f></onSizableRemove>
		<onSizableAdd set="method" line="30"><f a="access">
	<c path="guise.platform.types.ISizableDisplayAccess"/>
	<e path="Void"/>
</f></onSizableAdd>
		<_expSize><c path="guise.traits.core.Size"/></_expSize>
		<_expPos><c path="guise.traits.core.Position"/></_expPos>
		<_sizableDisplay><c path="guise.platform.types.ISizableDisplayAccess"/></_sizableDisplay>
		<new public="1" set="method" line="20"><f a="layerName:?normalStyle">
	<c path="String"/>
	<e path="guiseSkins.styled.FramingStyle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guiseSkins.styled.FramingStyle" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer"><Frame a="fitMode:?hScale:?vScale:?marginTop:?marginLeft:?marginBottom:?marginRight">
	<e path="guiseSkins.styled.FrameMode"/>
	<e path="guiseSkins.styled.ScaleMode"/>
	<e path="guiseSkins.styled.ScaleMode"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</Frame></enum>
	<enum path="guiseSkins.styled.FrameMode" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer">
		<Fill/>
		<ConstrainMin/>
		<ConstrainMax/>
	</enum>
	<enum path="guiseSkins.styled.ScaleMode" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer">
		<ScaleUpOnly a="?align"><e path="guiseSkins.styled.Align"/></ScaleUpOnly>
		<ScaleNever a="?align"><e path="guiseSkins.styled.Align"/></ScaleNever>
		<ScaleDownOnly a="?align"><e path="guiseSkins.styled.Align"/></ScaleDownOnly>
		<ScaleAlways/>
	</enum>
	<enum path="guiseSkins.styled.Align" params="" file="../src/guiseSkins/styled/FramingLayer.hx" module="guiseSkins.styled.FramingLayer">
		<AlignMid/>
		<AlignFore/>
		<AlignAft/>
	</enum>
	<class path="guiseSkins.styled.Styles" params="" file="../src/guiseSkins/styled/Styles.hx"><haxe_doc>* ...
 * @author Tom Byrne</haxe_doc></class>
	<typedef path="guiseSkins.styled.GradPoint" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles"><a>
	<fract><c path="Float"/></fract>
	<c><c path="Int"/></c>
	<a><c path="Float"/></a>
</a></typedef>
	<enum path="guiseSkins.styled.FillStyle" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<FsVLinearGradient a="gp"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></FsVLinearGradient>
		<FsTransparent/>
		<FsSolid a="c:?a">
			<c path="Int"/>
			<c path="Float"/>
		</FsSolid>
		<FsRadialGradient a="gp:?mat:?focalPointRatio">
			<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
			<t path="guise.geom.Matrix"/>
			<c path="Float"/>
		</FsRadialGradient>
		<FsNone/>
		<FsMulti a="fs"><c path="Array"><e path="guiseSkins.styled.FillStyle"/></c></FsMulti>
		<FsLinearGradient a="gp:?mat">
			<c path="Array"><t path="guiseSkins.styled.GradPoint"/></c>
			<t path="guise.geom.Matrix"/>
		</FsLinearGradient>
		<FsHLinearGradient a="gp"><c path="Array"><t path="guiseSkins.styled.GradPoint"/></c></FsHLinearGradient>
	</enum>
	<enum path="guiseSkins.styled.StrokeStyle" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<SsSolid a="th:fill:?joints">
			<c path="Float"/>
			<e path="guiseSkins.styled.FillStyle"/>
			<e path="guise.platform.types.JointStyle"/>
		</SsSolid>
		<SsNone/>
	</enum>
	<enum path="guiseSkins.styled.HAlign" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<Right/>
		<Left/>
		<Center/>
	</enum>
	<enum path="guiseSkins.styled.VAlign" params="" file="../src/guiseSkins/styled/Styles.hx" module="guiseSkins.styled.Styles">
		<Top/>
		<Middle/>
		<Bottom/>
	</enum>
	<class path="guiseSkins.styled.TextStyleLayer" params="" file="../src/guiseSkins/styled/TextStyleLayer.hx">
		<extends path="guiseSkins.styled.AbsStyledLayer"><e path="guiseSkins.styled.TextLabelStyle"/></extends>
		<onTextChanged set="method" line="80"><f a="from">
	<c path="guise.controls.data.ITextLabel"/>
	<e path="Void"/>
</f></onTextChanged>
		<toCase set="method" line="68"><f a="str:textCase">
	<c path="String"/>
	<e path="guiseSkins.styled.TextCase"/>
	<c path="String"/>
</f></toCase>
		<_drawStyle set="method" line="58" override="1"><f a=""><e path="Void"/></f></_drawStyle>
		<_isReadyToDraw set="method" line="54" override="1"><f a=""><e path="Bool"/></f></_isReadyToDraw>
		<onTextRemove set="method" line="51"><f a="access">
	<c path="guise.platform.types.ITextOutputAccess"/>
	<e path="Void"/>
</f></onTextRemove>
		<onTextAdd set="method" line="47"><f a="access">
	<c path="guise.platform.types.ITextOutputAccess"/>
	<e path="Void"/>
</f></onTextAdd>
		<_textSize><c path="guise.traits.core.Size"/></_textSize>
		<_textPos><c path="guise.traits.core.Position"/></_textPos>
		<_textDisplay><c path="guise.platform.types.ITextOutputAccess"/></_textDisplay>
		<set_textLabel set="method" line="21"><f a="value">
	<c path="guise.controls.data.ITextLabel"/>
	<c path="guise.controls.data.ITextLabel"/>
</f></set_textLabel>
		<textLabel public="1" set="set_textLabel">
			<c path="guise.controls.data.ITextLabel"/>
			<meta><m n="inject"/></meta>
		</textLabel>
		<new public="1" set="method" line="37"><f a="layerName:?normalStyle">
	<c path="String"/>
	<e path="guiseSkins.styled.TextLabelStyle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* @author Tom Byrne</haxe_doc>
		<meta>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
			<m n=":build"><e>'???'</e></m>
			<m n=":autoBuild"><e>'???'</e></m>
		</meta>
	</class>
	<enum path="guiseSkins.styled.TextLabelStyle" params="" file="../src/guiseSkins/styled/TextStyleLayer.hx" module="guiseSkins.styled.TextStyleLayer"><Tls a="ts:selectable:?tc:?antiAliasing">
	<e path="guise.platform.types.TextStyle"/>
	<e path="Bool"/>
	<e path="guiseSkins.styled.TextCase"/>
	<e path="guise.platform.types.AntiAliasType"/>
</Tls></enum>
	<enum path="guiseSkins.styled.TextCase" params="" file="../src/guiseSkins/styled/TextStyleLayer.hx" module="guiseSkins.styled.TextStyleLayer">
		<TcUpper/>
		<TcTitle/>
		<TcNormal/>
		<TcLower/>
	</enum>
	<class path="guiseSkins.styled.styles.ChutzpahStyle" params="" file="../src/guiseSkins/styled/styles/ChutzpahStyle.hx">
		<_labelTextStyle static="1"><e path="guiseSkins.styled.TextLabelStyle"/></_labelTextStyle>
		<_inputTextStyle static="1"><e path="guiseSkins.styled.TextLabelStyle"/></_inputTextStyle>
		<_labelTextAlign static="1"><e path="guiseSkins.styled.FramingStyle"/></_labelTextAlign>
		<_inputTextAlign static="1"><e path="guiseSkins.styled.FramingStyle"/></_inputTextAlign>
		<_buttonTextFiltNorm static="1"><c path="Array"><e path="guise.platform.types.FilterType"/></c></_buttonTextFiltNorm>
		<_buttonBackNorm static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackNorm>
		<_buttonBackOver static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackOver>
		<_buttonBackDownUnsel static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackDownUnsel>
		<_buttonBackSelNorm static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackSelNorm>
		<_buttonBackSelOver static="1"><e path="guiseSkins.styled.BoxStyle"/></_buttonBackSelOver>
		<_inputBackNorm static="1"><e path="guiseSkins.styled.BoxStyle"/></_inputBackNorm>
		<_inputBackFocus static="1"><e path="guiseSkins.styled.BoxStyle"/></_inputBackFocus>
		<_buttonFiltNorm static="1"><c path="Array"><e path="guise.platform.types.FilterType"/></c></_buttonFiltNorm>
		<_buttonFiltDown static="1"><c path="Array"><e path="guise.platform.types.FilterType"/></c></_buttonFiltDown>
		<_styleTransitioner static="1"><c path="guiseSkins.styled.DefaultStyleTrans"/></_styleTransitioner>
		<install public="1" set="method" line="47" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<buttonBacking set="method" line="96" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.BoxLayer"/>
</f></buttonBacking>
		<labelText set="method" line="105" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.TextStyleLayer"/>
</f></labelText>
		<inputText set="method" line="108" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.TextStyleLayer"/>
</f></inputText>
		<textFilt set="method" line="111" static="1"><f a="layerName">
	<c path="String"/>
	<f a="">
		<d/>
		<c path="guiseSkins.styled.FilterLayer"/>
	</f>
</f></textFilt>
		<buttonFilter set="method" line="118" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FilterLayer"/>
</f></buttonFilter>
		<inputTextAlign set="method" line="125" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FramingLayer"/>
</f></inputTextAlign>
		<labelTextAlign set="method" line="128" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FramingLayer"/>
</f></labelTextAlign>
		<inputBacking set="method" line="132" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.BoxLayer"/>
</f></inputBacking>
		<inputFilter set="method" line="138" static="1"><f a="tag">
	<d/>
	<c path="guiseSkins.styled.FilterLayer"/>
</f></inputFilter>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.styled.styles.NormalLayering" params="" file="../src/guiseSkins/styled/styles/NormalLayering.hx">
		<install public="1" set="method" line="16" static="1"><f a="within">
	<c path="composure.core.ComposeItem"/>
	<e path="Void"/>
</f></install>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.ColorEaser" params="" file="../src/guiseSkins/trans/ColorEaser.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.ColorEaser"/></c></_pool>
		<getNew public="1" set="method" line="11" static="1"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="guiseSkins.trans.ColorEaser"/>
</f></getNew>
		<update public="1" set="method" line="53"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="48"><f a=""><e path="Void"/></f></release>
		<diffB public="1"><c path="Int"/></diffB>
		<diffG public="1"><c path="Int"/></diffG>
		<diffR public="1"><c path="Int"/></diffR>
		<startB public="1"><c path="Int"/></startB>
		<startG public="1"><c path="Int"/></startG>
		<startR public="1"><c path="Int"/></startR>
		<inited public="1"><e path="Bool"/></inited>
		<end public="1"><c path="Int"/></end>
		<start public="1"><c path="Int"/></start>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="42"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.EnumEaser" params="" file="../src/guiseSkins/trans/EnumEaser.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.EnumEaser"/></c></_pool>
		<getNew public="1" set="method" line="11" static="1"><f a="enumVal:params:parent:prop">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="String"/>
	<c path="guiseSkins.trans.EnumEaser"/>
</f></getNew>
		<update public="1" set="method" line="50"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="44"><f a=""><e path="Void"/></f></release>
		<enumConst><c path="String"/></enumConst>
		<enumType><c path="Enum"><d/></c></enumType>
		<inited><e path="Bool"/></inited>
		<prop public="1"><c path="String"/></prop>
		<parent public="1"><d/></parent>
		<params public="1"><c path="Array"><d/></c></params>
		<enumVal public="1"><d/></enumVal>
		<new public="1" set="method" line="36"><f a="enumVal:params:parent:prop">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.ITransTracker" params="" file="../src/guiseSkins/trans/ITransitioner.hx" module="guiseSkins.trans.ITransitioner" interface="1">
		<stopTrans public="1" set="method"><f a="gotoEnd">
	<e path="Bool"/>
	<e path="Void"/>
</f></stopTrans>
		<setFinishHandler public="1" set="method"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setFinishHandler>
		<setUpdateHandler public="1" set="method"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setUpdateHandler>
	</class>
	<class path="guiseSkins.trans.PropEaser" params="" file="../src/guiseSkins/trans/PropEaser.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.PropEaser"/></c></_pool>
		<getNew public="1" set="method" line="10" static="1"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="guiseSkins.trans.PropEaser"/>
</f></getNew>
		<update public="1" set="method" line="46"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="41"><f a=""><e path="Void"/></f></release>
		<diff public="1"><c path="Float"/></diff>
		<inited public="1"><e path="Bool"/></inited>
		<end public="1"><c path="Float"/></end>
		<start public="1"><c path="Float"/></start>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="34"><f a="subject:prop:start:end">
	<d/>
	<d/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.PropSetter" params="" file="../src/guiseSkins/trans/PropSetter.hx">
		<implements path="guiseSkins.trans.IPropEaser"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans.PropSetter"/></c></_pool>
		<getNew public="1" set="method" line="11" static="1"><f a="subject:prop:value">
	<d/>
	<d/>
	<d/>
	<c path="guiseSkins.trans.PropSetter"/>
</f></getNew>
		<update public="1" set="method" line="40"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="35"><f a=""><e path="Void"/></f></release>
		<value public="1"><d/></value>
		<prop public="1"><d/></prop>
		<subject public="1"><d/></subject>
		<new public="1" set="method" line="30"><f a="subject:prop:value">
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<enum path="guiseSkins.trans.Easing" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner">
		<EaseOut/>
		<EaseInOut/>
		<EaseIn/>
	</enum>
	<class path="guiseSkins.trans._StyleTransitioner.TransTracker" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" private="1" module="guiseSkins.trans.StyleTransitioner">
		<implements path="guiseSkins.trans.ITransTracker"/>
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.TransTracker"/></c></_pool>
		<getNew public="1" set="method" line="368" static="1"><f a="stopHandler">
	<f a="">
		<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
		<e path="Void"/>
	</f>
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
</f></getNew>
		<onComplete set="method" line="473"><f a=""><e path="Void"/></f></onComplete>
		<onUpdate set="method" line="470"><f a="fract">
	<c path="Float"/>
	<e path="Void"/>
</f></onUpdate>
		<tweenFract public="1" set="method" line="461"><f a="to:time:easing">
	<c path="Float"/>
	<c path="Float"/>
	<t path="Null"><t path="feffects.Easing"/></t>
	<e path="Void"/>
</f></tweenFract>
		<set_fract set="method" line="438"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></set_fract>
		<fract public="1" set="set_fract"><c path="Float"/></fract>
		<setFinishHandler public="1" set="method" line="433"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setFinishHandler>
		<setUpdateHandler public="1" set="method" line="430"><f a="handler">
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></setUpdateHandler>
		<stopTrans public="1" set="method" line="420"><f a="gotoEnd">
	<e path="Bool"/>
	<e path="Void"/>
</f></stopTrans>
		<_tween><c path="feffects.Tween"/></_tween>
		<transSpans public="1"><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.TransSpan"/></c></transSpans>
		<transStyle public="1"><c path="guiseSkins.trans.TransStyle"/></transStyle>
		<subject public="1"><d/></subject>
		<curr public="1"><d/></curr>
		<from public="1"><d/></from>
		<to public="1"><d/></to>
		<stopHandler><f a="">
	<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
	<e path="Void"/>
</f></stopHandler>
		<finish public="1" set="dynamic" line="400"><f a="curr">
	<d/>
	<e path="Void"/>
</f></finish>
		<update public="1" set="dynamic" line="399"><f a="curr">
	<d/>
	<e path="Void"/>
</f></update>
		<release public="1" set="method" line="380"><f a=""><e path="Void"/></f></release>
		<new public="1" set="method" line="416"><f a="stopHandler">
	<f a="">
		<c path="guiseSkins.trans._StyleTransitioner.TransTracker"/>
		<e path="Void"/>
	</f>
	<e path="Void"/>
</f></new>
	</class>
	<class path="guiseSkins.trans._StyleTransitioner.TransSpan" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" private="1" module="guiseSkins.trans.StyleTransitioner">
		<_pool static="1"><c path="Array"><c path="guiseSkins.trans._StyleTransitioner.TransSpan"/></c></_pool>
		<getNew public="1" set="method" line="479" static="1"><f a=""><c path="guiseSkins.trans._StyleTransitioner.TransSpan"/></f></getNew>
		<easeProps public="1"><c path="Array"><c path="guiseSkins.trans.IPropEaser"/></c></easeProps>
		<length public="1"><c path="Float"/></length>
		<start public="1"><c path="Float"/></start>
		<release public="1" set="method" line="489"><f a=""><e path="Void"/></f></release>
		<new public="1" set="method" line="504"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="guiseSkins.trans._StyleTransitioner.PropEaserInfo" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" private="1" module="guiseSkins.trans.StyleTransitioner">
		<propEaserFact public="1"><t path="guiseSkins.trans.EaserFactFunc"/></propEaserFact>
		<paramIndex public="1"><c path="Int"/></paramIndex>
		<styleType public="1"><d/></styleType>
		<new public="1" set="method" line="511"><f a="styleType:paramIndex:propEaserFact">
	<d/>
	<c path="Int"/>
	<t path="guiseSkins.trans.EaserFactFunc"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="guiseSkins.trans.EaserFactFunc" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::">
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="guiseSkins.trans.IPropEaser"/>
</f></typedef>
	<typedef path="guiseSkins.trans.SwitchCheck" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::">
	<d/>
	<c path="Array"><d/></c>
	<d/>
	<c path="Array"><d/></c>
	<e path="Bool"/>
</f></typedef>
	<typedef path="guiseSkins.trans.SwitchSpanInfo" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><a>
	<via><d/></via>
	<toParams><c path="Array"><d/></c></toParams>
	<easerFuncs><c path="Array"><t path="guiseSkins.trans.EaserFactFunc"/></c></easerFuncs>
</a></typedef>
	<typedef path="guiseSkins.trans.EnumValSwitchFact" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::::">
	<d/>
	<e path="Bool"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></typedef>
	<typedef path="guiseSkins.trans.EnumSwitchFact" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner"><f a=":::::">
	<d/>
	<e path="Bool"/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Enum"><d/></c>
	<d/>
	<c path="Array"><t path="guiseSkins.trans.SwitchSpanInfo"/></c>
</f></typedef>
	<enum path="guiseSkins.trans.StyleSwitch" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner">
		<EnumValueSwitch a="switchFact:enumVal1:enumVal2:?check">
			<t path="guiseSkins.trans.EnumValSwitchFact"/>
			<d/>
			<d/>
			<t path="guiseSkins.trans.SwitchCheck"/>
		</EnumValueSwitch>
		<EnumTypeSwitch a="switchFact:enum1:enum2:?check">
			<t path="guiseSkins.trans.EnumSwitchFact"/>
			<c path="Enum"><d/></c>
			<c path="Enum"><d/></c>
			<t path="guiseSkins.trans.SwitchCheck"/>
		</EnumTypeSwitch>
	</enum>
	<enum path="guiseSkins.trans.SwitchParamType" params="" file="../src/guiseSkins/trans/StyleTransitioner.hx" module="guiseSkins.trans.StyleTransitioner">
		<UseStyle/>
		<SwitchEase a="?easerFact"><t path="guiseSkins.trans.EaserFactFunc"/></SwitchEase>
		<NormalEase a="?easerFact"><t path="guiseSkins.trans.EaserFactFunc"/></NormalEase>
	</enum>
	<class path="guiseSkins.trans.TransStyle" params="" file="../src/guiseSkins/trans/TransStyle.hx">
		<easing public="1"><e path="guiseSkins.trans.Easing"/></easing>
		<time public="1"><c path="Float"/></time>
		<new public="1" set="method" line="14"><f a="time:easing">
	<c path="Float"/>
	<e path="guiseSkins.trans.Easing"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="guiseSkins.trans.UtilFunctions" params="" file="../src/guiseSkins/trans/UtilFunctions.hx">
		<setProperty public="1" get="inline" set="null" line="10" static="1"><f a="subject:prop:value">
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></setProperty>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="haxe.FastCell_feffects_Tween" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<next public="1"><c path="haxe.FastCell_feffects_Tween"/></next>
		<elt public="1"><c path="feffects.Tween"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="feffects.Tween"/>
	<c path="haxe.FastCell_feffects_Tween"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastCell_guise_traits_core_IActive" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<next public="1"><c path="haxe.FastCell_guise_traits_core_IActive"/></next>
		<elt public="1"><c path="guise.traits.core.IActive"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="guise.traits.core.IActive"/>
	<c path="haxe.FastCell_guise_traits_core_IActive"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastCell" params="T" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx" module="haxe.FastList">
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<new public="1" set="method" line="33"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. A different class is created for each container used in platforms where it matters</haxe_doc>
	</class>
	<class path="haxe.FastList_guise_traits_core_IActive" params="" file="C:\Motion-Twin\haxe\std/haxe/FastList.hx">
		<toString public="1" set="method" line="156">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="guise.traits.core.IActive"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="107">
			<f a="v">
				<c path="guise.traits.core.IActive"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<isEmpty public="1" get="inline" set="null" line="99">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" get="inline" set="null" line="86">
			<f a=""><t path="Null"><c path="guise.traits.core.IActive"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<first public="1" get="inline" set="null" line="77">
			<f a=""><t path="Null"><c path="guise.traits.core.IActive"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<add public="1" get="inline" set="null" line="69">
			<f a="item">
				<c path="guise.traits.core.IActive"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the head of the list.</haxe_doc>
		</add>
		<head public="1"><c path="haxe.FastCell_guise_traits_core_IActive"/></head>
		<new public="1" set="method" line="63">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
	</class>
	<class path="haxe.Log" params="" file="C:\Motion-Twin\haxe\std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" set="dynamic" line="63" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\Motion-Twin\haxe\std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="haxe.Serializer" params="" file="C:\Motion-Twin\haxe\std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>Use constructor indexes for enums instead of names.
		This is less reliable but more compact.</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" set="method" line="436" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Serialize a single value and return the string.</haxe_doc>
		</run>
		<serializeException public="1" set="method" line="417"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<serialize public="1" set="method" line="158"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeFields set="method" line="150"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serializeClassFields set="method" line="136"><f a="v:c">
	<a><hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty></a>
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></serializeClassFields>
		<serializeRef set="method" line="113"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeString set="method" line="94"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<toString public="1" set="method" line="60"><f a=""><c path="String"/></f></toString>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<useCache public="1"><e path="Bool"/></useCache>
		<scount><c path="Int"/></scount>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<cache><c path="Array"><d/></c></cache>
		<buf><c path="StringBuf"/></buf>
		<new public="1" set="method" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.Timer" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/haxe/Timer.hx">
		<delay public="1" set="method" line="54" static="1">
			<f a="f:time_ms">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="haxe.Timer"/>
			</f>
			<haxe_doc>This will delay the call to [f] for the given time. [f] will only be called once.</haxe_doc>
		</delay>
		<measure public="1" params="T" set="method" line="68" static="1">
			<f a="f:?pos">
				<f a=""><c path="measure.T"/></f>
				<t path="haxe.PosInfos"/>
				<c path="measure.T"/>
			</f>
			<haxe_doc>Measure the time it takes to execute the function [f] and trace it. Returns the value returned by [f].</haxe_doc>
		</measure>
		<stamp public="1" set="method" line="78" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the most precise timestamp, in seconds. The value itself might differ depending on platforms, only differences between two values make sense.</haxe_doc>
		</stamp>
		<run public="1" set="dynamic" line="48">
			<f a=""><e path="Void"/></f>
			<haxe_doc>This is the [run()] method that is called when the Timer executes. It can be either overriden in subclasses or directly rebinded with another function-value.</haxe_doc>
		</run>
		<stop public="1" set="method" line="32">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Stop the timer definitely.</haxe_doc>
		</stop>
		<id><t path="Null"><c path="Int"/></t></id>
		<new public="1" set="method" line="16">
			<f a="time_ms">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Create a new timer that will run every [time_ms] (in milliseconds).</haxe_doc>
		</new>
	</class>
	<typedef path="haxe.TypeResolver" params="" file="C:\Motion-Twin\haxe\std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum set="method"><f a="name">
	<c path="String"/>
	<c path="Enum"><d/></c>
</f></resolveEnum>
	<resolveClass set="method"><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<class path="haxe.Unserializer" params="" file="C:\Motion-Twin\haxe\std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="flash.utils.ByteArray"/></CODES>
		<initCodes set="method" line="41" static="1"><f a=""><c path="flash.utils.ByteArray"/></f></initCodes>
		<run public="1" set="method" line="351" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Unserialize a single value and return it.</haxe_doc>
		</run>
		<unserialize public="1" set="method" line="151"><f a=""><d/></f></unserialize>
		<unserializeEnum set="method" line="139"><f a="edecl:tag">
	<c path="Enum"><unknown/></c>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserializeObject set="method" line="124"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<readDigits set="method" line="99"><f a=""><c path="Int"/></f></readDigits>
		<get get="inline" set="null" line="95"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<getResolver public="1" set="method" line="91"><f a=""><t path="haxe.TypeResolver"/></f></getResolver>
		<setResolver public="1" set="method" line="81"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<scache><c path="Array"><c path="String"/></c></scache>
		<cache><c path="Array"><d/></c></cache>
		<length><c path="Int"/></length>
		<pos><c path="Int"/></pos>
		<buf><c path="String"/></buf>
		<new public="1" set="method" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Bytes" params="" file="C:\Motion-Twin\haxe\std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="259" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="291" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="340" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<getData public="1" get="inline" set="null" line="255"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="241"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="218"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="168"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="130"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="103"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="71"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="53"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><c path="Int"/></length>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="C:\Motion-Twin\haxe\std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<enum path="haxe.io.Error" params="" file="C:\Motion-Twin\haxe\std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<typedef path="haxe.macro.Position" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<min><c path="Int"/></min>
	<max><c path="Int"/></max>
	<file><c path="String"/></file>
</a></typedef>
	<enum path="haxe.macro.Constant" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CType a="s"><c path="String"/></CType>
		<CString a="s"><c path="String"/></CString>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
		</CRegexp>
		<CInt a="v"><c path="String"/></CInt>
		<CIdent a="s"><c path="String"/></CIdent>
		<CFloat a="f"><c path="String"/></CFloat>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpXor/>
		<OpUShr/>
		<OpSub/>
		<OpShr/>
		<OpShl/>
		<OpOr/>
		<OpNotEq/>
		<OpMult/>
		<OpMod/>
		<OpLte/>
		<OpLt/>
		<OpInterval/>
		<OpGte/>
		<OpGt/>
		<OpEq/>
		<OpDiv/>
		<OpBoolOr/>
		<OpBoolAnd/>
		<OpAssignOp a="op"><e path="haxe.macro.Binop"/></OpAssignOp>
		<OpAssign/>
		<OpAnd/>
		<OpAdd/>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpNot/>
		<OpNegBits/>
		<OpNeg/>
		<OpIncrement/>
		<OpDecrement/>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<expr><e path="haxe.macro.ExprDef"/></expr>
</a></typedef>
	<typedef path="haxe.macro.ExprRequire" params="T" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><t path="haxe.macro.Expr"/></typedef>
	<enum path="haxe.macro.ExprDef" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EWhile>
		<EVars a="vars"><c path="Array"><a>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<name><c path="String"/></name>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
</a></c></EVars>
		<EUntyped a="e"><t path="haxe.macro.Expr"/></EUntyped>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<e path="Bool"/>
			<t path="haxe.macro.Expr"/>
		</EUnop>
		<EType a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EType>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<type><e path="haxe.macro.ComplexType"/></type>
	<name><c path="String"/></name>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
		</ETry>
		<EThrow a="e"><t path="haxe.macro.Expr"/></EThrow>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</ETernary>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><a>
	<values><c path="Array"><t path="haxe.macro.Expr"/></c></values>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</ESwitch>
		<EReturn a="?e"><t path="haxe.macro.Expr"/></EReturn>
		<EParenthesis a="e"><t path="haxe.macro.Expr"/></EParenthesis>
		<EObjectDecl a="fields"><c path="Array"><a>
	<field><c path="String"/></field>
	<expr><t path="haxe.macro.Expr"/></expr>
</a></c></EObjectDecl>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ENew>
		<EIn a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EIn>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="Null"><t path="haxe.macro.Expr"/></t>
		</EIf>
		<EFunction a="name:f">
			<t path="Null"><c path="String"/></t>
			<t path="haxe.macro.Function"/>
		</EFunction>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EFor>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
		</EField>
		<EDisplayNew a="t"><t path="haxe.macro.TypePath"/></EDisplayNew>
		<EDisplay a="e:isCall">
			<t path="haxe.macro.Expr"/>
			<e path="Bool"/>
		</EDisplay>
		<EContinue/>
		<EConst a="c"><e path="haxe.macro.Constant"/></EConst>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
		</ECheckType>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
		</ECast>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
		</ECall>
		<EBreak/>
		<EBlock a="exprs"><c path="Array"><t path="haxe.macro.Expr"/></c></EBlock>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EBinop>
		<EArrayDecl a="values"><c path="Array"><t path="haxe.macro.Expr"/></c></EArrayDecl>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
		</EArray>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p"><t path="haxe.macro.TypePath"/></TPath>
		<TParent a="t"><e path="haxe.macro.ComplexType"/></TParent>
		<TOptional a="t"><e path="haxe.macro.ComplexType"/></TOptional>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
		</TFunction>
		<TExtend a="p:fields">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Field"/></c>
		</TExtend>
		<TAnonymous a="fields"><c path="Array"><t path="haxe.macro.Field"/></c></TAnonymous>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<sub>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</sub>
	<params><c path="Array"><e path="haxe.macro.TypeParam"/></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
</a></typedef>
	<enum path="haxe.macro.TypeParam" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
	</enum>
	<typedef path="haxe.macro.Function" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<ret><t path="Null"><e path="haxe.macro.ComplexType"/></t></ret>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<expr><t path="Null"><t path="haxe.macro.Expr"/></t></expr>
	<args><c path="Array"><t path="haxe.macro.FunctionArg"/></c></args>
</a></typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<value>
		<t path="Null"><t path="haxe.macro.Expr"/></t>
		<meta><m n=":optional"/></meta>
	</value>
	<type><t path="Null"><e path="haxe.macro.ComplexType"/></t></type>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="haxe.macro.Metadata" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><t path="haxe.macro.Expr"/></c></params>
	<name><c path="String"/></name>
</a></c></typedef>
	<typedef path="haxe.macro.Field" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta>
		<t path="haxe.macro.Metadata"/>
		<meta><m n=":optional"/></meta>
	</meta>
	<kind><e path="haxe.macro.FieldType"/></kind>
	<doc>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</doc>
	<access>
		<c path="Array"><e path="haxe.macro.Access"/></c>
		<meta><m n=":optional"/></meta>
	</access>
</a></typedef>
	<enum path="haxe.macro.Access" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<AStatic/>
		<APublic/>
		<APrivate/>
		<AOverride/>
		<AInline/>
		<ADynamic/>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<t path="Null"><e path="haxe.macro.ComplexType"/></t>
			<t path="haxe.macro.Expr"/>
		</FVar>
		<FProp a="get:set:t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<t path="haxe.macro.Expr"/>
		</FProp>
		<FFun a="f"><t path="haxe.macro.Function"/></FFun>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<name><c path="String"/></name>
	<constraints><c path="Array"><e path="haxe.macro.ComplexType"/></c></constraints>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.Metadata"/></meta>
	<kind><e path="haxe.macro.TypeDefKind"/></kind>
	<isExtern><e path="Bool"/></isExtern>
	<fields><c path="Array"><t path="haxe.macro.Field"/></c></fields>
</a></typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDStructure/>
		<TDEnum/>
		<TDClass a="?extend:?implement:?isInterface">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<e path="Bool"/>
		</TDClass>
	</enum>
	<class path="haxe.macro.Error" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<pos public="1"><t path="haxe.macro.Position"/></pos>
		<message public="1"><c path="String"/></message>
		<new public="1" set="method" line="213"><f a="m:p">
	<c path="String"/>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>This error can be used to handle or produce compilation errors in macros.</haxe_doc>
	</class>
	<typedef path="haxe.macro.Ref" params="T" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<toString set="method"><f a=""><c path="String"/></f></toString>
	<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
</a></typedef>
	<enum path="haxe.macro.Type" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx">
		<TType a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.DefType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TType>
		<TMono a="t"><t path="haxe.macro.Ref"><t path="Null"><e path="haxe.macro.Type"/></t></t></TMono>
		<TLazy a="f"><f a=""><e path="haxe.macro.Type"/></f></TLazy>
		<TInst a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TInst>
		<TFun a="args:ret">
			<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<opt><e path="Bool"/></opt>
	<name><c path="String"/></name>
</a></c>
			<e path="haxe.macro.Type"/>
		</TFun>
		<TEnum a="t:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.EnumType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</TEnum>
		<TDynamic a="t"><t path="Null"><e path="haxe.macro.Type"/></t></TDynamic>
		<TAnonymous a="a"><t path="haxe.macro.Ref"><t path="haxe.macro.AnonType"/></t></TAnonymous>
	</enum>
	<typedef path="haxe.macro.AnonType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a><fields><c path="Array"><t path="haxe.macro.ClassField"/></c></fields></a></typedef>
	<typedef path="haxe.macro.BaseType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.ClassField" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.FieldKind"/></kind>
	<isPublic><e path="Bool"/></isPublic>
	<expr set="method"><f a=""><t path="Null"><e path="haxe.macro.TypedExpr"/></t></f></expr>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<enum path="haxe.macro.ClassKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<KTypeParameter/>
		<KNormal/>
		<KMacroType/>
		<KGenericInstance a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KGenericInstance>
		<KGeneric/>
		<KExtension a="cl:params">
			<t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t>
			<c path="Array"><e path="haxe.macro.Type"/></c>
		</KExtension>
		<KExpr a="expr"><t path="haxe.macro.Expr"/></KExpr>
	</enum>
	<typedef path="haxe.macro.ClassType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<superClass><t path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></t></superClass>
	<statics><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></statics>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<kind><e path="haxe.macro.ClassKind"/></kind>
	<isPrivate><e path="Bool"/></isPrivate>
	<isInterface><e path="Bool"/></isInterface>
	<isExtern><e path="Bool"/></isExtern>
	<interfaces><c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c></interfaces>
	<init><t path="Null"><e path="haxe.macro.TypedExpr"/></t></init>
	<fields><t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t></fields>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructor><t path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></t></constructor>
</a></typedef>
	<typedef path="haxe.macro.EnumField" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<index><c path="Int"/></index>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.EnumType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<names><c path="Array"><c path="String"/></c></names>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
	<constructs><c path="Hash"><t path="haxe.macro.EnumField"/></c></constructs>
</a></typedef>
	<typedef path="haxe.macro.DefType" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<type><e path="haxe.macro.Type"/></type>
	<pos><t path="haxe.macro.Position"/></pos>
	<params><c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<name><c path="String"/></name>
</a></c></params>
	<pack><c path="Array"><c path="String"/></c></pack>
	<name><c path="String"/></name>
	<module><c path="String"/></module>
	<meta><t path="haxe.macro.MetaAccess"/></meta>
	<isPrivate><e path="Bool"/></isPrivate>
	<isExtern><e path="Bool"/></isExtern>
	<exclude set="method"><f a=""><e path="Void"/></f></exclude>
	<doc><t path="Null"><c path="String"/></t></doc>
</a></typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"><a>
	<remove set="method"><f a="name">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
	<has set="method"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></has>
	<get set="method"><f a=""><t path="haxe.macro.Metadata"/></f></get>
	<add set="method"><f a="name:params:pos">
	<c path="String"/>
	<c path="Array"><t path="haxe.macro.Expr"/></c>
	<t path="haxe.macro.Position"/>
	<e path="Void"/>
</f></add>
</a></typedef>
	<enum path="haxe.macro.FieldKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<FVar a="read:write">
			<e path="haxe.macro.VarAccess"/>
			<e path="haxe.macro.VarAccess"/>
		</FVar>
		<FMethod a="k"><e path="haxe.macro.MethodKind"/></FMethod>
	</enum>
	<enum path="haxe.macro.VarAccess" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<AccResolve/>
		<AccRequire a="r"><c path="String"/></AccRequire>
		<AccNormal/>
		<AccNo/>
		<AccNever/>
		<AccInline/>
		<AccCall a="m"><c path="String"/></AccCall>
	</enum>
	<enum path="haxe.macro.MethodKind" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<MethNormal/>
		<MethMacro/>
		<MethInline/>
		<MethDynamic/>
	</enum>
	<enum path="haxe.macro.TypedExpr" params="" file="C:\Motion-Twin\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type"/>
	<typedef path="msignal.AnySignal" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal"><c path="msignal.Signal">
	<d/>
	<d/>
</c></typedef>
	<class path="msignal.Signal" params="TSlot:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx">
		<get_numListeners set="method" line="167"><f a=""><c path="Int"/></f></get_numListeners>
		<createSlot set="method" line="162">
			<f a="listener:?once:?priority">
				<c path="msignal.Signal.TListener"/>
				<e path="Bool"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<meta><m n="IgnoreCover"/></meta>
		</createSlot>
		<registrationPossible set="method" line="144"><f a="listener:once">
	<c path="msignal.Signal.TListener"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></registrationPossible>
		<registerListener set="method" line="128"><f a="listener:?once:?priority">
	<c path="msignal.Signal.TListener"/>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Signal.TSlot"/>
</f></registerListener>
		<removeAll public="1" set="method" line="123">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Unsubscribes all listeners from the signal.</haxe_doc>
		</removeAll>
		<remove public="1" set="method" line="111">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Unsubscribes a listener from the signal.
	
	@param listener The listener to remove
	@return The removed listener slot</haxe_doc>
		</remove>
		<addOnceWithPriority public="1" set="method" line="100">
			<f a="listener:?priority">
				<c path="msignal.Signal.TListener"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a one-time listener for this signal.
	The signal will remove the listener automatically the first time it is called,
	after the dispatch to all listeners is complete.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addOnceWithPriority>
		<addWithPriority public="1" set="method" line="87">
			<f a="listener:?priority">
				<c path="msignal.Signal.TListener"/>
				<c path="Int"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a listener for the signal.
	After you successfully register an event listener,
	you cannot change its priority through additional calls to add().
	To change a listener's priority, you must first call remove().
	Then you can register the listener again with the new priority level.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addWithPriority>
		<addOnce public="1" set="method" line="72">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a one-time listener for this signal.
	The signal will remove the listener automatically the first time it is called,
	after the dispatch to all listeners is complete.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</addOnce>
		<add public="1" set="method" line="59">
			<f a="listener">
				<c path="msignal.Signal.TListener"/>
				<c path="msignal.Signal.TSlot"/>
			</f>
			<haxe_doc>Subscribes a listener for the signal.
	
	@param listener A function matching the signature of TListener
	@return The added listener slot</haxe_doc>
		</add>
		<priorityBased><e path="Bool"/></priorityBased>
		<slots><c path="msignal.SlotList">
	<c path="msignal.Signal.TSlot"/>
	<c path="msignal.Signal.TListener"/>
</c></slots>
		<numListeners public="1" get="get_numListeners" set="null">
			<c path="Int"/>
			<haxe_doc>The current number of listeners for the signal.</haxe_doc>
		</numListeners>
		<valueClasses public="1"><c path="Array"><d/></c></valueClasses>
		<new set="method" line="45"><f a="?valueClasses">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></new>
		<haxe_doc>A Signal manages a list of listeners, which are executed when the signal is 
dispatched.</haxe_doc>
	</class>
	<class path="msignal.Signal0" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot0"/>
			<f a=""><e path="Void"/></f>
		</extends>
		<createSlot set="method" line="197" override="1"><f a="listener:?once:?priority">
	<f a=""><e path="Void"/></f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot0"/>
</f></createSlot>
		<dispatch public="1" set="method" line="186">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Executes the signals listeners with no arguements.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="178"><f a=""><e path="Void"/></f></new>
		<haxe_doc>Signal that executes listeners with no arguments.</haxe_doc>
	</class>
	<class path="msignal.Signal1" params="TValue" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
			<f a="">
				<c path="msignal.Signal1.TValue"/>
				<e path="Void"/>
			</f>
		</extends>
		<createSlot set="method" line="227" override="1"><f a="listener:?once:?priority">
	<f a="">
		<c path="msignal.Signal1.TValue"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot1"><c path="msignal.Signal1.TValue"/></c>
</f></createSlot>
		<dispatch public="1" set="method" line="216">
			<f a="value">
				<c path="msignal.Signal1.TValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Executes the signals listeners with one arguement.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="208"><f a="?type">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Signal that executes listeners with one arguments.</haxe_doc>
	</class>
	<class path="msignal.Signal2" params="TValue1:TValue2" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Signal.hx" module="msignal.Signal">
		<extends path="msignal.Signal">
			<c path="msignal.Slot2">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
			</c>
			<f a=":">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
				<e path="Void"/>
			</f>
		</extends>
		<createSlot set="method" line="257" override="1"><f a="listener:?once:?priority">
	<f a=":">
		<c path="msignal.Signal2.TValue1"/>
		<c path="msignal.Signal2.TValue2"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<c path="msignal.Slot2">
		<c path="msignal.Signal2.TValue1"/>
		<c path="msignal.Signal2.TValue2"/>
	</c>
</f></createSlot>
		<dispatch public="1" set="method" line="246">
			<f a="value1:value2">
				<c path="msignal.Signal2.TValue1"/>
				<c path="msignal.Signal2.TValue2"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Executes the signals listeners with two arguements.</haxe_doc>
		</dispatch>
		<new public="1" set="method" line="238"><f a="?type1:?type2">
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Signal that executes listeners with two arguments.</haxe_doc>
	</class>
	<typedef path="msignal.AnySlot" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot"><c path="msignal.Slot">
	<d/>
	<d/>
</c></typedef>
	<class path="msignal.Slot" params="TSignal:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx">
		<set_listener set="method" line="91"><f a="value">
	<c path="msignal.Slot.TListener"/>
	<c path="msignal.Slot.TListener"/>
</f></set_listener>
		<remove public="1" set="method" line="76">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Removes the slot from its signal.</haxe_doc>
		</remove>
		<signal><c path="msignal.Slot.TSignal"/></signal>
		<enabled public="1">
			<e path="Bool"/>
			<haxe_doc>Whether the listener is called on execution. Defaults to true.</haxe_doc>
		</enabled>
		<priority public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The priority of this slot should be given in the execution order.
	An Signal will call higher numbers before lower ones.
	Defaults to 0.</haxe_doc>
		</priority>
		<once public="1" set="null">
			<e path="Bool"/>
			<haxe_doc>Whether this slot is automatically removed after it has been used once.</haxe_doc>
		</once>
		<listener public="1" set="set_listener">
			<c path="msignal.Slot.TListener"/>
			<haxe_doc>The listener associated with this slot.
	Note: for hxcpp 2.10 this requires a getter method to compile</haxe_doc>
		</listener>
		<new set="method" line="64"><f a="signal:listener:?once:?priority">
	<c path="msignal.Slot.TSignal"/>
	<c path="msignal.Slot.TListener"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Defines the basic properties of a listener associated with a Signal.</haxe_doc>
	</class>
	<class path="msignal.Slot0" params="" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal0"/>
			<f a=""><e path="Void"/></f>
		</extends>
		<execute public="1" set="method" line="111">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Executes a listener with no arguments.</haxe_doc>
		</execute>
		<new public="1" set="method" line="103"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal0"/>
	<f a=""><e path="Void"/></f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with no arguments.</haxe_doc>
	</class>
	<class path="msignal.Slot1" params="TValue" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
			<f a="">
				<c path="msignal.Slot1.TValue"/>
				<e path="Void"/>
			</f>
		</extends>
		<execute public="1" set="method" line="138">
			<f a="value1">
				<c path="msignal.Slot1.TValue"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Executes a listener with one argument.
	If <code>param</code> is not null, it overrides the value provided.]]></haxe_doc>
		</execute>
		<param public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the argument to dispatch.</haxe_doc>
		</param>
		<new public="1" set="method" line="129"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal1"><c path="msignal.Slot1.TValue"/></c>
	<f a="">
		<c path="msignal.Slot1.TValue"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with one argument.</haxe_doc>
	</class>
	<class path="msignal.Slot2" params="TValue1:TValue2" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/Slot.hx" module="msignal.Slot">
		<extends path="msignal.Slot">
			<c path="msignal.Signal2">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
			</c>
			<f a=":">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
				<e path="Void"/>
			</f>
		</extends>
		<execute public="1" set="method" line="172">
			<f a="value1:value2">
				<c path="msignal.Slot2.TValue1"/>
				<c path="msignal.Slot2.TValue2"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Executes a listener with two arguments.
	If <code>param1</code> or <code>param2</code> is set, 
	they override the values provided.]]></haxe_doc>
		</execute>
		<param2 public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the second argument to dispatch.</haxe_doc>
		</param2>
		<param1 public="1">
			<d/>
			<haxe_doc>Allows the slot to inject the first argument to dispatch.</haxe_doc>
		</param1>
		<new public="1" set="method" line="162"><f a="signal:listener:?once:?priority">
	<c path="msignal.Signal2">
		<c path="msignal.Slot2.TValue1"/>
		<c path="msignal.Slot2.TValue2"/>
	</c>
	<f a=":">
		<c path="msignal.Slot2.TValue1"/>
		<c path="msignal.Slot2.TValue2"/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>A slot that executes a listener with two arguments.</haxe_doc>
	</class>
	<class path="msignal.SlotList" params="TSlot:TListener" file="C:\Motion-Twin\haxe\lib\msignal/1,1,2/msignal/SlotList.hx">
		<NIL public="1" static="1">
			<c path="msignal.SlotList">
				<d/>
				<d/>
			</c>
			<haxe_doc>Represents an empty list. Used as the list terminator.</haxe_doc>
		</NIL>
		<find public="1" set="method" line="240">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList.TSlot"/>
			</f>
			<haxe_doc>Retrieves the Slot associated with a supplied listener within the SlotList.
	@param   listener The Function being searched for
	@return  The ISlot in this list associated with the listener parameter through the ISlot.listener property.
			 Returns null if no such ISlot instance exists or the list is empty.</haxe_doc>
		</find>
		<contains public="1" set="method" line="220">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Determines whether the supplied listener Function is contained within this list</haxe_doc>
		</contains>
		<filterNot public="1" set="method" line="189">
			<f a="listener">
				<c path="msignal.SlotList.TListener"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Returns the slots in this list that do not contain the supplied listener.
	Note: assumes the listener is not repeated within the list.
	@param	listener The function to remove.
	@return A list consisting of all elements of this list that do not have listener.</haxe_doc>
		</filterNot>
		<insertWithPriority public="1" set="method" line="152"><f a="slot">
	<c path="msignal.SlotList.TSlot"/>
	<c path="msignal.SlotList">
		<c path="msignal.SlotList.TSlot"/>
		<c path="msignal.SlotList.TListener"/>
	</c>
</f></insertWithPriority>
		<append public="1" set="method" line="118">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Appends a slot to this list.
	Note: appending is O(n). Where possible, prepend which is O(1).
	In some cases, many list items must be cloned to 
	avoid changing existing lists.
	@param	slot The item to be appended.
	@return	A list consisting of all elements of this list followed by slot.</haxe_doc>
		</append>
		<prepend public="1" set="method" line="105">
			<f a="slot">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
			</f>
			<haxe_doc>Prepends a slot to this list.
	@param	slot The item to be prepended.
	@return	A list consisting of slot followed by all elements of this list.</haxe_doc>
		</prepend>
		<get_length set="method" line="79"><f a=""><c path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null">
			<c path="Int"/>
			<haxe_doc>The number of slots in the list.</haxe_doc>
		</length>
		<nonEmpty public="1"><e path="Bool"/></nonEmpty>
		<tail public="1"><c path="msignal.SlotList">
	<c path="msignal.SlotList.TSlot"/>
	<c path="msignal.SlotList.TListener"/>
</c></tail>
		<head public="1"><c path="msignal.SlotList.TSlot"/></head>
		<new public="1" set="method" line="49">
			<f a="head:?tail">
				<c path="msignal.SlotList.TSlot"/>
				<c path="msignal.SlotList">
					<c path="msignal.SlotList.TSlot"/>
					<c path="msignal.SlotList.TListener"/>
				</c>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Creates and returns a new SlotList object.
	 *
	<p>A user never has to create a SlotList manually. 
	Use the <code>NIL</code> element to represent an empty list. 
	<code>NIL.prepend(value)</code> would create a list containing <code>value</code></p>.
	 *
	@param head The first slot in the list.
	@param tail A list containing all slots except head.]]></haxe_doc>
		</new>
	</class>
	<class path="nme.Assets" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/Assets.hx">
		<cachedBitmapData public="1" line="32" static="1"><c path="Hash"><t path="nme.display.BitmapData"/></c></cachedBitmapData>
		<getBitmapData public="1" set="method" line="42" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<e path="Bool"/>
				<t path="nme.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap (Assets.getBitmapData ("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache (Default: true)
	 * @return		A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="54" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes ("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="66" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont ("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getSound public="1" set="method" line="78" static="1">
			<f a="id">
				<c path="String"/>
				<t path="nme.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound ("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="90" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText ("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>
 * 
 * @author Joshua Granick]]></haxe_doc>
	</class>
	<class path="nme.Lib" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/Lib.hx">
		<FULLSCREEN public="1" line="13" static="1"><c path="Int"/></FULLSCREEN>
		<BORDERLESS public="1" line="14" static="1"><c path="Int"/></BORDERLESS>
		<RESIZABLE public="1" line="15" static="1"><c path="Int"/></RESIZABLE>
		<HARDWARE public="1" line="16" static="1"><c path="Int"/></HARDWARE>
		<VSYNC public="1" line="17" static="1"><c path="Int"/></VSYNC>
		<HW_AA public="1" line="18" static="1"><c path="Int"/></HW_AA>
		<HW_AA_HIRES public="1" line="19" static="1"><c path="Int"/></HW_AA_HIRES>
		<ALLOW_SHADERS public="1" line="20" static="1"><c path="Int"/></ALLOW_SHADERS>
		<company public="1" get="nmeGetCompany" set="null" static="1"><c path="String"/></company>
		<current public="1" get="nmeGetCurrent" set="null" static="1"><t path="nme.display.MovieClip"/></current>
		<file public="1" get="nmeGetFile" set="null" static="1"><c path="String"/></file>
		<initHeight public="1" get="nmeGetInitHeight" set="null" static="1"><c path="Int"/></initHeight>
		<initWidth public="1" get="nmeGetInitWidth" set="null" static="1"><c path="Int"/></initWidth>
		<packageName public="1" get="nmeGetPackageName" set="null" static="1"><c path="String"/></packageName>
		<stage public="1" get="nmeGetStage" set="null" static="1"><t path="nme.display.Stage"/></stage>
		<version public="1" get="nmeGetVersion" set="null" static="1"><c path="String"/></version>
		<close public="1" set="method" line="36" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Closes the application.
	 * This is method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</close>
		<create public="1" set="method" line="59" static="1">
			<f a="onLoaded:width:height:?frameRate:?color:?flags:?title:?icon">
				<f a=""><e path="Void"/></f>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
				<t path="nme.display.BitmapData"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Creates a new application window. If you are using the NME
	 * command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This is method is ignored in the Flash and HTML5 targets.
	 * @param	onLoaded		A method callback that is called once the window is created.
	 * @param	width		The requested width of the window. Use a width and height of 0 to request the full screen size.
	 * @param	height		The requested height of the window. Use a width and height of 0 to request the full screen size.
	 * @param	frameRate		The requested frame rate for the application.
	 * @param	color		An RGB color to use for the application background.
	 * @param	flags		A series of bit flags which can specify windowing options, like FULLSCREEN or HARDWARE
	 * @param	title		The title to use when creating the application window.
	 * @param	icon		An icon to use for the created application window.</haxe_doc>
		</create>
		<createManagedStage public="1" set="method" line="75" static="1">
			<f a="width:height">
				<c path="Int"/>
				<c path="Int"/>
				<unknown/>
			</f>
			<haxe_doc>* Creates a managed stage, for greater control customization and control
	 * of application events.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	width		The requested width of the managed stage.
	 * @param	height		The requested width of the managed stage.</haxe_doc>
		</createManagedStage>
		<exit public="1" set="method" line="91" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Similar to the <code>close()</code> method, but the current 
	 * <code>Stage</code> object is given an opportunity to handle 
	 * the quit event before the application process is ended.
	 * This method is ignored in the Flash and HTML5 targets.]]></haxe_doc>
		</exit>
		<forceClose public="1" set="method" line="105" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Terminates the application process immediately without
	 * performing a clean shutdown.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</forceClose>
		<getTimer public="1" get="inline" set="null" line="123" static="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc><![CDATA[* Returns the time in milliseconds, relative to the start of
	 * the application. This is a high performance call in order to 
	 * help regulate time-based operations. Depending upon the
	 * target platform, this value may or may not be an absolute
	 * timestamp. If you need an exact time, you should use the
	 * <code>Date</code> object.
	 * @return		A relative time value in milliseconds.]]></haxe_doc>
		</getTimer>
		<getURL public="1" set="method" line="142" static="1">
			<f a="url:?target">
				<t path="nme.net.URLRequest"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Opens a browser window with the specified URL. 
	 * @param	url		The URL to open.
	 * @param	target		An optional window target value.</haxe_doc>
		</getURL>
		<pause public="1" set="method" line="161" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* For supported platforms, the NME application will be
	 * paused. This can help improve response times if fullscreen
	 * native UI element is being used temporarily.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</pause>
		<postUICallback public="1" set="method" line="179" static="1">
			<f a="handler">
				<f a=""><e path="Void"/></f>
				<e path="Void"/>
			</f>
			<haxe_doc>* For some target platforms, NME operates on a separate thread
	 * than the native application UI. In these cases, you can use this
	 * method to make thread-safe calls to the native UI.
	 * 
	 * If the platform does not require thread-safe callbacks, the 
	 * handler method will be called immediately.
	 * @param	handler		The method handler you wish to call when the UI is available.</haxe_doc>
		</postUICallback>
		<resume public="1" set="method" line="196" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Resumes the NME application. For certain platforms,
	 * pausing the application can improve response times when
	 * a fullscreen native UI element is being displayed.
	 * This method is ignored in the Flash and HTML5 targets.</haxe_doc>
		</resume>
		<setPackage public="1" set="method" line="215" static="1">
			<f a="company:file:packageName:version">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Specifies meta-data for the running application. If you are using 
	 * the NME command-line tools, this method will be called automatically
	 * as a part of the default platform templates.
	 * This method is ignored in the Flash and HTML5 targets.
	 * @param	company		The company name for the application.
	 * @param	file		The file name for the application.
	 * @param	packageName		The package name of the application.
	 * @param	version		The version string of the application.</haxe_doc>
		</setPackage>
		<trace public="1" set="method" line="228" static="1">
			<f a="arg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sends a <code>trace</code> call for the current platform.
	 * @param	arg]]></haxe_doc>
		</trace>
		<nmeGetCompany set="method" line="247" static="1"><f a=""><c path="String"/></f></nmeGetCompany>
		<nmeGetCurrent set="method" line="257" static="1"><f a=""><t path="nme.display.MovieClip"/></f></nmeGetCurrent>
		<nmeGetFile set="method" line="271" static="1"><f a=""><c path="String"/></f></nmeGetFile>
		<nmeGetInitHeight set="method" line="281" static="1"><f a=""><c path="Int"/></f></nmeGetInitHeight>
		<nmeGetInitWidth set="method" line="291" static="1"><f a=""><c path="Int"/></f></nmeGetInitWidth>
		<nmeGetPackageName set="method" line="301" static="1"><f a=""><c path="String"/></f></nmeGetPackageName>
		<nmeGetStage set="method" line="311" static="1"><f a=""><t path="nme.display.Stage"/></f></nmeGetStage>
		<nmeGetVersion set="method" line="323" static="1"><f a=""><c path="String"/></f></nmeGetVersion>
	</class>
	<typedef path="nme.Vector" params="T" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/Vector.hx"><c path="flash.Vector"><c path="nme.Vector.T"/></c></typedef>
	<typedef path="nme.display.BitmapData" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/BitmapData.hx"><c path="flash.display.BitmapData"/></typedef>
	<typedef path="nme.display.CapsStyle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/CapsStyle.hx"><e path="flash.display.CapsStyle"/></typedef>
	<typedef path="nme.display.DisplayObject" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/DisplayObject.hx"><c path="flash.display.DisplayObject"/></typedef>
	<typedef path="nme.display.DisplayObjectContainer" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/DisplayObjectContainer.hx"><c path="flash.display.DisplayObjectContainer"/></typedef>
	<typedef path="nme.display.GradientType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/GradientType.hx"><e path="flash.display.GradientType"/></typedef>
	<typedef path="nme.display.Graphics" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Graphics.hx"><c path="flash.display.Graphics"/></typedef>
	<typedef path="nme.display.InteractiveObject" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/InteractiveObject.hx"><c path="flash.display.InteractiveObject"/></typedef>
	<typedef path="nme.display.InterpolationMethod" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/InterpolationMethod.hx"><e path="flash.display.InterpolationMethod"/></typedef>
	<typedef path="nme.display.JointStyle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/JointStyle.hx"><e path="flash.display.JointStyle"/></typedef>
	<typedef path="nme.display.MovieClip" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/MovieClip.hx"><c path="flash.display.MovieClip"/></typedef>
	<typedef path="nme.display.Shape" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Shape.hx"><c path="flash.display.Shape"/></typedef>
	<typedef path="nme.display.SpreadMethod" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/SpreadMethod.hx"><e path="flash.display.SpreadMethod"/></typedef>
	<typedef path="nme.display.Sprite" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Sprite.hx"><c path="flash.display.Sprite"/></typedef>
	<typedef path="nme.display.Stage" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Stage.hx"><c path="flash.display.Stage"/></typedef>
	<typedef path="nme.display.StageAlign" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/StageAlign.hx"><e path="flash.display.StageAlign"/></typedef>
	<typedef path="nme.display.StageScaleMode" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/StageScaleMode.hx"><e path="flash.display.StageScaleMode"/></typedef>
	<class path="nme.display.Tilesheet" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/display/Tilesheet.hx">
		<TILE_SCALE public="1" get="inline" set="null" line="59" static="1"><c path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" get="inline" set="null" line="60" static="1"><c path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" get="inline" set="null" line="61" static="1"><c path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" get="inline" set="null" line="62" static="1"><c path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" get="inline" set="null" line="66" static="1"><c path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" get="inline" set="null" line="69" static="1"><c path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" get="inline" set="null" line="70" static="1"><c path="Int"/></TILE_BLEND_ADD>
		<defaultRatio line="77" static="1"><t path="nme.geom.Point"/></defaultRatio>
		<drawTiles public="1" set="method" line="193">
			<f a="graphics:tileData:?smooth:?flags">
				<t path="nme.display.Graphics"/>
				<c path="Array"><c path="Float"/></c>
				<e path="Bool"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Fast method to draw a batch of tiles using a Tilesheet
	 * 
	 * The input array accepts the x, y and tile ID for each tile you wish to draw.
	 * For example, an array of [ 0, 0, 0, 10, 10, 1 ] would draw tile 0 to (0, 0) and
	 * tile 1 to (10, 10)
	 * 
	 * You can also set flags for TILE_SCALE, TILE_ROTATION, TILE_RGB and
	 * TILE_ALPHA.
	 * 
	 * Depending on which flags are active, this is the full order of the array:
	 * 
	 * [ x, y, tile ID, scale, rotation, red, green, blue, alpha, x, y ... ]
	 * 
	 * @param	graphics		The neash.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether drawn tiles should be smoothed (Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing (Default: 0)</haxe_doc>
		</drawTiles>
		<adjustLen set="method" line="162"><f a="vec:len">
	<t path="nme.Vector"><c path="Float"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Float"/></t>
</f></adjustLen>
		<adjustIndices set="method" line="131"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIndices>
		<adjustIDs set="method" line="116"><f a="vec:len">
	<t path="nme.Vector"><c path="Int"/></t>
	<t path="UInt"/>
	<t path="nme.Vector"><c path="Int"/></t>
</f></adjustIDs>
		<addTileRect public="1" set="method" line="107"><f a="rectangle:?centerPoint">
	<t path="nme.geom.Rectangle"/>
	<t path="nme.geom.Point"/>
	<e path="Void"/>
</f></addTileRect>
		<_uvs><t path="nme.Vector"><c path="Float"/></t></_uvs>
		<_indices><t path="nme.Vector"><c path="Int"/></t></_indices>
		<_vertices><t path="nme.Vector"><c path="Float"/></t></_vertices>
		<_ids><t path="nme.Vector"><c path="Int"/></t></_ids>
		<tileUVs><c path="Array"><t path="nme.geom.Rectangle"/></c></tileUVs>
		<tiles><c path="Array"><t path="nme.geom.Rectangle"/></c></tiles>
		<tilePoints><c path="Array"><t path="nme.geom.Point"/></c></tilePoints>
		<bitmapWidth><c path="Int"/></bitmapWidth>
		<bitmapHeight><c path="Int"/></bitmapHeight>
		<nmeBitmap public="1">
			<t path="nme.display.BitmapData"/>
			<haxe_doc>* @private</haxe_doc>
		</nmeBitmap>
		<new public="1" set="method" line="89"><f a="inImage">
	<t path="nme.display.BitmapData"/>
	<e path="Void"/>
</f></new>
	</class>
	<typedef path="nme.events.Event" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/Event.hx"><c path="flash.events.Event"/></typedef>
	<typedef path="nme.events.FocusEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/FocusEvent.hx"><c path="flash.events.FocusEvent"/></typedef>
	<typedef path="nme.events.KeyboardEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/KeyboardEvent.hx"><c path="flash.events.KeyboardEvent"/></typedef>
	<typedef path="nme.events.MouseEvent" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/events/MouseEvent.hx"><c path="flash.events.MouseEvent"/></typedef>
	<typedef path="nme.filters.BitmapFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/filters/BitmapFilter.hx"><c path="flash.filters.BitmapFilter"/></typedef>
	<typedef path="nme.filters.DropShadowFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/filters/DropShadowFilter.hx"><c path="flash.filters.DropShadowFilter"/></typedef>
	<typedef path="nme.filters.GlowFilter" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/filters/GlowFilter.hx"><c path="flash.filters.GlowFilter"/></typedef>
	<typedef path="nme.geom.Matrix" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/geom/Matrix.hx"><c path="flash.geom.Matrix"/></typedef>
	<typedef path="nme.geom.Point" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/geom/Point.hx"><c path="flash.geom.Point"/></typedef>
	<typedef path="nme.geom.Rectangle" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/geom/Rectangle.hx"><c path="flash.geom.Rectangle"/></typedef>
	<typedef path="nme.media.Sound" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/media/Sound.hx"><c path="flash.media.Sound"/></typedef>
	<typedef path="nme.net.URLRequest" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/net/URLRequest.hx"><c path="flash.net.URLRequest"/></typedef>
	<typedef path="nme.text.AntiAliasType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/AntiAliasType.hx"><e path="flash.text.AntiAliasType"/></typedef>
	<typedef path="nme.text.Font" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/Font.hx"><c path="flash.text.Font"/></typedef>
	<typedef path="nme.text.TextField" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/TextField.hx"><c path="flash.text.TextField"/></typedef>
	<typedef path="nme.text.TextFieldType" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/TextFieldType.hx"><e path="flash.text.TextFieldType"/></typedef>
	<typedef path="nme.text.TextFormat" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/text/TextFormat.hx"><c path="flash.text.TextFormat"/></typedef>
	<typedef path="nme.utils.ByteArray" params="" file="C:\Motion-Twin\haxe\lib\nme/3,4,3/nme/utils/ByteArray.hx"><c path="flash.utils.ByteArray"/></typedef>
	<class path="org.tbyrne.collections.UniqueList" params="T" file="../../Composure/src/org/tbyrne/collections/UniqueList.hx">
		<clear public="1" set="method" line="50"><f a=""><e path="Void"/></f></clear>
		<remove public="1" set="method" line="42"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></remove>
		<containsItem public="1" set="method" line="39"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></containsItem>
		<add public="1" set="method" line="31"><f a="value">
	<c path="org.tbyrne.collections.UniqueList.T"/>
	<e path="Bool"/>
</f></add>
		<first public="1" set="method" line="27"><f a=""><t path="Null"><c path="org.tbyrne.collections.UniqueList.T"/></t></f></first>
		<_length><c path="Int"/></_length>
		<list><c path="haxe.FastList"><c path="org.tbyrne.collections.UniqueList.T"/></c></list>
		<get_length set="method" line="18"><f a=""><c path="Int"/></f></get_length>
		<length public="1" get="get_length" set="null"><c path="Int"/></length>
		<iterator public="1" set="method" line="14"><f a=""><t path="Iterator"><c path="org.tbyrne.collections.UniqueList.T"/></t></f></iterator>
		<new public="1" set="method" line="6"><f a="?list">
	<t path="Iterable"><c path="org.tbyrne.collections.UniqueList.T"/></t>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.tbyrne.logging.ILogger" params="" file="../../Composure/src/org/tbyrne/logging/ILogger.hx" interface="1">
		<log public="1" set="method"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LogMsg" params="" file="../../Composure/src/org/tbyrne/logging/LogMsg.hx">
		<toString public="1" set="method" line="24">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Used by trace when Logging hasn't been setup.</haxe_doc>
		</toString>
		<title public="1"><c path="String"/></title>
		<types public="1"><c path="Array"><c path="String"/></c></types>
		<message public="1"><c path="String"/></message>
		<id public="1"><c path="String"/></id>
		<new public="1" set="method" line="15"><f a="?message:?types:?title:?id">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LogType" params="" file="../../Composure/src/org/tbyrne/logging/LogMsg.hx" module="org.tbyrne.logging.LogMsg">
		<devInfo public="1" static="1"><c path="String"/></devInfo>
		<devWarning public="1" static="1"><c path="String"/></devWarning>
		<devError public="1" static="1"><c path="String"/></devError>
		<userInfo public="1" static="1"><c path="String"/></userInfo>
		<userWarning public="1" static="1"><c path="String"/></userWarning>
		<userError public="1" static="1"><c path="String"/></userError>
		<performanceWarning public="1" static="1"><c path="String"/></performanceWarning>
		<deprecationWarning public="1" static="1"><c path="String"/></deprecationWarning>
		<externalError public="1" static="1"><c path="String"/></externalError>
	</class>
	<class path="org.tbyrne.logging.LogUtils" params="" file="../../Composure/src/org/tbyrne/logging/LogUtils.hx">
		<formatMsg public="1" set="method" line="12" static="1"><f a="logMsg:addLine:infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<e path="Bool"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.LoggerList" params="" file="../../Composure/src/org/tbyrne/logging/LoggerList.hx">
		<nativeTrace public="1" get="get_nativeTrace" set="null" static="1"><d/></nativeTrace>
		<get_nativeTrace set="method" line="17" static="1"><f a=""><d/></f></get_nativeTrace>
		<fallbackLogger public="1" static="1"><c path="org.tbyrne.logging.ILogger"/></fallbackLogger>
		<_inited line="26" static="1"><e path="Bool"/></_inited>
		<init set="method" line="27" static="1"><f a=""><e path="Void"/></f></init>
		<_nativeTrace static="1"><d/></_nativeTrace>
		<_loggers static="1"><c path="Hash"><c path="Array"><c path="org.tbyrne.logging.ILogger"/></c></c></_loggers>
		<defaultTypes public="1" static="1"><c path="Array"><c path="String"/></c></defaultTypes>
		<install public="1" set="method" line="41" static="1"><f a=""><e path="Void"/></f></install>
		<trace public="1" set="method" line="54" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<log public="1" set="method" line="68" static="1"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<addLogger public="1" set="method" line="94" static="1"><f a="logger:types">
	<c path="org.tbyrne.logging.ILogger"/>
	<c path="Array"><c path="String"/></c>
	<e path="Void"/>
</f></addLogger>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.loggers.ErrorThrowingLogger" params="" file="../../Composure/src/org/tbyrne/logging/loggers/ErrorThrowingLogger.hx">
		<implements path="org.tbyrne.logging.ILogger"/>
		<formatMsg set="method" line="22"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<log public="1" set="method" line="19"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<new public="1" set="method" line="15"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.loggers.FlashTraceLogger" params="" file="../../Composure/src/org/tbyrne/logging/loggers/FlashTraceLogger.hx">
		<implements path="org.tbyrne.logging.ILogger"/>
		<formatMsg set="method" line="32"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<log public="1" set="method" line="19"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<new public="1" set="method" line="16"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
	<class path="org.tbyrne.logging.loggers.HaxeLogger" params="" file="../../Composure/src/org/tbyrne/logging/loggers/HaxeLogger.hx">
		<implements path="org.tbyrne.logging.ILogger"/>
		<formatMsg set="method" line="20"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<c path="String"/>
</f></formatMsg>
		<log public="1" set="method" line="17"><f a="logMsg:?infos">
	<c path="org.tbyrne.logging.LogMsg"/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<new public="1" set="method" line="14"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Tom Byrne</haxe_doc>
	</class>
</haxe>